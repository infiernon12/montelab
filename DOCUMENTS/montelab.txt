Ð¡Ñ‚Ñ€ÑƒÐºÑ‚ÑƒÑ€Ð° Ð¿Ñ€Ð¾ÐµÐºÑ‚Ð°:

/montelab/
|-- main.py
|-- main_adaptive.py
|-- main_start.py
|-- MonteCarlo-Poker-master/
|   |-- Ñ„Ð°Ð¹Ð»Ñ‹ Ð¼Ð¾Ð´ÑƒÐ»Ñ Ð¼Ð¾Ð½Ñ‚Ðµ-ÐºÐ°Ñ€Ð»Ð¾ Ð½Ð° Ð¡++ 
|-- core
|-- |-- domain
|   |   |-- __init__.py                  #init.py(domain)
|   |   |-- card.py
|   |   |-- detection.py
|   |   |-- game_state.py
|-- |-- poker
|   |   |-- __init__.py                 #init.py(poker)
|   |   |-- board_analyzer.py
|   |   |-- equity_calculator.py
|   |   |-- hand_evaluator.py
|   |   |-- monte_carlo_backend.py
|   |   |-- outs_calculator.py
|-- ml
|   |-- __init__.py                     #init.py(ml)
|   |-- detector.py
|-- models
|   |-- Ð¼Ð¾Ð´ÐµÐ»Ð¸ Ð½ÐµÐ¹Ñ€Ð¾ÑÐµÑ‚ÐµÐ¹ YOLO Ð¸ ResNet34
|-- services
|   |-- __init__.py                     #init.py(services)
|   |-- analysis_service.py
|   |-- ml_service.py
|   |-- improved_abc_recommendations.py
|-- ui
|   |-- dock_widgets.py
|   |-- hwid_dialog.py
|   |-- styles.py
|   |-- ui_config.py
|-- |-- widgets
|   |   |-- __init__.py                 #init.py(widgets)
|   |   |-- card_input.py
|   |   |-- selection_overlay.py
|-- |-- windows
|   |   |-- __init__.py                 #init.py(windows)
|   |   |-- adaptive_main_window.py
|   |   |-- main_window.py
|-- utils
|   |-- __init__.py                     #init.py(utils)
|   |-- hwid_generator.py
|   |-- licencs_client.py
|   |-- screen_capture.py
|   |-- global_hotkeys.py

ÐŸÐ°Ð¿ÐºÐ¸ Ð² ÐºÐ¾Ñ‚Ð¾Ñ€Ñ‹Ñ… Ð½Ðµ ÑƒÐºÐ°Ð·Ð°Ð½ __init__.py - ÑÑ‚Ð¾ Ð·Ð½Ð°Ñ‡Ð¸Ñ‚ Ñ‡Ñ‚Ð¾ Ð¾Ð½ ÐµÑÑ‚ÑŒ, Ð½Ð¾ Ð¿ÑƒÑÑ‚Ð¾Ð¹.

Ð¤Ð°Ð¹Ð»Ñ‹ Ð¸ Ð¸Ñ… ÑÐ¾Ð´ÐµÑ€Ð¶Ð¸Ð¼Ð¾Ðµ:

==========================
main.py
==========================




"""Main application entry point - Refactored"""
import sys
import logging
from pathlib import Path
from PySide6.QtWidgets import QApplication, QMessageBox
from utils.hwid_generator import HWIDGenerator
from utils.license_client import LicenseClient
from ui.hwid_dialog import HWIDDialog

# Setup logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)


def check_license(app):
    """Check license before starting application"""
    try:
        # Generate HWID
        hwid = HWIDGenerator.generate_hwid()
        logger.info(f"Generated HWID: {hwid}")
        
        # Initialize license client
        hmac_secret = "28de6a1eb3b9e9edb29c886a43d71964935bd12cb981cc2e604381076d73f6660fdca0a6092ee4b055882859563e7c373472d01d28d0e91cefa810bc1106c572"
        license_client = LicenseClient(
            api_base_url="https://185.221.196.69:8000/api/v1",
            hmac_secret_key=hmac_secret,
            hwid=hwid
        )
        
        # Check license
        logger.info("Checking license...")
        is_licensed = license_client.check_license()
        
        if not is_licensed:
            logger.warning("âš ï¸ License not active")
            # Show HWID dialog
            dialog = HWIDDialog()
            dialog.exec()
            return False
        
        logger.info("âœ… License verified successfully")
        return True
        
    except Exception as e:
        logger.error(f"License check failed: {e}")
        # Show error message
        QMessageBox.critical(
            None,
            "ÐžÑˆÐ¸Ð±ÐºÐ° Ð»Ð¸Ñ†ÐµÐ½Ð·Ð¸Ð¸",
            f"ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ð¿Ñ€Ð¾Ð²ÐµÑ€Ð¸Ñ‚ÑŒ Ð»Ð¸Ñ†ÐµÐ½Ð·Ð¸ÑŽ:\n{str(e)}\n\nÐŸÑ€Ð¸Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ Ð±ÑƒÐ´ÐµÑ‚ Ð·Ð°ÐºÑ€Ñ‹Ñ‚Ð¾."
        )
        return False


def main():
    """Application entry point"""
    logger.info("=" * 60)
    logger.info("MonteLab - Refactored Architecture")
    logger.info("=" * 60)
    
    try:
        app = QApplication(sys.argv)
        app.setApplicationName("MonteLab")
        app.setApplicationVersion("2.0-Refactored")
        
        # Check license before proceeding
        if not check_license(app):
            logger.info("Application terminated: License not verified")
            return 1
        
        # Apply dark theme
        app.setStyle("Fusion")
        from ui.styles import apply_dark_theme
        apply_dark_theme(app)
        
        # Initialize services
        from services.ml_service import MLService
        from core.poker import EquityCalculator, CppMonteCarloBackend
        from services.analysis_service import AnalysisService
        
        # Load ML models
        script_dir = Path(__file__).parent
        yolo_path = script_dir / "models" / "board_player_detector_v4.pt"
        resnet_path = script_dir / "models" / "fine_tuned_resnet_cards_240EPOCH.pt"
        
        ml_service = MLService.from_weights(str(yolo_path), str(resnet_path), "cpu")
        
        # Initialize Monte Carlo backend
        try:
            monte_carlo_backend = CppMonteCarloBackend()
            equity_calculator = EquityCalculator(backend=monte_carlo_backend)
            logger.info("âœ… Monte Carlo backend initialized successfully")
        except Exception as e:
            logger.warning(f"âš ï¸  Monte Carlo backend unavailable: {e}")
            equity_calculator = EquityCalculator(backend=None)
        
        analysis_service = AnalysisService(equity_calculator)
        
        # Create main window
        from ui.windows.main_window import MainWindow
        window = MainWindow(ml_service, analysis_service)
        window.show()
        
        logger.info("Application started successfully")
        logger.info("Features enabled:")
        logger.info(f"  â€¢ ML Card Detection: {'âœ…' if ml_service.is_available else 'âŒ'}")
        logger.info(f"  â€¢ Monte Carlo Equity: {'âœ…' if equity_calculator.backend else 'âŒ'}")
        logger.info("")
        
        return app.exec()
        
    except Exception as e:
        logger.critical(f"Application startup failed: {e}", exc_info=True)
        return 1


if __name__ == "__main__":
    sys.exit(main())




==========================
main_adaptive.py
==========================




"""Main application entry point - With Adaptive UI"""
import sys
import logging
from pathlib import Path
from PySide6.QtWidgets import QApplication, QMessageBox
from utils.hwid_generator import HWIDGenerator
from utils.license_client import LicenseClient
from ui.hwid_dialog import HWIDDialog

# Setup logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)


def check_license(app):
    """Check license before starting application"""
    try:
        # Generate HWID
        hwid = HWIDGenerator.generate_hwid()
        logger.info(f"Generated HWID: {hwid}")
        
        # Initialize license client
        hmac_secret = "28de6a1eb3b9e9edb29c886a43d71964935bd12cb981cc2e604381076d73f6660fdca0a6092ee4b055882859563e7c373472d01d28d0e91cefa810bc1106c572"
        license_client = LicenseClient(
            api_base_url="https://185.221.196.69:8000/api/v1/",
            hmac_secret_key=hmac_secret,
            hwid=hwid
        )
        
        # Check license
        logger.info("Checking license...")
        is_licensed = license_client.check_license()
        
        if not is_licensed:
            logger.warning("âš ï¸ License not active")
            # Show HWID dialog
            dialog = HWIDDialog()
            dialog.exec()
            return False
        
        logger.info("âœ… License verified successfully")
        return True
        
    except Exception as e:
        logger.error(f"License check failed: {e}")
        # Show error message
        QMessageBox.critical(
            None,
            "ÐžÑˆÐ¸Ð±ÐºÐ° Ð»Ð¸Ñ†ÐµÐ½Ð·Ð¸Ð¸",
            f"ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ð¿Ñ€Ð¾Ð²ÐµÑ€Ð¸Ñ‚ÑŒ Ð»Ð¸Ñ†ÐµÐ½Ð·Ð¸ÑŽ:\n{str(e)}\n\nÐŸÑ€Ð¸Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ Ð±ÑƒÐ´ÐµÑ‚ Ð·Ð°ÐºÑ€Ñ‹Ñ‚Ð¾."
        )
        return False


def main():
    """Application entry point"""
    logger.info("=" * 60)
    logger.info("MonteLab - Adaptive UI Version")
    logger.info("=" * 60)
    
    try:
        app = QApplication(sys.argv)
        app.setApplicationName("MonteLab")
        app.setApplicationVersion("2.0-Adaptive")
        
        # Check license before proceeding
        if not check_license(app):
            logger.info("Application terminated: License not verified")
            return 1
        
        # Apply dark theme
        app.setStyle("Fusion")
        from ui.styles import apply_dark_theme
        apply_dark_theme(app)
        
        # Initialize services
        from services.ml_service import MLService
        from core.poker import EquityCalculator, CppMonteCarloBackend
        from services.analysis_service import AnalysisService
        
        # Load ML models
        script_dir = Path(__file__).parent
        yolo_path = script_dir / "models" / "board_player_detector_v4.pt"
        resnet_path = script_dir / "models" / "fine_tuned_resnet_cards_240EPOCH.pt"
        
        ml_service = MLService.from_weights(str(yolo_path), str(resnet_path), "cpu")
        
        # Initialize Monte Carlo backend
        try:
            monte_carlo_backend = CppMonteCarloBackend()
            equity_calculator = EquityCalculator(backend=monte_carlo_backend)
            logger.info("âœ… Monte Carlo backend initialized successfully")
        except Exception as e:
            logger.warning(f"âš ï¸  Monte Carlo backend unavailable: {e}")
            equity_calculator = EquityCalculator(backend=None)
        
        analysis_service = AnalysisService(equity_calculator)
        
        # Create adaptive main window
        from ui.windows.adaptive_main_window import AdaptiveMainWindow
        window = AdaptiveMainWindow(ml_service, analysis_service)
        window.show()
        
        logger.info("âœ… Adaptive UI initialized successfully")
        logger.info("Features enabled:")
        logger.info(f"  â€¢ ML Card Detection: {'âœ…' if ml_service.is_available else 'âŒ'}")
        logger.info(f"  â€¢ Monte Carlo Equity: {'âœ…' if equity_calculator.backend else 'âŒ'}")
        logger.info(f"  â€¢ Adaptive Dockable UI: âœ…")
        logger.info(f"  â€¢ Persistent Layout: âœ…")
        logger.info("")
        
        return app.exec()
        
    except Exception as e:
        logger.critical(f"Application startup failed: {e}", exc_info=True)
        return 1


if __name__ == "__main__":
    sys.exit(main())






==========================
main_start.py
==========================




"""
MonteLab - Advanced Poker Analysis Tool
Main entry point with license validation and UI selection
"""

import sys
import logging
from pathlib import Path
from PySide6.QtWidgets import QApplication, QMessageBox, QDialog, QVBoxLayout, QLabel, QPushButton, QButtonGroup, QRadioButton, QGroupBox
from PySide6.QtCore import Qt
from PySide6.QtGui import QFont

# Setup logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('montelab.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)


class UISelectionDialog(QDialog):
    """Dialog for selecting UI mode after license validation"""
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.selected_mode = None
        self.setup_ui()
    
    def setup_ui(self):
        """Setup UI selection dialog"""
        self.setWindowTitle("MonteLab - Select Interface")
        self.setFixedSize(500, 350)
        self.setModal(True)
        
        layout = QVBoxLayout(self)
        layout.setContentsMargins(25, 25, 25, 25)
        layout.setSpacing(20)
        
        # Title
        title = QLabel("ðŸŽ® Choose Your Interface")
        title.setAlignment(Qt.AlignmentFlag.AlignCenter)
        title_font = QFont()
        title_font.setPointSize(18)
        title_font.setBold(True)
        title.setFont(title_font)
        title.setStyleSheet("color: #4CAF50; padding: 10px;")
        layout.addWidget(title)
        
        # Description
        desc = QLabel("Select the interface that best suits your workflow:")
        desc.setAlignment(Qt.AlignmentFlag.AlignCenter)
        desc.setStyleSheet("color: #ccc; font-size: 13px; padding: 5px;")
        desc.setWordWrap(True)
        layout.addWidget(desc)
        
        # UI mode selection group
        mode_group = QGroupBox("Interface Modes")
        mode_layout = QVBoxLayout(mode_group)
        mode_layout.setSpacing(15)
        
        self.button_group = QButtonGroup(self)
        
        # Classic mode option
        self.classic_radio = QRadioButton("ðŸ“Š Classic Mode")
        self.classic_radio.setStyleSheet("""
            QRadioButton {
                font-size: 14px;
                font-weight: bold;
                color: #fff;
                padding: 10px;
            }
            QRadioButton::indicator {
                width: 20px;
                height: 20px;
            }
        """)
        classic_desc = QLabel("Traditional single-window interface with all controls in one view.\nBest for: Single monitor setups, focused analysis")
        classic_desc.setStyleSheet("color: #aaa; font-size: 11px; padding-left: 30px; margin-bottom: 10px;")
        classic_desc.setWordWrap(True)
        
        # Adaptive mode option
        self.adaptive_radio = QRadioButton("ðŸŽ¯ Adaptive Mode")
        self.adaptive_radio.setStyleSheet("""
            QRadioButton {
                font-size: 14px;
                font-weight: bold;
                color: #fff;
                padding: 10px;
            }
            QRadioButton::indicator {
                width: 20px;
                height: 20px;
            }
        """)
        adaptive_desc = QLabel("Modern dockable interface with floating panels and persistent layout.\nBest for: Multi-monitor setups, customizable workspace")
        adaptive_desc.setStyleSheet("color: #aaa; font-size: 11px; padding-left: 30px; margin-bottom: 10px;")
        adaptive_desc.setWordWrap(True)
        
        self.button_group.addButton(self.classic_radio, 1)
        self.button_group.addButton(self.adaptive_radio, 2)
        
        # Set default selection
        self.adaptive_radio.setChecked(True)
        
        mode_layout.addWidget(self.classic_radio)
        mode_layout.addWidget(classic_desc)
        mode_layout.addWidget(self.adaptive_radio)
        mode_layout.addWidget(adaptive_desc)
        
        layout.addWidget(mode_group)
        
        # Buttons
        button_layout = QVBoxLayout()
        button_layout.setSpacing(10)
        
        self.start_btn = QPushButton("ðŸš€ Start MonteLab")
        self.start_btn.setStyleSheet("""
            QPushButton {
                background-color: #4CAF50;
                color: white;
                border: none;
                padding: 12px;
                border-radius: 6px;
                font-weight: bold;
                font-size: 14px;
            }
            QPushButton:hover {
                background-color: #45a049;
            }
            QPushButton:pressed {
                background-color: #3d8b40;
            }
        """)
        self.start_btn.clicked.connect(self.on_start)
        
        self.cancel_btn = QPushButton("âŒ Exit")
        self.cancel_btn.setStyleSheet("""
            QPushButton {
                background-color: #666;
                color: white;
                border: none;
                padding: 10px;
                border-radius: 6px;
                font-weight: bold;
                font-size: 12px;
            }
            QPushButton:hover {
                background-color: #777;
            }
            QPushButton:pressed {
                background-color: #555;
            }
        """)
        self.cancel_btn.clicked.connect(self.reject)
        
        button_layout.addWidget(self.start_btn)
        button_layout.addWidget(self.cancel_btn)
        
        layout.addLayout(button_layout)
        
        # Apply dialog style
        self.setStyleSheet("""
            QDialog {
                background-color: #2b2b2b;
            }
            QGroupBox {
                font-weight: bold;
                font-size: 13px;
                border: 2px solid #555;
                border-radius: 8px;
                margin-top: 10px;
                padding-top: 15px;
                background-color: #1e1e1e;
            }
            QGroupBox::title {
                color: #4CAF50;
                subcontrol-origin: margin;
                left: 15px;
                padding: 0 5px;
            }
        """)
    
    def on_start(self):
        """Handle start button click"""
        if self.classic_radio.isChecked():
            self.selected_mode = "classic"
        else:
            self.selected_mode = "adaptive"
        
        logger.info(f"User selected UI mode: {self.selected_mode}")
        self.accept()
    
    def get_selected_mode(self):
        """Get selected UI mode"""
        return self.selected_mode


def check_license():
    """
    Perform license validation
    Returns: True if valid license, False otherwise
    """
    try:
        from utils.hwid_generator import HWIDGenerator
        from utils.license_client import LicenseClient
        from ui.hwid_dialog import HWIDDialog
        
        # Generate HWID
        hwid = HWIDGenerator.generate_hwid()
        logger.info(f"Generated HWID: {hwid}")
        
        # Initialize license client
        api_url = "https://185.221.196.69:8000/api/v1/"
        secret_key = "28de6a1eb3b9e9edb29c886a43d71964935bd12cb981cc2e604381076d73f6660fdca0a6092ee4b055882859563e7c373472d01d28d0e91cefa810bc1106c572"
        
        license_client = LicenseClient(api_url, secret_key, hwid)
        
        # Check license
        logger.info("Checking license...")
        is_valid = license_client.check_license()
        
        if not is_valid:
            logger.warning("License validation failed - showing HWID dialog")
            
            # Show HWID dialog for user to get license
            hwid_dialog = HWIDDialog()
            result = hwid_dialog.exec()
            
            if result == QDialog.DialogCode.Rejected:
                logger.info("User closed HWID dialog")
                return False
            
            # User may have obtained license - check again
            logger.info("Rechecking license after HWID dialog...")
            is_valid = license_client.check_license()
            
            if not is_valid:
                QMessageBox.critical(
                    None,
                    "License Required",
                    "Valid license not found. Please contact administrator with your HWID.\n\n"
                    "Application will now exit."
                )
                return False
        
        logger.info("License validation successful")
        return True
        
    except Exception as e:
        logger.error(f"License check error: {e}", exc_info=True)
        QMessageBox.critical(
            None,
            "License Error",
            f"Failed to validate license:\n{str(e)}\n\nApplication will exit."
        )
        return False


def initialize_services():
    """
    Initialize ML and analysis services
    Returns: (ml_service, analysis_service) or (None, None) on failure
    """
    try:
        from services.ml_service import MLService
        from services.analysis_service import AnalysisService
        from core.poker import EquityCalculator, CppMonteCarloBackend
        
        # Model paths
        script_dir = Path(__file__).parent
        
        yolo_path = script_dir / "models" / "board_player_detector_v4.pt"
        resnet_path = script_dir / "models" / "fine_tuned_resnet_cards_240EPOCH.pt"
        
        # Initialize ML service
        logger.info("Initializing ML service...")
        if yolo_path.exists() and resnet_path.exists():
            ml_service = MLService.from_weights(
                str(yolo_path),
                str(resnet_path),
                device="cpu"
            )
            logger.info("ML service initialized successfully")
        else:
            logger.warning(f"Model files not found: YOLO={yolo_path.exists()}, ResNet={resnet_path.exists()}")
            ml_service = MLService(None, None)
        
        # Initialize Monte Carlo backend
        logger.info("Initializing Monte Carlo backend...")
        try:
            mc_backend = CppMonteCarloBackend()
            equity_calculator = EquityCalculator(backend=mc_backend)
            logger.info("Monte Carlo backend initialized successfully")
        except Exception as e:
            logger.warning(f"Monte Carlo backend unavailable: {e}")
            equity_calculator = EquityCalculator(backend=None)
        
        # Initialize analysis service
        analysis_service = AnalysisService(equity_calculator)
        logger.info("Analysis service initialized successfully")
        
        return ml_service, analysis_service
        
    except Exception as e:
        logger.error(f"Service initialization error: {e}", exc_info=True)
        QMessageBox.critical(
            None,
            "Initialization Error",
            f"Failed to initialize services:\n{str(e)}\n\nApplication will exit."
        )
        return None, None


def launch_classic_ui(ml_service, analysis_service):
    """Launch classic single-window UI"""
    try:
        from ui.windows.main_window import MainWindow
        
        logger.info("Launching Classic UI...")
        window = MainWindow(ml_service, analysis_service)
        window.show()
        return window
        
    except Exception as e:
        logger.error(f"Failed to launch Classic UI: {e}", exc_info=True)
        QMessageBox.critical(
            None,
            "UI Error",
            f"Failed to launch Classic interface:\n{str(e)}"
        )
        return None


def launch_adaptive_ui(ml_service, analysis_service):
    """Launch adaptive dockable UI"""
    try:
        from ui.windows.adaptive_main_window import AdaptiveMainWindow
        
        logger.info("Launching Adaptive UI...")
        window = AdaptiveMainWindow(ml_service, analysis_service)
        window.show()
        return window
        
    except Exception as e:
        logger.error(f"Failed to launch Adaptive UI: {e}", exc_info=True)
        QMessageBox.critical(
            None,
            "UI Error",
            f"Failed to launch Adaptive interface:\n{str(e)}"
        )
        return None


def main():
    """Main application entry point"""
    logger.info("=" * 60)
    logger.info("MonteLab - Advanced Poker Analysis Tool")
    logger.info("Starting application...")
    logger.info("=" * 60)
    
    # Create Qt application
    app = QApplication(sys.argv)
    app.setApplicationName("MonteLab")
    app.setOrganizationName("MonteLab")
    
    # Apply dark theme
    try:
        from ui.styles import apply_dark_theme
        apply_dark_theme(app)
        logger.info("Dark theme applied")
    except Exception as e:
        logger.warning(f"Failed to apply theme: {e}")
    
    # Step 1: License validation
    logger.info("Step 1: License validation")
    if not check_license():
        logger.error("License validation failed - exiting")
        return 1
    
    logger.info("âœ… License validation passed")
    
    # Step 2: Initialize services
    logger.info("Step 2: Initializing services")
    ml_service, analysis_service = initialize_services()
    
    if ml_service is None or analysis_service is None:
        logger.error("Service initialization failed - exiting")
        return 1
    
    logger.info("âœ… Services initialized")
    
    # Step 3: UI mode selection
    logger.info("Step 3: UI mode selection")
    selection_dialog = UISelectionDialog()
    
    if selection_dialog.exec() != QDialog.DialogCode.Accepted:
        logger.info("User cancelled UI selection - exiting")
        return 0
    
    selected_mode = selection_dialog.get_selected_mode()
    logger.info(f"âœ… Selected mode: {selected_mode}")
    
    # Step 4: Launch selected UI
    logger.info(f"Step 4: Launching {selected_mode} UI")
    
    if selected_mode == "classic":
        window = launch_classic_ui(ml_service, analysis_service)
    else:  # adaptive
        window = launch_adaptive_ui(ml_service, analysis_service)
    
    if window is None:
        logger.error("Failed to launch UI - exiting")
        return 1
    
    logger.info("âœ… UI launched successfully")
    logger.info("=" * 60)
    logger.info("Application ready - entering event loop")
    logger.info("=" * 60)
    
    # Run application
    exit_code = app.exec()
    
    logger.info("=" * 60)
    logger.info(f"Application exiting with code: {exit_code}")
    logger.info("=" * 60)
    
    return exit_code


if __name__ == "__main__":
    try:
        sys.exit(main())
    except Exception as e:
        logger.critical(f"Unhandled exception: {e}", exc_info=True)
        QMessageBox.critical(
            None,
            "Critical Error",
            f"Unhandled exception occurred:\n{str(e)}\n\nApplication will exit."
        )
        sys.exit(1)




==========================
init.py(domain)
==========================





"""Domain models package - Pure data structures with no business logic"""
from .card import Card
from .game_state import GameState, GameStage, TableSize, GameType, Position, Action
from .detection import DetectedCard

__all__ = [
    'Card',
    'GameState',
    'GameStage',
    'TableSize',
    'GameType',
    'Position',
    'Action',
    'DetectedCard'
]





==========================
card.py
==========================




"""Card domain model - Immutable playing card representation"""
from dataclasses import dataclass
from typing import Optional


@dataclass(frozen=True)
class Card:
    """Immutable playing card with validation"""
    rank: str  # 2-9, T, J, Q, K, A
    suit: str  # c, d, h, s
    
    VALID_RANKS = {'2', '3', '4', '5', '6', '7', '8', '9', 'T', 'J', 'Q', 'K', 'A'}
    VALID_SUITS = {'c', 'd', 'h', 's'}
    
    RANK_VALUES = {
        '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9,
        'T': 10, 'J': 11, 'Q': 12, 'K': 13, 'A': 14
    }
    
    def __post_init__(self):
        if self.rank not in self.VALID_RANKS:
            raise ValueError(f"Invalid rank: {self.rank}")
        if self.suit not in self.VALID_SUITS:
            raise ValueError(f"Invalid suit: {self.suit}")
    
    def rank_value(self) -> int:
        """Get numeric value of rank (2=2, ..., A=14)"""
        return self.RANK_VALUES[self.rank]
    
    def __str__(self) -> str:
        return f"{self.rank}{self.suit}"
    
    @classmethod
    def parse(cls, card_str: str) -> Optional['Card']:
        """Parse card from string (e.g. 'As', 'Kh')"""
        if not card_str or len(card_str.strip()) < 2:
            return None
        
        card_str = card_str.strip().upper()
        if len(card_str) != 2:
            return None
        
        rank, suit = card_str[0], card_str[1].lower()
        
        if rank not in cls.VALID_RANKS or suit not in cls.VALID_SUITS:
            return None
        
        return cls(rank, suit)





==========================
detection.py
==========================




"""Detection data model for ML pipeline"""
from dataclasses import dataclass
from typing import Tuple, Optional


@dataclass
class DetectedCard:
    """Detected card with bounding box from ML model"""
    bbox: Tuple[int, int, int, int]  # x1, y1, x2, y2
    kind: str  # "player" or "board"
    score: float
    classification: Optional[str] = None





==========================
game_state.py
==========================




"""Game state enums and data structures"""
from enum import Enum
from dataclasses import dataclass
from typing import List
from .card import Card


class Position(Enum):
    """Player position at the table"""
    UTG = "UTG"
    MP = "MP"
    CO = "CO"
    BTN = "BTN"
    SB = "SB"
    BB = "BB"


class Action(Enum):
    """Available player actions"""
    FOLD = "FOLD"
    CALL = "CALL"
    RAISE = "RAISE"
    ALL_IN = "ALL_IN"


class GameStage(Enum):
    """Current game stage"""
    PREFLOP = "Preflop"
    FLOP = "Flop"
    TURN = "Turn"
    RIVER = "River"


class TableSize(Enum):
    """Table size configurations"""
    HEADS_UP = "heads_up"
    THREE_MAX = "3max"
    FOUR_MAX = "4max"
    FIVE_MAX = "5max"
    SIX_MAX = "6max"
    SEVEN_MAX = "7max"
    EIGHT_MAX = "8max"
    NINE_MAX = "9max"


class GameType(Enum):
    """Game type variants"""
    CASH = "Cash"
    TOURNAMENT = "TTM"


@dataclass
class GameState:
    """Current game state snapshot"""
    table_size: TableSize
    game_type: GameType
    stage: GameStage
    player_cards: List[Card]
    board_cards: List[Card]
    
    def get_opponents_count(self) -> int:
        """Get number of opponents based on table size"""
        opponents_map = {
            TableSize.HEADS_UP: 1,
            TableSize.THREE_MAX: 2,
            TableSize.FOUR_MAX: 3,
            TableSize.FIVE_MAX: 4,
            TableSize.SIX_MAX: 5,
            TableSize.SEVEN_MAX: 6,
            TableSize.EIGHT_MAX: 7,
            TableSize.NINE_MAX: 8
        }
        return opponents_map.get(self.table_size, 1)
    
    def get_players_count(self) -> int:
        """Get total players at table"""
        return self.get_opponents_count() + 1





==========================
init.py(poker)
==========================




"""Poker logic package - Hand evaluation and analysis"""
from .hand_evaluator import HandEvaluator
from .equity_calculator import EquityCalculator, MonteCarloBackend
from .board_analyzer import BoardAnalyzer
from .outs_calculator import OutsCalculator
from .monte_carlo_backend import CppMonteCarloBackend

__all__ = [
    'HandEvaluator',
    'EquityCalculator',
    'MonteCarloBackend',
    'CppMonteCarloBackend',
    'BoardAnalyzer',
    'OutsCalculator'
]





==========================
board_analyzer.py
==========================




"""Board texture analysis"""
from typing import List, Dict
from collections import Counter
from core.domain import Card


class BoardAnalyzer:
    """Analyze board texture and properties"""
    
    def analyze_texture(self, board_cards: List[Card]) -> Dict[str, any]:
        """Comprehensive board texture analysis"""
        if len(board_cards) < 3:
            return {"error": "Need at least 3 board cards"}
        
        suit_counter = Counter(card.suit for card in board_cards)
        rank_counter = Counter(card.rank for card in board_cards)
        rank_values = sorted([card.rank_value() for card in board_cards])
        
        max_suit_count = max(suit_counter.values())
        unique_suits = len(suit_counter)
        max_rank_count = max(rank_counter.values())
        
        return {
            "monotone": max_suit_count >= 3,
            "two_tone": sum(1 for count in suit_counter.values() if count >= 2) >= 2,
            "rainbow": unique_suits >= 3,
            "paired": max_rank_count >= 2,
            "coordinated": self._is_coordinated(rank_values),
            "straight_draws": self._count_straight_draws(rank_values),
            "flush_draw": max_suit_count == 2,
            "dry": max_suit_count == 1 and not self._is_coordinated(rank_values)
        }
    
    def _is_coordinated(self, sorted_ranks: List[int]) -> bool:
        """Check if board is coordinated (connected cards)"""
        if len(sorted_ranks) < 2:
            return False
        
        for i in range(len(sorted_ranks) - 1):
            gap = sorted_ranks[i + 1] - sorted_ranks[i]
            if gap <= 2:
                return True
        return False
    
    def _count_straight_draws(self, sorted_ranks: List[int]) -> int:
        """Count possible straight draws"""
        unique_ranks = sorted(set(sorted_ranks))
        draws = 0
        
        # Regular straights
        for start in range(2, 11):
            straight_ranks = list(range(start, start + 5))
            board_in_straight = [r for r in unique_ranks if r in straight_ranks]
            if len(board_in_straight) >= 3:
                draws += 1
        
        # Wheel
        wheel_ranks = [14, 2, 3, 4, 5]
        board_in_wheel = [r for r in unique_ranks if r in wheel_ranks]
        if len(board_in_wheel) >= 3:
            draws += 1
        
        return draws





==========================
equity_calculator.py
==========================




"""Equity calculator with Monte Carlo backend abstraction"""
from typing import List, Dict, Optional
from abc import ABC, abstractmethod
import logging
from core.domain import Card

logger = logging.getLogger(__name__)


class MonteCarloBackend(ABC):
    """Abstract interface for Monte Carlo simulation backends"""
    
    @abstractmethod
    def calculate_equity(self, hole_cards: List[Card], board_cards: List[Card],
                        num_opponents: int, iterations: int) -> Dict[str, float]:
        """Calculate equity using Monte Carlo simulation"""
        pass


class EquityCalculator:
    """High-level equity calculator with pluggable backends"""
    
    def __init__(self, backend: Optional[MonteCarloBackend] = None):
        self.backend = backend
        if backend is None:
            logger.warning("No Monte Carlo backend provided - equity calculations disabled")
    
    def calculate_equity(self, hole_cards: List[Card], board_cards: List[Card],
                        num_opponents: int = 1, iterations: int = 10000) -> Dict[str, float]:
        """Calculate equity with validation"""
        
        # Validation
        if len(hole_cards) != 2:
            return {"error": "Need exactly 2 hole cards"}
        
        if len(board_cards) > 5:
            return {"error": "Board cannot have more than 5 cards"}
        
        if self.backend is None:
            return {"error": "Monte Carlo backend not available"}
        
        # Delegate to backend
        return self.backend.calculate_equity(hole_cards, board_cards, num_opponents, iterations)





==========================
hand_evaluator.py
==========================




"""Hand evaluation logic - Separated from simulation"""
from typing import List, Tuple, Dict
from collections import Counter
from itertools import combinations
from core.domain import Card


class HandEvaluator:
    """Pure hand strength evaluation without simulation dependencies"""
    
    # Hand type base values (large gaps for kickers)
    HAND_TYPE_BASE = {
        'high_card': 0,
        'one_pair': 10000000,
        'two_pair': 20000000,
        'three_kind': 30000000,
        'straight': 40000000,
        'flush': 50000000,
        'full_house': 60000000,
        'four_kind': 70000000,
        'straight_flush': 80000000
    }
    
    WHEEL_RANKS = {2, 3, 4, 5, 14}
    
    def __init__(self):
        self._cache = {}
    
    def get_best_5_card_hand(self, cards: List[Card]) -> Tuple[List[Card], int]:
        """Find best 5-card hand and numeric strength"""
        if len(cards) < 5:
            return cards, self._evaluate_hand_strength(cards)
        
        if len(cards) == 5:
            return cards, self._evaluate_hand_strength(cards)
        
        best_hand = None
        best_strength = -1
        
        for combo in combinations(cards, 5):
            combo_list = list(combo)
            strength = self._evaluate_hand_strength(combo_list)
            if strength > best_strength:
                best_strength = strength
                best_hand = combo_list
        
        return best_hand, best_strength
    
    def _evaluate_hand_strength(self, cards: List[Card]) -> int:
        """Precise numeric hand strength evaluation"""
        if len(cards) < 2:
            return 0
        
        cards_key = tuple(sorted((c.rank, c.suit) for c in cards))
        if cards_key in self._cache:
            return self._cache[cards_key]
        
        rank_values = [card.rank_value() for card in cards]
        rank_counts = Counter(rank_values)
        suit_counts = Counter(card.suit for card in cards)
        
        ranks_by_count = sorted(rank_counts.items(), key=lambda x: (x[1], x[0]), reverse=True)
        sorted_counts = sorted(rank_counts.values(), reverse=True)
        
        is_flush = max(suit_counts.values()) >= 5
        is_straight, straight_high = self._check_straight(rank_values)
        
        strength = self._calculate_strength(
            sorted_counts, ranks_by_count, is_flush, is_straight, straight_high, suit_counts, cards
        )
        
        self._cache[cards_key] = strength
        return strength
    
    def _calculate_strength(self, sorted_counts, ranks_by_count, is_flush, 
                          is_straight, straight_high, suit_counts, cards) -> int:
        """Calculate numeric strength based on hand type"""
        
        if is_straight and is_flush:
            return self.HAND_TYPE_BASE['straight_flush'] + straight_high
        
        if sorted_counts[0] == 4:
            quad_rank = ranks_by_count[0][0]
            kicker = ranks_by_count[1][0] if len(ranks_by_count) > 1 else 0
            return self.HAND_TYPE_BASE['four_kind'] + quad_rank * 100 + kicker
        
        if sorted_counts[0] == 3 and len(sorted_counts) > 1 and sorted_counts[1] >= 2:
            trips_rank = ranks_by_count[0][0]
            pair_rank = ranks_by_count[1][0]
            return self.HAND_TYPE_BASE['full_house'] + trips_rank * 100 + pair_rank
        
        if is_flush:
            flush_suit = max(suit_counts.keys(), key=suit_counts.get)
            flush_cards = [card for card in cards if card.suit == flush_suit]
            flush_values = sorted([card.rank_value() for card in flush_cards], reverse=True)[:5]
            kicker_score = sum(flush_values[i] * (15 ** (4-i)) for i in range(len(flush_values)))
            return self.HAND_TYPE_BASE['flush'] + kicker_score
        
        if is_straight:
            return self.HAND_TYPE_BASE['straight'] + straight_high
        
        if sorted_counts[0] == 3:
            trips_rank = ranks_by_count[0][0]
            kickers = sorted([r for r, c in ranks_by_count[1:]], reverse=True)[:2]
            kicker_score = sum(kickers[i] * (15 ** (1-i)) for i in range(len(kickers)))
            return self.HAND_TYPE_BASE['three_kind'] + trips_rank * 1000 + kicker_score
        
        if len(sorted_counts) > 1 and sorted_counts[0] == 2 and sorted_counts[1] == 2:
            pairs = sorted([r for r, c in ranks_by_count if c == 2], reverse=True)[:2]
            kicker = max([r for r, c in ranks_by_count if c == 1], default=0)
            return self.HAND_TYPE_BASE['two_pair'] + pairs[0] * 1000 + pairs[1] * 50 + kicker
        
        if sorted_counts[0] == 2:
            pair_rank = ranks_by_count[0][0]
            kickers = sorted([r for r, c in ranks_by_count[1:]], reverse=True)[:3]
            kicker_score = sum(kickers[i] * (15 ** (2-i)) for i in range(len(kickers)))
            return self.HAND_TYPE_BASE['one_pair'] + pair_rank * 10000 + kicker_score
        
        # High card
        rank_values = [card.rank_value() for card in cards]
        high_cards = sorted(rank_values, reverse=True)[:5]
        kicker_score = sum(high_cards[i] * (15 ** (4-i)) for i in range(len(high_cards)))
        return self.HAND_TYPE_BASE['high_card'] + kicker_score
    
    def _check_straight(self, rank_values: List[int]) -> Tuple[bool, int]:
        """Check for straight and return high card"""
        unique_values = sorted(set(rank_values))
        
        # Wheel (A-2-3-4-5)
        if self.WHEEL_RANKS.issubset(set(unique_values)):
            return True, 5
        
        # Regular straights
        for i in range(len(unique_values) - 4):
            if unique_values[i + 4] - unique_values[i] == 4:
                return True, unique_values[i + 4]
        
        return False, 0
    
    def get_hand_description(self, cards: List[Card]) -> str:
        """Get textual description of hand type"""
        if len(cards) < 2:
            return "High card"
        
        rank_counts = Counter(card.rank for card in cards)
        suit_counts = Counter(card.suit for card in cards)
        
        sorted_counts = sorted(rank_counts.values(), reverse=True)
        max_rank_count = sorted_counts[0]
        is_flush = max(suit_counts.values()) >= 5
        is_straight, _ = self._check_straight([card.rank_value() for card in cards])
        
        if is_straight and is_flush:
            return "Straight flush"
        elif max_rank_count >= 4:
            return "Four of a kind"
        elif max_rank_count == 3 and len(sorted_counts) > 1 and sorted_counts[1] >= 2:
            return "Full house"
        elif is_flush:
            return "Flush"
        elif is_straight:
            return "Straight"
        elif max_rank_count == 3:
            return "Three of a kind"
        elif len(sorted_counts) > 1 and sorted_counts[0] == 2 and sorted_counts[1] == 2:
            return "Two pair"
        elif max_rank_count == 2:
            return "One pair"
        else:
            return "High card"
    
    def get_hand_key(self, hole_cards: List[Card]) -> str:
        """Get hand key for preflop analysis (AA, AKs, AKo, etc.)"""
        if len(hole_cards) != 2:
            return ""
        
        c1, c2 = hole_cards
        
        if c1.rank == c2.rank:
            return f"{c1.rank}{c1.rank}"
        
        if c1.rank_value() > c2.rank_value():
            high, low = c1, c2
        else:
            high, low = c2, c1
        
        suffix = "s" if high.suit == low.suit else "o"
        return f"{high.rank}{low.rank}{suffix}"





==========================
monte_carlo_backend.py
==========================




"""Monte Carlo backend implementation"""
from typing import List, Dict
import logging
from core.poker import MonteCarloBackend
from core.domain import Card
from monte_carlo_engine_v3 import MonteCarloEngineDaemon

logger = logging.getLogger(__name__)


class CppMonteCarloBackend(MonteCarloBackend):
    """C++ Monte Carlo backend implementation"""
    
    def __init__(self):
        try:
            self.engine = MonteCarloEngineDaemon()
            logger.info("C++ Monte Carlo backend initialized")
        except Exception as e:
            logger.error(f"Failed to initialize C++ backend: {e}")
            raise
    
    def calculate_equity(self, hole_cards: List[Card], board_cards: List[Card],
                        num_opponents: int, iterations: int) -> Dict[str, float]:
        """Calculate equity using C++ engine"""
        return self.engine.calculate_equity(hole_cards, board_cards, num_opponents, iterations)





==========================
outs_calculator.py
==========================




"""Outs calculator - Separated from hand evaluation"""
from typing import List, Dict, Set
from collections import Counter
from core.domain import Card


class OutsCalculator:
    """Calculate outs for different draw types"""
    
    VALID_RANKS = {'2', '3', '4', '5', '6', '7', '8', '9', 'T', 'J', 'Q', 'K', 'A'}
    VALID_SUITS = {'c', 'd', 'h', 's'}
    
    def calculate_outs(self, hole_cards: List[Card], board_cards: List[Card]) -> Dict[str, int]:
        """Calculate outs without double counting"""
        if len(board_cards) >= 5:
            return {'flush': 0, 'straight': 0, 'set_trips': 0, 'overcard': 0}
        
        remaining_cards = self._get_remaining_cards(hole_cards, board_cards)
        
        # Calculate all outs by type (as sets to avoid duplicates)
        flush_outs = self._count_flush_outs(hole_cards, board_cards, remaining_cards)
        straight_outs = self._count_straight_outs(hole_cards, board_cards, remaining_cards, flush_outs)
        set_outs = self._count_set_outs(hole_cards, board_cards, remaining_cards, flush_outs | straight_outs)
        overcard_outs = self._count_overcard_outs(hole_cards, board_cards, remaining_cards, 
                                                   flush_outs | straight_outs | set_outs)
        
        return {
            'flush': len(flush_outs),
            'straight': len(straight_outs),
            'set_trips': len(set_outs),
            'overcard': len(overcard_outs)
        }
    
    def _get_remaining_cards(self, hole_cards: List[Card], board_cards: List[Card]) -> List[Card]:
        """Get all remaining cards in deck"""
        used_cards = set((c.rank, c.suit) for c in hole_cards + board_cards)
        remaining = []
        
        for rank in self.VALID_RANKS:
            for suit in self.VALID_SUITS:
                if (rank, suit) not in used_cards:
                    remaining.append(Card(rank, suit))
        
        return remaining
    
    def _count_flush_outs(self, hole_cards: List[Card], board_cards: List[Card],
                         remaining_cards: List[Card]) -> Set:
        """Count flush draw outs"""
        all_cards = hole_cards + board_cards
        suit_counts = Counter(card.suit for card in all_cards)
        flush_outs = set()
        
        for suit, count in suit_counts.items():
            if count == 4:
                player_suit_count = sum(1 for card in hole_cards if card.suit == suit)
                if player_suit_count >= 1:
                    for card in remaining_cards:
                        if card.suit == suit:
                            flush_outs.add((card.rank, card.suit))
        
        return flush_outs
    
    def _count_straight_outs(self, hole_cards: List[Card], board_cards: List[Card],
                            remaining_cards: List[Card], excluded_outs: Set) -> Set:
        """Count straight draw outs"""
        all_cards = hole_cards + board_cards
        all_ranks = sorted(set(card.rank_value() for card in all_cards))
        hole_ranks = set(card.rank_value() for card in hole_cards)
        straight_outs = set()
        
        # Regular straights
        for start in range(2, 11):
            straight_ranks = set(range(start, start + 5))
            present_ranks = set(all_ranks) & straight_ranks
            
            if len(present_ranks) == 4 and hole_ranks & present_ranks:
                missing_rank = (straight_ranks - set(all_ranks)).pop()
                for card in remaining_cards:
                    if (card.rank_value() == missing_rank and 
                        (card.rank, card.suit) not in excluded_outs):
                        straight_outs.add((card.rank, card.suit))
        
        # Wheel (A-2-3-4-5)
        wheel_ranks = {14, 2, 3, 4, 5}
        present_wheel = set(all_ranks) & wheel_ranks
        
        if len(present_wheel) == 4 and hole_ranks & present_wheel:
            missing_rank = (wheel_ranks - set(all_ranks)).pop()
            for card in remaining_cards:
                if (card.rank_value() == missing_rank and 
                    (card.rank, card.suit) not in excluded_outs):
                    straight_outs.add((card.rank, card.suit))
        
        return straight_outs
    
    def _count_set_outs(self, hole_cards: List[Card], board_cards: List[Card],
                       remaining_cards: List[Card], excluded_outs: Set) -> Set:
        """Count set/trips improvement outs"""
        all_cards = hole_cards + board_cards
        rank_counts = Counter(card.rank for card in all_cards)
        hole_ranks = [card.rank for card in hole_cards]
        set_outs = set()
        
        # Trips â†’ Quads and Full House
        for rank, count in rank_counts.items():
            if count == 3 and rank in hole_ranks:
                # Quads (1 out)
                for card in remaining_cards:
                    if (card.rank == rank and 
                        (card.rank, card.suit) not in excluded_outs):
                        set_outs.add((card.rank, card.suit))
                
                # Full House (pair up other ranks)
                for other_rank, other_count in rank_counts.items():
                    if other_rank != rank and other_count >= 1:
                        remaining_of_rank = sum(1 for card in remaining_cards 
                                              if card.rank == other_rank)
                        
                        count_added = 0
                        for card in remaining_cards:
                            if (card.rank == other_rank and 
                                count_added < remaining_of_rank and
                                (card.rank, card.suit) not in excluded_outs):
                                set_outs.add((card.rank, card.suit))
                                count_added += 1
        
        return set_outs
    
    def _count_overcard_outs(self, hole_cards: List[Card], board_cards: List[Card],
                            remaining_cards: List[Card], excluded_outs: Set) -> Set:
        """Count overcard outs"""
        if not board_cards:
            return set()
        
        board_high = max(card.rank_value() for card in board_cards)
        overcard_outs = set()
        
        for hole_card in hole_cards:
            if hole_card.rank_value() > board_high:
                for card in remaining_cards:
                    if (card.rank == hole_card.rank and 
                        (card.rank, card.suit) not in excluded_outs):
                        overcard_outs.add((card.rank, card.suit))
        
        return overcard_outs





==========================
init.py(ml)
==========================




"""ML package"""
from .detector import TableCardDetector, CardClassifierResNet

__all__ = ['TableCardDetector', 'CardClassifierResNet']





==========================
detector.py
==========================




import logging
from pathlib import Path
from typing import List, Tuple
import numpy as np
import cv2
import torch
import torch.nn as nn
import torchvision.transforms as transforms
from torchvision.models import resnet34
from ultralytics import YOLO

import torch.nn.functional as F
from core.domain import DetectedCard

logger = logging.getLogger(__name__)

class TableCardDetector:
    """YOLO-based card detection with separate zones for player and board cards"""
    
    def __init__(self, weights_path: str, device: str = "cpu"):
        self.device = device
        self.weights_path = weights_path
        logger.info(f"Loading card detector from {weights_path}")
        
        if not Path(weights_path).exists():
            raise FileNotFoundError(f"Model weights not found: {weights_path}")
        
        self.model = YOLO(weights_path)
        self.model.to(device)
        logger.info("Card detector loaded successfully")
    
    def predict(self, frame: np.ndarray, confidence_threshold: float = 0.6) -> List[DetectedCard]:
        """Detect cards with separate optimization for player and board cards"""
        if frame is None or frame.size == 0:
            return []
        
        try:
            results = self.model(frame, verbose=False, conf=confidence_threshold, iou=0.5)
            all_detections = []
            
            frame_height, frame_width = frame.shape[:2]
            
            for result in results:
                if not hasattr(result, 'boxes') or result.boxes is None:
                    continue
                
                for box in result.boxes:
                    confidence = float(box.conf[0])
                    if confidence < confidence_threshold:
                        continue
                    
                    x1, y1, x2, y2 = map(int, box.xyxy[0].tolist())
                    cls_id = int(box.cls[0])
                    
                    if x2 <= x1 or y2 <= y1:
                        continue
                    if (x2 - x1) < 20 or (y2 - y1) < 30:
                        continue
                    
                    if x1 < 0 or y1 < 0 or x2 >= frame_width or y2 >= frame_height:
                        continue
                    
                    kind_raw = self.model.names.get(cls_id, "unknown")
                    kind = self._map_class_name(kind_raw)
                    
                    if kind == "unknown":
                        continue
                    
                    detection = DetectedCard(
                        bbox=(x1, y1, x2, y2),
                        kind=kind,
                        score=confidence
                    )
                    all_detections.append(detection)
            
            optimized_detections = self._optimize_card_detections(all_detections, frame_height, frame_width)
            
            logger.info(f"Detected {len(optimized_detections)} cards after optimization")
            return optimized_detections
            
        except Exception as e:
            logger.error(f"Detection error: {e}")
            return []
    
    def _optimize_card_detections(self, detections: List[DetectedCard], 
                                frame_height: int, frame_width: int) -> List[DetectedCard]:
        player_cards = [d for d in detections if d.kind == "player"]
        board_cards = [d for d in detections if d.kind == "board"]
        
        optimized_player_cards = self._optimize_player_cards(player_cards, frame_height, frame_width)
        optimized_board_cards = self._optimize_board_cards(board_cards, frame_height, frame_width)
        
        return optimized_player_cards + optimized_board_cards
    
    def _optimize_player_cards(self, player_cards: List[DetectedCard], 
                             frame_height: int, frame_width: int) -> List[DetectedCard]:
        if not player_cards:
            return []
        
        bottom_zone_start = int(frame_height * 0.6)
        center_zone_left = int(frame_width * 0.2)
        center_zone_right = int(frame_width * 0.8)
        
        filtered_cards = []
        
        for card in player_cards:
            x1, y1, x2, y2 = card.bbox
            center_x = (x1 + x2) // 2
            center_y = (y1 + y2) // 2
            
            in_bottom_zone = center_y >= bottom_zone_start
            in_center_zone = center_zone_left <= center_x <= center_zone_right
            not_too_high = center_y >= int(frame_height * 0.4)
            
            if in_bottom_zone or (in_center_zone and not_too_high):
                filtered_cards.append(card)
        
        if len(filtered_cards) > 2:
            filtered_cards = sorted(filtered_cards, key=lambda x: x.score, reverse=True)[:2]
        
        return filtered_cards
    
    def _optimize_board_cards(self, board_cards: List[DetectedCard], 
                            frame_height: int, frame_width: int) -> List[DetectedCard]:
        if not board_cards:
            return []
        
        center_zone_top = int(frame_height * 0.2)
        center_zone_bottom = int(frame_height * 0.7)
        center_zone_left = int(frame_width * 0.15)
        center_zone_right = int(frame_width * 0.85)
        
        filtered_cards = []
        
        for card in board_cards:
            x1, y1, x2, y2 = card.bbox
            center_x = (x1 + x2) // 2
            center_y = (y1 + y2) // 2
            
            in_vertical_zone = center_zone_top <= center_y <= center_zone_bottom
            in_horizontal_zone = center_zone_left <= center_x <= center_zone_right
            
            if in_vertical_zone and in_horizontal_zone:
                filtered_cards.append(card)
        
        if len(filtered_cards) > 5:
            filtered_cards = sorted(filtered_cards, key=lambda x: x.score, reverse=True)[:5]
        
        filtered_cards = sorted(filtered_cards, key=lambda x: (x.bbox[0] + x.bbox[2]) // 2)
        
        return filtered_cards
    
    def _map_class_name(self, raw_name: str) -> str:
        name_mapping = {
            "BoardCard": "board",
            "PlayerCard": "player", 
            "board_card": "board",
            "player_card": "player",
            "Board": "board",
            "Player": "player"
        }
        return name_mapping.get(raw_name, raw_name.lower())

class CardClassifierResNet:
    """ResNet-based card classification"""
    
    def __init__(self, weights_path: str, device: str = "cpu"):
        self.device = device
        self.weights_path = weights_path
        logger.info(f"Loading card classifier from {weights_path}")
        
        if not Path(weights_path).exists():
            raise FileNotFoundError(f"Model weights not found: {weights_path}")
        
        self._load_model()
        self._setup_transforms()
        logger.info("Card classifier loaded successfully")
    
    def _load_model(self):
        checkpoint = torch.load(self.weights_path, map_location=self.device)
        
        try:
            from torchvision.models import ResNet34_Weights
            self.model = resnet34(weights=None)
        except ImportError:
            self.model = resnet34(pretrained=False)
        
        num_features = self.model.fc.in_features
        self.model.fc = nn.Sequential(
            nn.Dropout(0.5),
            nn.Linear(num_features, 52)
        )
        
        if isinstance(checkpoint, dict):
            if 'model_state_dict' in checkpoint:
                self.model.load_state_dict(checkpoint['model_state_dict'])
            elif 'state_dict' in checkpoint:
                self.model.load_state_dict(checkpoint['state_dict'])
            else:
                self.model.load_state_dict(checkpoint)
        else:
            self.model = checkpoint
        
        self.model.to(self.device)
        self.model.eval()
        
        self.class_names = [
            "ace of clubs", "ace of diamonds", "ace of hearts", "ace of spades",
            "eight of clubs", "eight of diamonds", "eight of hearts", "eight of spades",
            "five of clubs", "five of diamonds", "five of hearts", "five of spades",
            "four of clubs", "four of diamonds", "four of hearts", "four of spades",
            "jack of clubs", "jack of diamonds", "jack of hearts", "jack of spades",
            "king of clubs", "king of diamonds", "king of hearts", "king of spades",
            "nine of clubs", "nine of diamonds", "nine of hearts", "nine of spades",
            "queen of clubs", "queen of diamonds", "queen of hearts", "queen of spades",
            "seven of clubs", "seven of diamonds", "seven of hearts", "seven of spades",
            "six of clubs", "six of diamonds", "six of hearts", "six of spades",
            "ten of clubs", "ten of diamonds", "ten of hearts", "ten of spades",
            "three of clubs", "three of diamonds", "three of hearts", "three of spades",
            "two of clubs", "two of diamonds", "two of hearts", "two of spades"
        ]
    
    def _setup_transforms(self):
        self.transform = transforms.Compose([
            transforms.ToPILImage(),
            transforms.Resize((224, 224)),
            transforms.ToTensor(),
            transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225])
        ])
    
    def classify_crop(self, crop: np.ndarray) -> Tuple[str, float]:
        if crop is None or crop.size == 0:
            return "unknown", 0.0
        
        try:
            crop_rgb = cv2.cvtColor(crop, cv2.COLOR_BGR2RGB)
            tensor = self.transform(crop_rgb).unsqueeze(0).to(self.device)
            
            with torch.no_grad():
                output = self.model(tensor)
                probs = F.softmax(output, dim=1)
                confidence, index = torch.max(probs, dim=1)
            
            class_idx = index.item()
            confidence_score = confidence.item()
            
            if 0 <= class_idx < len(self.class_names):
                raw_label = self.class_names[class_idx]
                card_label = self._map_class_to_card(raw_label)
                return card_label, confidence_score
            
            return "unknown", confidence_score
            
        except Exception as e:
            logger.error(f"Classification error: {e}")
            return "unknown", 0.0
    
    def _map_class_to_card(self, raw_label: str) -> str:
        name_mapping = {
            "ace of clubs": "Ac", "ace of diamonds": "Ad", "ace of hearts": "Ah", "ace of spades": "As",
            "king of clubs": "Kc", "king of diamonds": "Kd", "king of hearts": "Kh", "king of spades": "Ks",
            "queen of clubs": "Qc", "queen of diamonds": "Qd", "queen of hearts": "Qh", "queen of spades": "Qs",
            "jack of clubs": "Jc", "jack of diamonds": "Jd", "jack of hearts": "Jh", "jack of spades": "Js",
            "ten of clubs": "Tc", "ten of diamonds": "Td", "ten of hearts": "Th", "ten of spades": "Ts",
            "nine of clubs": "9c", "nine of diamonds": "9d", "nine of hearts": "9h", "nine of spades": "9s",
            "eight of clubs": "8c", "eight of diamonds": "8d", "eight of hearts": "8h", "eight of spades": "8s",
            "seven of clubs": "7c", "seven of diamonds": "7d", "seven of hearts": "7h", "seven of spades": "7s",
            "six of clubs": "6c", "six of diamonds": "6d", "six of hearts": "6h", "six of spades": "6s",
            "five of clubs": "5c", "five of diamonds": "5d", "five of hearts": "5h", "five of spades": "5s",
            "four of clubs": "4c", "four of diamonds": "4d", "four of hearts": "4h", "four of spades": "4s",
            "three of clubs": "3c", "three of diamonds": "3d", "three of hearts": "3h", "three of spades": "3s",
            "two of clubs": "2c", "two of diamonds": "2d", "two of hearts": "2h", "two of spades": "2s"
        }
        
        return name_mapping.get(raw_label.lower(), raw_label)





==========================
init.py(services)
==========================




"""Services package"""
from .ml_service import MLService
from .analysis_service import AnalysisService

__all__ = ['MLService', 'AnalysisService']





==========================
analysis_service.py
==========================




"""Analysis Service - Orchestrates poker analysis with improved recommendations"""
from typing import Dict, List
import logging
from core.domain import Card, GameState, GameStage
from core.poker import HandEvaluator, EquityCalculator, BoardAnalyzer, OutsCalculator

logger = logging.getLogger(__name__)


class AnalysisService:
    """High-level poker analysis orchestration with improved ABC recommendations"""
    
    def __init__(self, equity_calculator: EquityCalculator):
        self.hand_evaluator = HandEvaluator()
        self.board_analyzer = BoardAnalyzer()
        self.outs_calculator = OutsCalculator()
        self.equity_calculator = equity_calculator
        
        # Import recommendation engine
        try:
            from services.improved_abc_recommendations import ImprovedRecommendationEngine
            self.recommendation_engine = ImprovedRecommendationEngine()
            self.use_improved_recommendations = True
            logger.info("Loaded improved recommendation engine")
        except ImportError:
            logger.warning("Improved recommendation engine not found, using basic recommendations")
            self.recommendation_engine = None
            self.use_improved_recommendations = False
    
    def analyze_hand(self, game_state: GameState) -> Dict[str, any]:
        """Comprehensive hand analysis"""
        
        # Validation
        if len(game_state.player_cards) != 2:
            return {"error": "Need exactly 2 player cards"}
        
        # Determine analysis type based on stage
        if game_state.stage == GameStage.PREFLOP:
            return self._analyze_preflop(game_state)
        else:
            return self._analyze_postflop(game_state)
    
    def _analyze_preflop(self, game_state: GameState) -> Dict[str, any]:
        """Preflop analysis (would integrate with GTO charts)"""
        hand_key = self.hand_evaluator.get_hand_key(game_state.player_cards)
        
        return {
            "stage": "preflop",
            "hand_key": hand_key,
            "cards_display": " ".join(str(c) for c in game_state.player_cards),
            # GTO recommendations would go here
        }
    
    def _analyze_postflop(self, game_state: GameState) -> Dict[str, any]:
        """Postflop analysis with hand strength, outs, equity"""
        
        # Hand strength evaluation
        all_cards = game_state.player_cards + game_state.board_cards
        best_hand, strength = self.hand_evaluator.get_best_5_card_hand(all_cards)
        current_hand = self.hand_evaluator.get_hand_description(best_hand)
        
        # Outs calculation
        outs_data = {}
        total_outs = 0
        if len(game_state.board_cards) < 5:
            outs_data = self.outs_calculator.calculate_outs(
                game_state.player_cards,
                game_state.board_cards
            )
            total_outs = sum(outs_data.values())
        
        # Board texture analysis
        texture_analysis = {}
        if len(game_state.board_cards) >= 3:
            texture_analysis = self.board_analyzer.analyze_texture(game_state.board_cards)
        
        # Equity simulation
        equity_data = {}
        if len(game_state.board_cards) >= 3:
            try:
                equity_data = self.equity_calculator.calculate_equity(
                    game_state.player_cards,
                    game_state.board_cards,
                    num_opponents=game_state.get_opponents_count(),
                    iterations=50000
                )
            except Exception as e:
                logger.error(f"Equity calculation failed: {e}")
                equity_data = {"error": str(e)}
        
        # Strategic recommendation - NEW IMPROVED VERSION
        if self.use_improved_recommendations and self.recommendation_engine:
            strategy = self._generate_improved_strategy(
                current_hand=current_hand,
                equity_data=equity_data,
                outs_data=outs_data,
                total_outs=total_outs,
                texture_analysis=texture_analysis,
                game_state=game_state
            )
        else:
            # Fallback to basic strategy
            strategy = self._generate_basic_strategy(
                current_hand, total_outs, equity_data, texture_analysis, len(game_state.board_cards)
            )
        
        return {
            "stage": game_state.stage.value,
            "current_hand": current_hand,
            "hand_strength_numeric": strength,
            "best_5_cards": [str(c) for c in best_hand],
            "outs_analysis": outs_data,
            "total_outs": total_outs,
            "board_texture": texture_analysis,
            "equity": equity_data,
            "strategy_recommendation": strategy,
            # Additional data for improved recommendations
            "num_opponents": game_state.get_opponents_count(),
            "board_cards_list": game_state.board_cards
        }
    
    def _generate_improved_strategy(
        self,
        current_hand: str,
        equity_data: Dict,
        outs_data: Dict,
        total_outs: int,
        texture_analysis: Dict,
        game_state: GameState
    ) -> str:
        """Generate improved strategic recommendation"""
        
        try:
            win_rate = equity_data.get('win_rate', 0)
            
            recommendation = self.recommendation_engine.generate_recommendation(
                current_hand=current_hand,
                win_rate=win_rate,
                total_outs=total_outs,
                outs_breakdown=outs_data,
                texture_analysis=texture_analysis,
                num_opponents=game_state.get_opponents_count(),
                stage=game_state.stage,
                board_cards=game_state.board_cards
            )
            
            return recommendation
            
        except Exception as e:
            logger.error(f"Improved recommendation generation failed: {e}")
            # Fallback to basic
            return self._generate_basic_strategy(
                current_hand, total_outs, equity_data, 
                texture_analysis, len(game_state.board_cards)
            )
    
    def _generate_basic_strategy(
        self, 
        current_hand: str, 
        total_outs: int, 
        equity_data: Dict, 
        texture_analysis: Dict, 
        board_cards_count: int
    ) -> str:
        """Basic ABC strategy recommendation (fallback)"""
        
        strong_hands = ['four of a kind', 'full house', 'flush', 'straight', 'three of a kind']
        medium_hands = ['two pair', 'one pair']
        
        win_rate = equity_data.get('win_rate', 0)
        
        # Strong made hands
        if any(hand in current_hand.lower() for hand in strong_hands):
            if win_rate > 70:
                return "ðŸ’ª ÐžÐ§Ð•ÐÐ¬ Ð¡Ð˜Ð›Ð¬ÐÐÐ¯ Ð Ð£ÐšÐ - Ð¡Ñ‚Ð°Ð²ÑŒÑ‚Ðµ ÐºÑ€ÑƒÐ¿Ð½Ð¾ Ð½Ð° Ð²ÑÐ»ÑŒÑŽ!"
            else:
                return "âœ… Ð¡Ð˜Ð›Ð¬ÐÐÐ¯ Ð Ð£ÐšÐ - Ð¡Ñ‚Ð°Ð²ÑŒÑ‚Ðµ Ð½Ð° Ð²ÑÐ»ÑŒÑŽ"
        
        # Medium hands
        if any(hand in current_hand.lower() for hand in medium_hands):
            if win_rate > 55:
                return "ðŸ‘ Ð¡Ð Ð•Ð”ÐÐ¯Ð¯ Ð Ð£ÐšÐ - Ð¡Ñ‚Ð°Ð²ÑŒÑ‚Ðµ ÑÑ€ÐµÐ´Ð½Ðµ Ð¸Ð»Ð¸ ÐºÐ¾Ð»Ð»Ð¸Ñ€ÑƒÐ¹Ñ‚Ðµ"
            else:
                return "âš ï¸ ÐžÐ¡Ð¢ÐžÐ ÐžÐ–ÐÐž - Ð§ÐµÐº-ÐºÐ¾Ð»Ð» Ð¸Ð»Ð¸ Ð½ÐµÐ±Ð¾Ð»ÑŒÑˆÐ°Ñ ÑÑ‚Ð°Ð²ÐºÐ°"
        
        # Drawing hands
        if total_outs >= 12:
            return "ðŸš€ ÐœÐžÐÐ¡Ð¢Ð -Ð”Ð Ðž - Ð˜Ð³Ñ€Ð°Ð¹Ñ‚Ðµ Ð¾Ñ‡ÐµÐ½ÑŒ Ð°Ð³Ñ€ÐµÑÑÐ¸Ð²Ð½Ð¾!"
        elif total_outs >= 8:
            return "âš¡ Ð¥ÐžÐ ÐžÐ¨Ð•Ð• Ð”Ð Ðž - ÐŸÐ¾Ð»Ñƒ-Ð±Ð»ÐµÑ„ Ð¸Ð»Ð¸ ÐºÐ¾Ð»Ð»"
        elif total_outs >= 4:
            return "ðŸ¤ž Ð¡Ð›ÐÐ‘ÐžÐ• Ð”Ð Ðž - ÐšÐ¾Ð»Ð»Ð¸Ñ€ÑƒÐ¹Ñ‚Ðµ Ð´ÐµÑˆÐµÐ²Ð¾"
        
        # Weak hands
        if board_cards_count == 5:
            return "âŒ Ð¡Ð›ÐÐ‘ÐÐ¯ Ð Ð£ÐšÐ - Ð¡ÐºÐ¾Ñ€ÐµÐµ Ð²ÑÐµÐ³Ð¾ Ð¤ÐžÐ›Ð” Ðº ÑÑ‚Ð°Ð²ÐºÐ°Ð¼"
        else:
            return "ðŸ˜• Ð¡Ð›ÐÐ‘ÐÐ¯ ÐŸÐžÐ—Ð˜Ð¦Ð˜Ð¯ - Ð§ÐµÐº Ð¸Ð»Ð¸ Ñ„Ð¾Ð»Ð´ Ðº Ð°Ð³Ñ€ÐµÑÑÐ¸Ð¸"





==========================
ml_service.py
==========================




"""ML Service - Abstracts card detection pipeline"""
from typing import List, Tuple, Optional
import logging
import numpy as np
from pathlib import Path
from core.domain import DetectedCard

logger = logging.getLogger(__name__)


class MLService:
    """High-level ML detection service"""
    
    def __init__(self, detector=None, classifier=None):
        self.detector = detector
        self.classifier = classifier
        self.is_available = detector is not None and classifier is not None
    
    @classmethod
    def from_weights(cls, yolo_path: str, resnet_path: str, device: str = "cpu"):
        """Factory method to load models from weights"""
        try:
            from ml.detector import TableCardDetector, CardClassifierResNet
            
            if not Path(yolo_path).exists() or not Path(resnet_path).exists():
                logger.warning("Model weights not found")
                return cls(None, None)
            
            detector = TableCardDetector(yolo_path, device)
            classifier = CardClassifierResNet(resnet_path, device)
            
            logger.info("ML models loaded successfully")
            return cls(detector, classifier)
            
        except Exception as e:
            logger.error(f"Failed to load ML models: {e}")
            return cls(None, None)
    
    def detect_and_classify(self, frame: np.ndarray, 
                           confidence_threshold: float = 0.4) -> Tuple[List[DetectedCard], List[DetectedCard]]:
        """Detect and classify cards, return (player_cards, board_cards)"""
        
        if not self.is_available:
            logger.warning("ML models not available")
            return [], []
        
        try:
            # Detection
            detections = self.detector.predict(frame, confidence_threshold=confidence_threshold)
            
            # Separate by type
            player_detections = [d for d in detections if d.kind == "player"]
            board_detections = [d for d in detections if d.kind == "board"]
            
            # Classify
            classified_player = self._classify_detections(player_detections, frame)
            classified_board = self._classify_detections(board_detections, frame)
            
            logger.info(f"Detected {len(classified_player)} player, {len(classified_board)} board cards")
            return classified_player, classified_board
            
        except Exception as e:
            logger.error(f"Detection/classification error: {e}")
            return [], []
    
    def _classify_detections(self, detections: List[DetectedCard], 
                            frame: np.ndarray) -> List[DetectedCard]:
        """Classify a list of detections"""
        classified = []
        
        for detection in detections:
            x1, y1, x2, y2 = detection.bbox
            crop = frame[y1:y2, x1:x2]
            
            if crop.size > 0:
                card_label, confidence = self.classifier.classify_crop(crop)
                if confidence > 0.2:
                    detection.classification = card_label
                    classified.append(detection)
        
        return classified





=========================
improved_abc_recommendations.py
=========================




"""
Ð£Ð»ÑƒÑ‡ÑˆÐµÐ½Ð½Ð°Ñ ÑÐ¸ÑÑ‚ÐµÐ¼Ð° ABC Ñ€ÐµÐºÐ¾Ð¼ÐµÐ½Ð´Ð°Ñ†Ð¸Ð¹ Ð´Ð»Ñ analysis_service.py
Ð¡ ÑƒÑ‡ÐµÑ‚Ð¾Ð¼: board texture, ÐºÐ¾Ð»Ð¸Ñ‡ÐµÑÑ‚Ð²Ð° Ð¾Ð¿Ð¿Ð¾Ð½ÐµÐ½Ñ‚Ð¾Ð², ÑÑ‚Ð°Ð´Ð¸Ð¸ ÑƒÐ»Ð¸Ñ†Ñ‹, Ð¿Ð¾Ð·Ð¸Ñ†Ð¸Ð¾Ð½Ð½Ð¾Ð¹ Ð¸Ð³Ñ€Ñ‹
"""

from typing import Dict, List
from core.domain import Card, GameState, GameStage


class ImprovedRecommendationEngine:
    """
    Ð Ð°ÑÑˆÐ¸Ñ€ÐµÐ½Ð½Ð°Ñ ÑÐ¸ÑÑ‚ÐµÐ¼Ð° ABC Ñ€ÐµÐºÐ¾Ð¼ÐµÐ½Ð´Ð°Ñ†Ð¸Ð¹ Ñ ÑƒÑ‡ÐµÑ‚Ð¾Ð¼:
    - Board texture compatibility Ñ Ñ€ÑƒÐºÐ¾Ð¹ Ð¸Ð³Ñ€Ð¾ÐºÐ°
    - ÐšÐ¾Ð»Ð¸Ñ‡ÐµÑÑ‚Ð²Ð¾ Ð¾Ð¿Ð¿Ð¾Ð½ÐµÐ½Ñ‚Ð¾Ð² (multiway vs heads-up)
    - Ð¡Ñ‚Ð°Ð´Ð¸Ñ Ð¸Ð³Ñ€Ñ‹ (flop/turn/river)
    - ÐŸÐ¾Ð·Ð¸Ñ†Ð¸Ð¾Ð½Ð½Ñ‹Ðµ ÑÐ¾Ð²ÐµÑ‚Ñ‹ (Ð´Ð»Ñ Ð¸Ð½Ñ„Ð¾Ñ€Ð¼Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð½Ð¾Ð³Ð¾ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ)
    - Ð¡Ð¾Ð²ÐµÑ‚Ñ‹ Ð¿Ð¾ Ð¿Ð¾Ð²ÐµÐ´ÐµÐ½Ð¸ÑŽ Ð¾Ð¿Ð¿Ð¾Ð½ÐµÐ½Ñ‚Ð° (Ð´Ð»Ñ Ð¸Ð½Ñ„Ð¾Ñ€Ð¼Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð½Ð¾Ð³Ð¾ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ)
    """
    
    # ÐšÐ¾Ð½ÑÑ‚Ð°Ð½Ñ‚Ñ‹ Ð´Ð»Ñ ÐºÐ»Ð°ÑÑÐ¸Ñ„Ð¸ÐºÐ°Ñ†Ð¸Ð¸ ÐºÐ¾Ð¼Ð±Ð¸Ð½Ð°Ñ†Ð¸Ð¹
    MONSTER_HANDS = {'straight_flush', 'four_kind', 'full_house'}
    STRONG_HANDS = {'flush', 'straight'}
    MEDIUM_HANDS = {'three_kind', 'two_pair'}
    WEAK_MADE_HANDS = {'one_pair'}
    
    def generate_recommendation(
        self,
        current_hand: str,
        win_rate: float,
        total_outs: int,
        outs_breakdown: Dict[str, int],
        texture_analysis: Dict,
        num_opponents: int,
        stage: GameStage,
        board_cards: List[Card]
    ) -> str:
        """
        Ð“Ð»Ð°Ð²Ð½Ð°Ñ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ñ Ð³ÐµÐ½ÐµÑ€Ð°Ñ†Ð¸Ð¸ Ñ€ÐµÐºÐ¾Ð¼ÐµÐ½Ð´Ð°Ñ†Ð¸Ð¹
        """
        
        # ÐÐ¾Ñ€Ð¼Ð°Ð»Ð¸Ð·Ð°Ñ†Ð¸Ñ Ð½Ð°Ð·Ð²Ð°Ð½Ð¸Ñ Ñ€ÑƒÐºÐ¸
        hand_type = self._normalize_hand_name(current_hand)
        
        # ÐžÐ¿Ñ€ÐµÐ´ÐµÐ»ÑÐµÐ¼ ÐºÐ°Ñ‚ÐµÐ³Ð¾Ñ€Ð¸ÑŽ Ñ€ÑƒÐºÐ¸
        hand_category = self._categorize_hand(hand_type)
        
        # ÐŸÑ€Ð¾Ð²ÐµÑ€ÑÐµÐ¼ ÑÐ¾Ð²Ð¼ÐµÑÑ‚Ð¸Ð¼Ð¾ÑÑ‚ÑŒ Ñ€ÑƒÐºÐ¸ Ñ Ñ‚ÐµÐºÑÑ‚ÑƒÑ€Ð¾Ð¹ Ð±Ð¾Ñ€Ð´Ð°
        texture_match = self._check_texture_compatibility(hand_type, texture_analysis, board_cards)
        
        # Ð‘Ð°Ð·Ð¾Ð²Ð°Ñ Ñ€ÐµÐºÐ¾Ð¼ÐµÐ½Ð´Ð°Ñ†Ð¸Ñ Ð² Ð·Ð°Ð²Ð¸ÑÐ¸Ð¼Ð¾ÑÑ‚Ð¸ Ð¾Ñ‚ ÑÐ¸Ð»Ñ‹
        if hand_category == 'monster':
            return self._recommend_monster(
                hand_type, win_rate, texture_analysis, 
                num_opponents, stage, texture_match
            )
        
        elif hand_category == 'strong':
            return self._recommend_strong(
                hand_type, win_rate, texture_analysis, 
                num_opponents, stage, texture_match, outs_breakdown
            )
        
        elif hand_category == 'medium':
            return self._recommend_medium(
                hand_type, win_rate, texture_analysis, 
                num_opponents, stage, texture_match, total_outs
            )
        
        elif hand_category == 'weak_made':
            return self._recommend_weak_made(
                hand_type, win_rate, texture_analysis, 
                num_opponents, stage, total_outs, outs_breakdown
            )
        
        else:  # draw / no made hand
            return self._recommend_draw(
                total_outs, outs_breakdown, win_rate, 
                texture_analysis, num_opponents, stage
            )
    
    def _normalize_hand_name(self, hand_name: str) -> str:
        """ÐÐ¾Ñ€Ð¼Ð°Ð»Ð¸Ð·Ð°Ñ†Ð¸Ñ Ð½Ð°Ð·Ð²Ð°Ð½Ð¸Ð¹ ÐºÐ¾Ð¼Ð±Ð¸Ð½Ð°Ñ†Ð¸Ð¹"""
        hand_map = {
            'straight flush': 'straight_flush',
            'four of a kind': 'four_kind',
            'full house': 'full_house',
            'three of a kind': 'three_kind',
            'two pair': 'two_pair',
            'one pair': 'one_pair',
            'high card': 'high_card'
        }
        return hand_map.get(hand_name.lower(), hand_name.lower())
    
    def _categorize_hand(self, hand_type: str) -> str:
        """ÐšÐ°Ñ‚ÐµÐ³Ð¾Ñ€Ð¸Ð·Ð°Ñ†Ð¸Ñ Ñ€ÑƒÐºÐ¸"""
        if hand_type in self.MONSTER_HANDS:
            return 'monster'
        elif hand_type in self.STRONG_HANDS:
            return 'strong'
        elif hand_type in self.MEDIUM_HANDS:
            return 'medium'
        elif hand_type in self.WEAK_MADE_HANDS:
            return 'weak_made'
        else:
            return 'draw'
    
    def _check_texture_compatibility(
        self, 
        hand_type: str, 
        texture: Dict,
        board_cards: List[Card]
    ) -> Dict[str, bool]:
        """
        ÐŸÑ€Ð¾Ð²ÐµÑ€ÑÐµÑ‚, ÑƒÑÐ¸Ð»Ð¸Ð²Ð°ÐµÑ‚ Ð»Ð¸ Ñ‚ÐµÐºÑÑ‚ÑƒÑ€Ð° Ð±Ð¾Ñ€Ð´Ð° Ð½Ð°ÑˆÑƒ Ñ€ÑƒÐºÑƒ
        Ð¸Ð»Ð¸ ÑÐ¾Ð·Ð´Ð°ÐµÑ‚ Ð¾Ð¿Ð°ÑÐ½Ð¾ÑÑ‚ÑŒ
        """
        return {
            'flush_compatible': hand_type == 'flush' and texture.get('monotone', False),
            'straight_compatible': hand_type == 'straight' and texture.get('coordinated', False),
            'set_compatible': hand_type == 'three_kind' and not texture.get('paired', False),
            'fullhouse_compatible': hand_type == 'full_house' and texture.get('paired', False),
            
            'flush_danger': texture.get('monotone', False) and hand_type != 'flush',
            'straight_danger': texture.get('coordinated', False) and hand_type not in ['straight', 'flush', 'full_house'],
            'pair_danger': texture.get('paired', False) and hand_type not in ['full_house', 'four_kind']
        }
    
    # ===================== MONSTER HANDS =====================
    
    def _recommend_monster(
        self, 
        hand_type: str, 
        win_rate: float,
        texture: Dict,
        num_opponents: int,
        stage: GameStage,
        texture_match: Dict
    ) -> str:
        """Ð ÐµÐºÐ¾Ð¼ÐµÐ½Ð´Ð°Ñ†Ð¸Ð¸ Ð´Ð»Ñ Ð¼Ð¾Ð½ÑÑ‚Ñ€-Ñ€ÑƒÐº"""
        
        base = "ðŸ’Ž **ÐœÐžÐÐ¡Ð¢Ð -Ð Ð£ÐšÐ**\n\n"
        
        # ÐšÐ²Ð°Ð´Ñ
        if hand_type == 'four_kind':
            base += "ðŸ”¥ **ÐšÐ°Ñ€Ðµ** - Ð¿Ñ€Ð°ÐºÑ‚Ð¸Ñ‡ÐµÑÐºÐ¸ Ð½ÐµÐ¿Ð¾Ð±ÐµÐ´Ð¸Ð¼Ð°Ñ Ñ€ÑƒÐºÐ°!\n"
            base += "âœ… **ÐœÐÐšÐ¡Ð˜ÐœÐÐ›Ð¬ÐÐÐ¯ ÐÐ“Ð Ð•Ð¡Ð¡Ð˜Ð¯**: Ð¡Ñ‚Ñ€Ð¾Ð¸Ð¼ Ð¾Ð³Ñ€Ð¾Ð¼Ð½Ñ‹Ð¹ Ð±Ð°Ð½Ðº Ð»ÑŽÐ±Ð¾Ð¹ Ñ†ÐµÐ½Ð¾Ð¹.\n\n"
            base += "**Ð”ÐµÐ¹ÑÑ‚Ð²Ð¸Ñ:**\n"
            base += "â€¢ ÐÐ° Ð²ÑÐµÑ… ÑƒÐ»Ð¸Ñ†Ð°Ñ…: Ð ÐµÐ¹Ð·/3-Ð±ÐµÑ‚/4-Ð±ÐµÑ‚\n"
            base += "â€¢ ÐÐ° Ñ€Ð¸Ð²ÐµÑ€Ðµ: ÐžÐ²ÐµÑ€bet Ð´Ð»Ñ Ð¼Ð°ÐºÑÐ¸Ð¼Ð°Ð»ÑŒÐ½Ð¾Ð³Ð¾ value\n"
            base += "â€¢ ÐŸÑ€Ð¾Ñ‚Ð¸Ð² 1 Ð¾Ð¿Ð¿Ð¾Ð½ÐµÐ½Ñ‚Ð°: Ð’Ð¾Ð·Ð¼Ð¾Ð¶ÐµÐ½ small bet Ð´Ð»Ñ Ð¸Ð½Ð´ÑƒÑÐ° ÐºÐ¾Ð»Ð»Ð°\n"
            base += f"â€¢ ÐŸÑ€Ð¾Ñ‚Ð¸Ð² {num_opponents} Ð¾Ð¿Ð¿Ð¾Ð½ÐµÐ½Ñ‚Ð¾Ð²: ÐšÑ€ÑƒÐ¿Ð½Ñ‹Ðµ ÑÑ‚Ð°Ð²ÐºÐ¸ ÑÑ€Ð°Ð·Ñƒ\n\n"
            
            base += self._add_positional_advice(
                "ÐœÐ¾Ð¶Ð½Ð¾ slow-play Ð½Ð° Ñ„Ð»Ð¾Ð¿Ðµ Ð´Ð»Ñ trap",
                "Ð ÐµÐ¹Ð· Ð½Ð° Ñ„Ð»Ð¾Ð¿Ðµ, Ñ‡Ñ‚Ð¾Ð±Ñ‹ Ð½Ðµ Ð´Ð°Ñ‚ÑŒ Ð±ÐµÑÐ¿Ð»Ð°Ñ‚Ð½Ñ‹Ñ… ÐºÐ°Ñ€Ñ‚"
            )
            return base
        
        # Ð¤ÑƒÐ»Ð»-Ñ…Ð°ÑƒÑ
        elif hand_type == 'full_house':
            base += "ðŸ  **Ð¤ÑƒÐ»Ð»-Ñ…Ð°ÑƒÑ** - Ð¾Ñ‡ÐµÐ½ÑŒ ÑÐ¸Ð»ÑŒÐ½Ð°Ñ Ñ€ÑƒÐºÐ°!\n"
            
            if texture_match['fullhouse_compatible']:
                base += "âœ… ÐŸÐ°Ñ€Ð½Ñ‹Ð¹ Ð±Ð¾Ñ€Ð´ ÑƒÑÐ¸Ð»Ð¸Ð²Ð°ÐµÑ‚ Ð²Ð°ÑˆÑƒ Ñ€ÑƒÐºÑƒ - Ð¾Ð¿Ð¿Ð¾Ð½ÐµÐ½Ñ‚Ñ‹ Ð¼Ð¾Ð³ÑƒÑ‚ Ð¸Ð¼ÐµÑ‚ÑŒ Ð¼ÐµÐ½ÑŒÑˆÐ¸Ð¹ Ñ„ÑƒÐ»Ð»-Ñ…Ð°ÑƒÑ.\n\n"
            else:
                base += "âš ï¸ Ð¤ÑƒÐ»Ð»-Ñ…Ð°ÑƒÑ Ð½Ð° Ð½ÐµÐ¿Ð°Ñ€Ð½Ð¾Ð¼ Ð±Ð¾Ñ€Ð´Ðµ - Ð¾Ð¿Ð¿Ð¾Ð½ÐµÐ½Ñ‚Ñ‹ Ð²Ñ€ÑÐ´ Ð»Ð¸ Ð·Ð°Ð¿Ð¾Ð´Ð¾Ð·Ñ€ÑÑ‚ ÑÐ¸Ð»Ñƒ.\n\n"
            
            base += "**Ð”ÐµÐ¹ÑÑ‚Ð²Ð¸Ñ:**\n"
            base += "â€¢ ÐÐ° Ñ„Ð»Ð¾Ð¿Ðµ/Ñ‚ÐµÑ€Ð½Ðµ: Ð¡Ñ€ÐµÐ´Ð½Ð¸Ð¹ bet Ð´Ð»Ñ value\n"
            base += "â€¢ ÐÐ° Ñ€Ð¸Ð²ÐµÑ€Ðµ: ÐšÑ€ÑƒÐ¿Ð½Ñ‹Ð¹ value bet\n"
            
            if num_opponents == 1:
                base += "â€¢ Heads-up: ÐœÐ¾Ð¶Ð½Ð¾ Ñ‡ÐµÐº-Ñ€ÐµÐ¹Ð· Ð´Ð»Ñ Ð¼Ð°ÐºÑÐ¸Ð¼Ð¸Ð·Ð°Ñ†Ð¸Ð¸\n"
            else:
                base += f"â€¢ {num_opponents} Ð¾Ð¿Ð¿Ð¾Ð½ÐµÐ½Ñ‚Ð¾Ð²: ÐŸÑ€ÑÐ¼Ñ‹Ðµ ÑÑ‚Ð°Ð²ÐºÐ¸ (ÐºÑ‚Ð¾-Ñ‚Ð¾ Ð·Ð°Ð¿Ð»Ð°Ñ‚Ð¸Ñ‚)\n"
            
            base += "\n" + self._add_opponent_behavior_advice(**{
                "Ð°Ð³Ñ€ÐµÑÑÐ¸Ð²ÐµÐ½": "Ð§ÐµÐº-Ñ€ÐµÐ¹Ð· Ð½Ð° Ñ€Ð¸Ð²ÐµÑ€Ðµ Ð´Ð»Ñ Ð¼Ð°ÐºÑÐ¸Ð¼Ð°Ð»ÑŒÐ½Ð¾Ð³Ð¾ value",
                "Ð¿Ð°ÑÑÐ¸Ð²ÐµÐ½": "ÐšÑ€ÑƒÐ¿Ð½Ð°Ñ Ð´Ð¾Ð½Ðº-ÑÑ‚Ð°Ð²ÐºÐ°, Ñ‡Ñ‚Ð¾Ð±Ñ‹ Ð²Ð·ÑÑ‚ÑŒ value",
                "Ñ‚Ð°Ð¹Ñ‚Ð¾Ð²": "Ð¡Ñ€ÐµÐ´Ð½ÑÑ ÑÑ‚Ð°Ð²ÐºÐ° - Ð¾Ð½Ð¸ Ð¿Ð»Ð°Ñ‚ÑÑ‚ Ñ‚Ð¾Ð»ÑŒÐºÐ¾ Ñ ÑÐ¸Ð»ÑŒÐ½Ñ‹Ð¼Ð¸ Ñ€ÑƒÐºÐ°Ð¼Ð¸"
            })
            return base
        
        # Ð¡Ñ‚Ñ€Ð¸Ñ‚-Ñ„Ð»ÐµÑˆ
        else:  # straight_flush
            base += "ðŸ‘‘ **Ð¡Ð¢Ð Ð˜Ð¢-Ð¤Ð›Ð•Ð¨** - Ð°Ð±ÑÐ¾Ð»ÑŽÑ‚Ð½Ñ‹Ð¹ Ð¾Ñ€ÐµÑ…!\n"
            base += "âœ… **Ð’Ð¡Ð Ð’ Ð‘ÐÐÐš**: Impossible to beat Ð¿Ñ€Ð°ÐºÑ‚Ð¸Ñ‡ÐµÑÐºÐ¸.\n\n"
            base += "**Ð”ÐµÐ¹ÑÑ‚Ð²Ð¸Ñ:**\n"
            base += "â€¢ Ð›ÑŽÐ±Ð°Ñ Ð°Ð³Ñ€ÐµÑÑÐ¸Ñ Ð¾Ð¿Ñ€Ð°Ð²Ð´Ð°Ð½Ð°\n"
            base += "â€¢ ÐÐ° Ñ€Ð¸Ð²ÐµÑ€Ðµ: Overbet 2-3x pot Ñ€Ð°Ð·Ð¼ÐµÑ€Ð°\n"
            base += f"â€¢ {num_opponents} Ð¾Ð¿Ð¿Ð¾Ð½ÐµÐ½Ñ‚Ð¾Ð²: ÐšÑ‚Ð¾-Ñ‚Ð¾ Ð¾Ð±ÑÐ·Ð°Ñ‚ÐµÐ»ÑŒÐ½Ð¾ Ð·Ð°Ð¿Ð»Ð°Ñ‚Ð¸Ñ‚\n\n"
            
            return base + self._add_positional_advice(
                "Slow-play Ñ€Ð°Ð·Ñ€ÐµÑˆÐµÐ½ Ð´Ð»Ñ trap'Ð°",
                "ÐÐ³Ñ€ÐµÑÑÐ¸Ñ ÑÑ€Ð°Ð·Ñƒ - Ð½Ðµ Ð´Ð°Ð²Ð°Ñ‚ÑŒ Ð´ÐµÑˆÐµÐ²Ñ‹Ñ… ÐºÐ°Ñ€Ñ‚"
            )
    
    # ===================== STRONG HANDS =====================
    
    def _recommend_strong(
        self,
        hand_type: str,
        win_rate: float,
        texture: Dict,
        num_opponents: int,
        stage: GameStage,
        texture_match: Dict,
        outs_breakdown: Dict
    ) -> str:
        """Ð ÐµÐºÐ¾Ð¼ÐµÐ½Ð´Ð°Ñ†Ð¸Ð¸ Ð´Ð»Ñ ÑÐ¸Ð»ÑŒÐ½Ñ‹Ñ… Ñ€ÑƒÐº (Ñ„Ð»ÐµÑˆ, ÑÑ‚Ñ€Ð¸Ñ‚)"""
        
        base = "ðŸ’ª **Ð¡Ð˜Ð›Ð¬ÐÐÐ¯ Ð Ð£ÐšÐ**\n\n"
        
        # Ð¤Ð»ÐµÑˆ
        if hand_type == 'flush':
            base += "â™ ï¸ **Ð¤Ð»ÐµÑˆ**\n"
            
            if texture_match['flush_compatible']:
                base += "âš ï¸ **Ð’ÐÐ˜ÐœÐÐÐ˜Ð•**: ÐœÐ¾Ð½Ð¾Ñ‚Ð¾Ð½Ð½Ñ‹Ð¹ Ð±Ð¾Ñ€Ð´ - Ð²Ð¾Ð·Ð¼Ð¾Ð¶ÐµÐ½ ÑÑ‚Ð°Ñ€ÑˆÐ¸Ð¹ Ñ„Ð»ÐµÑˆ Ñƒ Ð¾Ð¿Ð¿Ð¾Ð½ÐµÐ½Ñ‚Ð°!\n"
                base += "â€¢ ÐžÑ†ÐµÐ½Ð¸Ñ‚Ðµ ÑÑ‚Ð°Ñ€ÑˆÐ¸Ð½ÑÑ‚Ð²Ð¾ Ð²Ð°ÑˆÐµÐ³Ð¾ Ñ„Ð»ÐµÑˆÐ°:\n"
                base += "  - ÐžÑ€ÐµÑ…Ð¾Ð²Ñ‹Ð¹/Ð²Ñ‚Ð¾Ñ€Ð¾Ð¹ Ñ„Ð»ÐµÑˆ: ÐÐ³Ñ€ÐµÑÑÐ¸Ð²Ð½Ð°Ñ Ð¸Ð³Ñ€Ð°\n"
                base += "  - ÐÐ¸Ð·ÐºÐ¸Ð¹ Ñ„Ð»ÐµÑˆ: ÐžÑÑ‚Ð¾Ñ€Ð¾Ð¶Ð½Ð°Ñ Ð¸Ð³Ñ€Ð°, pot control\n\n"
            else:
                base += "âœ… Ð¤Ð»ÐµÑˆ Ð½Ð° 2-tone Ð±Ð¾Ñ€Ð´Ðµ - Ð¾Ð¿Ð¿Ð¾Ð½ÐµÐ½Ñ‚Ñ‹ Ð½Ðµ Ð¾Ð¶Ð¸Ð´Ð°ÑŽÑ‚!\n\n"
            
            if win_rate >= 75:
                base += "âœ… **Ð’Ð¸Ð½Ñ€ÐµÐ¹Ñ‚ Ð¾Ñ‚Ð»Ð¸Ñ‡Ð½Ñ‹Ð¹** - Ð¸Ð³Ñ€Ð°ÐµÐ¼ Ð½Ð° value!\n"
                base += "**Ð”ÐµÐ¹ÑÑ‚Ð²Ð¸Ñ:**\n"
                base += "â€¢ Ð¤Ð»Ð¾Ð¿/Ñ‚ÐµÑ€Ð½: Bet Ð´Ð»Ñ Ð·Ð°Ñ‰Ð¸Ñ‚Ñ‹ Ð¸ value\n"
                base += "â€¢ Ð Ð¸Ð²ÐµÑ€: ÐšÑ€ÑƒÐ¿Ð½Ñ‹Ð¹ value bet (60-75% pot)\n"
            elif win_rate >= 55:
                base += "âš ï¸ **Ð’Ð¸Ð½Ñ€ÐµÐ¹Ñ‚ ÑƒÐ¼ÐµÑ€ÐµÐ½Ð½Ñ‹Ð¹** - Ð¾ÑÑ‚Ð¾Ñ€Ð¾Ð¶Ð½Ð°Ñ Ð¸Ð³Ñ€Ð°\n"
                base += "**Ð”ÐµÐ¹ÑÑ‚Ð²Ð¸Ñ:**\n"
                base += "â€¢ Ð¡Ñ€ÐµÐ´Ð½Ð¸Ðµ ÑÑ‚Ð°Ð²ÐºÐ¸ Ð´Ð»Ñ value\n"
                base += "â€¢ Ð˜Ð·Ð±ÐµÐ³Ð°Ñ‚ÑŒ Ð¾Ð³Ñ€Ð¾Ð¼Ð½Ñ‹Ñ… Ð±Ð°Ð½ÐºÐ¾Ð²\n"
            else:
                base += "âŒ **Ð’Ð¸Ð½Ñ€ÐµÐ¹Ñ‚ Ð½Ð¸Ð·ÐºÐ¸Ð¹** - pot control Ð¾Ð±ÑÐ·Ð°Ñ‚ÐµÐ»ÐµÐ½!\n"
                base += "**Ð”ÐµÐ¹ÑÑ‚Ð²Ð¸Ñ:**\n"
                base += "â€¢ Ð§ÐµÐº-ÐºÐ¾Ð»Ð» Ð»Ð¸Ð½Ð¸Ñ\n"
                base += "â€¢ Fold Ðº Ð°Ð³Ñ€ÐµÑÑÐ¸Ð¸, ÐµÑÐ»Ð¸ Ð±Ð¾Ñ€Ð´ Ð¿Ð°Ñ€Ð½Ñ‹Ð¹ (Ñ„ÑƒÐ»Ð»-Ñ…Ð°ÑƒÑ)\n"
            
            base += f"\nâ€¢ ÐŸÑ€Ð¾Ñ‚Ð¸Ð² {num_opponents} Ð¾Ð¿Ð¿Ð¾Ð½ÐµÐ½Ñ‚Ð¾Ð²: "
            if num_opponents == 1:
                base += "ÐœÐ¾Ð¶Ð½Ð¾ Ð±Ð»ÐµÑ„ÐºÑÑ‚Ñ‡Ð¸Ñ‚ÑŒ\n"
            else:
                base += "ÐžÑÑ‚Ð¾Ñ€Ð¾Ð¶Ð½ÐµÐµ - ÐºÑ‚Ð¾-Ñ‚Ð¾ Ð¼Ð¾Ð¶ÐµÑ‚ Ð¸Ð¼ÐµÑ‚ÑŒ ÑÑ‚Ð°Ñ€ÑˆÐ¸Ð¹ Ñ„Ð»ÐµÑˆ\n"
            
            base += "\n" + self._add_opponent_behavior_advice(**{
                "Ð°Ð³Ñ€ÐµÑÑÐ¸Ð²ÐµÐ½": "Ð§ÐµÐº-ÐºÐ¾Ð»Ð» Ð¸Ð»Ð¸ Ñ‡ÐµÐº-Ñ€ÐµÐ¹Ð· ÐµÑÐ»Ð¸ Ñ„Ð»ÐµÑˆ ÑÑ‚Ð°Ñ€ÑˆÐ¸Ð¹",
                "Ð¿Ð°ÑÑÐ¸Ð²ÐµÐ½": "Bet Ð´Ð»Ñ value - Ð²Ð¾Ð·ÑŒÐ¼Ñ‘Ñ‚ Ñ Ð¼Ð»Ð°Ð´ÑˆÐ¸Ð¼Ð¸ Ñ€ÑƒÐºÐ°Ð¼Ð¸",
                "Ð½Ð° Ñ‚Ð¸Ð»ÑŒÑ‚Ðµ": "ÐœÐ°ÐºÑÐ¸Ð¼Ð°Ð»ÑŒÐ½Ð°Ñ Ð°Ð³Ñ€ÐµÑÑÐ¸Ñ - Ð·Ð°Ð¿Ð»Ð°Ñ‚Ð¸Ñ‚ ÑˆÐ¸Ñ€Ð¾ÐºÐ¾"
            })
            
        # Ð¡Ñ‚Ñ€Ð¸Ñ‚
        else:  # straight
            base += "ðŸ“Š **Ð¡Ñ‚Ñ€Ð¸Ñ‚**\n"
            
            if texture_match['straight_compatible']:
                base += "âš ï¸ ÐšÐ¾Ð¾Ñ€Ð´Ð¸Ð½Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð½Ñ‹Ð¹ Ð±Ð¾Ñ€Ð´ - Ð²Ð°Ñˆ ÑÑ‚Ñ€Ð¸Ñ‚ Ð²Ð¸Ð´ÐµÐ½!\n"
                base += "â€¢ ÐžÐ¿Ð¿Ð¾Ð½ÐµÐ½Ñ‚Ñ‹ Ð¼Ð¾Ð³ÑƒÑ‚ Ð¸Ð¼ÐµÑ‚ÑŒ Ñ‚Ð¾Ñ‚ Ð¶Ðµ ÑÑ‚Ñ€Ð¸Ñ‚ (ÑÐ¿Ð»Ð¸Ñ‚) Ð¸Ð»Ð¸ ÑÑ‚Ð°Ñ€ÑˆÐ¸Ð¹ ÑÑ‚Ñ€Ð¸Ñ‚\n"
                base += "â€¢ ÐŸÑ€Ð¾Ð²ÐµÑ€ÑŒÑ‚Ðµ, Ð¾Ñ€ÐµÑ…Ð¾Ð²Ñ‹Ð¹ Ð»Ð¸ Ð²Ð°Ñˆ ÑÑ‚Ñ€Ð¸Ñ‚\n\n"
            
            if texture.get('monotone') or texture.get('flush_draw'):
                base += "âš ï¸ **ÐžÐŸÐÐ¡ÐÐžÐ¡Ð¢Ð¬ Ð¤Ð›Ð•Ð¨Ð** Ð½Ð° Ð±Ð¾Ñ€Ð´Ðµ!\n"
                base += "â€¢ Ð˜Ð³Ñ€Ð°Ð¹Ñ‚Ðµ Ð¾ÑÑ‚Ð¾Ñ€Ð¾Ð¶Ð½Ð¾ ÐµÑÐ»Ð¸ Ð±Ð¾Ñ€Ð´ 3-flush\n"
                base += "â€¢ ÐÐ° Ñ€Ð¸Ð²ÐµÑ€Ðµ Ðº Ñ„Ð»ÐµÑˆÑƒ - Ñ‚Ð¾Ð»ÑŒÐºÐ¾ Ñ‡ÐµÐº-ÐºÐ¾Ð»Ð» Ð¼Ð°Ð»Ñ‹Ñ… ÑÑ‚Ð°Ð²Ð¾Ðº\n\n"
            
            if win_rate >= 70:
                base += "âœ… **Ð¡Ð¸Ð»ÑŒÐ½Ñ‹Ð¹ ÑÑ‚Ñ€Ð¸Ñ‚** - Ð¸Ð³Ñ€Ð°ÐµÐ¼ Ð°Ð³Ñ€ÐµÑÑÐ¸Ð²Ð½Ð¾\n"
                base += "**Ð”ÐµÐ¹ÑÑ‚Ð²Ð¸Ñ:**\n"
                base += "â€¢ Bet Ð´Ð»Ñ value Ð¸ Ð·Ð°Ñ‰Ð¸Ñ‚Ñ‹ Ð¾Ñ‚ Ð´Ñ€Ð¾\n"
                base += "â€¢ ÐÐµ Ð´Ð°Ð²Ð°Ñ‚ÑŒ Ð±ÐµÑÐ¿Ð»Ð°Ñ‚Ð½Ñ‹Ñ… ÐºÐ°Ñ€Ñ‚ Ðº Ñ„Ð»ÐµÑˆÑƒ\n"
            else:
                base += "âš ï¸ **Ð£ÑÐ·Ð²Ð¸Ð¼Ñ‹Ð¹ ÑÑ‚Ñ€Ð¸Ñ‚** - pot control\n"
                base += "**Ð”ÐµÐ¹ÑÑ‚Ð²Ð¸Ñ:**\n"
                base += "â€¢ Ð¡Ñ€ÐµÐ´Ð½Ð¸Ðµ ÑÑ‚Ð°Ð²ÐºÐ¸\n"
                base += "â€¢ Fold Ðº Ð°Ð³Ñ€ÐµÑÑÐ¸Ð¸ Ð½Ð° Ñ„Ð»ÐµÑˆÐµÐ²Ð¾Ð¼/Ð¿Ð°Ñ€Ð½Ð¾Ð¼ Ñ€Ð¸Ð²ÐµÑ€Ðµ\n"
            
            base += f"\nâ€¢ {num_opponents} Ð¾Ð¿Ð¿Ð¾Ð½ÐµÐ½Ñ‚Ð¾Ð²: "
            if num_opponents >= 3:
                base += "Multiway - ÐºÑ‚Ð¾-Ñ‚Ð¾ Ð¼Ð¾Ð¶ÐµÑ‚ Ð¸Ð¼ÐµÑ‚ÑŒ Ñ„Ð»ÐµÑˆ/Ñ„ÑƒÐ»Ð»-Ñ…Ð°ÑƒÑ\n"
            
            base += "\n" + self._add_positional_advice(
                "ÐœÐ¾Ð¶Ð½Ð¾ Ñ‡ÐµÐº-Ñ€ÐµÐ¹Ð· Ð½Ð° Ñ‚ÐµÑ€Ð½Ðµ Ð´Ð»Ñ Ð¼Ð°ÐºÑÐ¸Ð¼Ð¸Ð·Ð°Ñ†Ð¸Ð¸",
                "Bet ÑÑ€Ð°Ð·Ñƒ - Ð½Ðµ Ð´Ð°Ð²Ð°Ñ‚ÑŒ Ð´ÐµÑˆÐµÐ²Ñ‹Ñ… ÐºÐ°Ñ€Ñ‚ Ð¾Ð¿Ð¿Ð¾Ð½ÐµÐ½Ñ‚Ð°Ð¼"
            )
        
        return base
    
    # ===================== MEDIUM HANDS =====================
    
    def _recommend_medium(
        self,
        hand_type: str,
        win_rate: float,
        texture: Dict,
        num_opponents: int,
        stage: GameStage,
        texture_match: Dict,
        total_outs: int
    ) -> str:
        """Ð ÐµÐºÐ¾Ð¼ÐµÐ½Ð´Ð°Ñ†Ð¸Ð¸ Ð´Ð»Ñ ÑÑ€ÐµÐ´Ð½Ð¸Ñ… Ñ€ÑƒÐº"""
        
        base = "ðŸŽ¯ **Ð¡Ð Ð•Ð”ÐÐ¯Ð¯ Ð Ð£ÐšÐ**\n\n"
        
        # Ð¡ÐµÑ‚/Ñ‚Ñ€Ð¸Ð¿Ñ
        if hand_type == 'three_kind':
            base += "ðŸŽ² **Ð¡ÐµÑ‚/Ð¢Ñ€Ð¸Ð¿Ñ**\n"
            
            if texture_match['set_compatible']:
                base += "âœ… Ð¡ÐºÑ€Ñ‹Ñ‚Ñ‹Ð¹ ÑÐµÑ‚ Ð½Ð° Ð½ÐµÐ¿Ð°Ñ€Ð½Ð¾Ð¼ Ð±Ð¾Ñ€Ð´Ðµ - ÑÐ¸Ð»ÑŒÐ½Ð°Ñ Ñ€ÑƒÐºÐ°!\n\n"
            else:
                base += "âš ï¸ Ð¢Ñ€Ð¸Ð¿Ñ Ð½Ð° Ð¿Ð°Ñ€Ð½Ð¾Ð¼ Ð±Ð¾Ñ€Ð´Ðµ - Ð¾Ð¿Ð¿Ð¾Ð½ÐµÐ½Ñ‚ Ð¼Ð¾Ð¶ÐµÑ‚ Ð¸Ð¼ÐµÑ‚ÑŒ Ñ„ÑƒÐ»Ð»-Ñ…Ð°ÑƒÑ\n\n"
            
            # ÐŸÑ€Ð¾Ð²ÐµÑ€ÑÐµÐ¼ Ð¾Ð¿Ð°ÑÐ½Ð¾ÑÑ‚Ð¸ Ð½Ð° Ð±Ð¾Ñ€Ð´Ðµ
            dangers = []
            if texture.get('monotone'):
                dangers.append("Ð¼Ð¾Ð½Ð¾Ñ‚Ð¾Ð½Ð½Ñ‹Ð¹ Ð±Ð¾Ñ€Ð´ (Ñ„Ð»ÐµÑˆ)")
            if texture.get('coordinated'):
                dangers.append("ÐºÐ¾Ð¾Ñ€Ð´Ð¸Ð½Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð½Ñ‹Ð¹ Ð±Ð¾Ñ€Ð´ (ÑÑ‚Ñ€Ð¸Ñ‚)")
            
            if dangers:
                base += f"âš ï¸ **ÐžÐŸÐÐ¡ÐÐžÐ¡Ð¢Ð˜**: {', '.join(dangers)}\n"
                base += "â€¢ Ð¡ÐµÑ‚ ÑƒÑÐ·Ð²Ð¸Ð¼ Ðº ÑÑ‚Ð°Ñ€ÑˆÐ¸Ð¼ ÐºÐ¾Ð¼Ð±Ð¸Ð½Ð°Ñ†Ð¸ÑÐ¼\n"
                base += "â€¢ Ð˜Ð³Ñ€Ð°Ð¹Ñ‚Ðµ Ð¾ÑÑ‚Ð¾Ñ€Ð¾Ð¶Ð½ÐµÐµ Ð½Ð° Ð¾Ð¿Ð°ÑÐ½Ñ‹Ñ… Ð±Ð¾Ñ€Ð´Ð°Ñ…\n\n"
            
            # ÐÑƒÑ‚Ñ‹ Ð½Ð° ÑƒÐ»ÑƒÑ‡ÑˆÐµÐ½Ð¸Ðµ
            if total_outs >= 7:  # Ð°ÑƒÑ‚Ñ‹ Ð½Ð° Ñ„ÑƒÐ»Ð»-Ñ…Ð°ÑƒÑ
                base += f"ðŸŽ¯ Ð£ Ð²Ð°Ñ {total_outs} Ð°ÑƒÑ‚Ð¾Ð² Ð½Ð° Ñ„ÑƒÐ»Ð»-Ñ…Ð°ÑƒÑ!\n"
                base += "â€¢ ÐœÐ¾Ð¶Ð½Ð¾ Ð°Ð³Ñ€ÐµÑÑÐ¸Ð²Ð½Ð¾ Ð¸Ð³Ñ€Ð°Ñ‚ÑŒ Ð´Ð°Ð¶Ðµ Ð¿Ñ€Ð¾Ñ‚Ð¸Ð² Ð²Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ð¾Ð³Ð¾ Ñ„Ð»ÐµÑˆÐ°\n\n"
            
            if win_rate >= 60:
                base += "âœ… **Ð’Ð¸Ð½Ñ€ÐµÐ¹Ñ‚ Ñ…Ð¾Ñ€Ð¾ÑˆÐ¸Ð¹** - Ð¸Ð³Ñ€Ð°ÐµÐ¼ Ð½Ð° value\n"
                base += "**Ð”ÐµÐ¹ÑÑ‚Ð²Ð¸Ñ:**\n"
                base += "â€¢ Ð¤Ð»Ð¾Ð¿: Bet Ð´Ð»Ñ Ð·Ð°Ñ‰Ð¸Ñ‚Ñ‹ Ð¸ value (50-60% pot)\n"
                base += "â€¢ Ð¢ÐµÑ€Ð½: ÐŸÑ€Ð¾Ð´Ð¾Ð»Ð¶Ð°ÐµÐ¼ bet\n"
                base += "â€¢ Ð Ð¸Ð²ÐµÑ€: Value bet ÐµÑÐ»Ð¸ Ð½ÐµÑ‚ Ñ„Ð»ÐµÑˆÐ° Ð½Ð° Ð±Ð¾Ñ€Ð´Ðµ\n"
            elif win_rate >= 45:
                base += "âš ï¸ **Ð’Ð¸Ð½Ñ€ÐµÐ¹Ñ‚ ÑÑ€ÐµÐ´Ð½Ð¸Ð¹** - Ð¾ÑÑ‚Ð¾Ñ€Ð¾Ð¶Ð½Ð°Ñ Ð¸Ð³Ñ€Ð°\n"
                base += "**Ð”ÐµÐ¹ÑÑ‚Ð²Ð¸Ñ:**\n"
                base += "â€¢ ÐœÐ°Ð»Ñ‹Ðµ/ÑÑ€ÐµÐ´Ð½Ð¸Ðµ ÑÑ‚Ð°Ð²ÐºÐ¸\n"
                base += "â€¢ Ð§ÐµÐº-ÐºÐ¾Ð»Ð» Ðº Ð°Ð³Ñ€ÐµÑÑÐ¸Ð¸ Ð½Ð° Ð¾Ð¿Ð°ÑÐ½Ñ‹Ñ… Ð±Ð¾Ñ€Ð´Ð°Ñ…\n"
            else:
                base += "âŒ **Ð’Ð¸Ð½Ñ€ÐµÐ¹Ñ‚ Ð½Ð¸Ð·ÐºÐ¸Ð¹** - ÑÐºÐ¾Ñ€ÐµÐµ Ð²ÑÐµÐ³Ð¾ ÑƒÐ¶Ðµ Ð¿Ð¾Ð·Ð°Ð´Ð¸\n"
                base += "**Ð”ÐµÐ¹ÑÑ‚Ð²Ð¸Ñ:**\n"
                base += "â€¢ Ð§ÐµÐº-fold Ð¸Ð»Ð¸ fold Ðº ÐºÑ€ÑƒÐ¿Ð½Ñ‹Ð¼ ÑÑ‚Ð°Ð²ÐºÐ°Ð¼\n"
                base += "â€¢ Ð¢Ð¾Ð»ÑŒÐºÐ¾ cheap showdown\n"
            
            base += f"\nâ€¢ {num_opponents} Ð¾Ð¿Ð¿Ð¾Ð½ÐµÐ½Ñ‚Ð¾Ð²: "
            if num_opponents >= 3:
                base += "Multiway - Ð²Ñ‹ÑÐ¾Ðº Ñ€Ð¸ÑÐº Ñ„Ð»ÐµÑˆÐ°/ÑÑ‚Ñ€Ð¸Ñ‚Ð° Ñƒ ÐºÐ¾Ð³Ð¾-Ñ‚Ð¾\n"
            else:
                base += "Heads-up - Ð¼Ð¾Ð¶ÐµÑ‚Ðµ Ð¸Ð³Ñ€Ð°Ñ‚ÑŒ Ð°Ð³Ñ€ÐµÑÑÐ¸Ð²Ð½ÐµÐµ\n"
        
        # Ð”Ð²Ðµ Ð¿Ð°Ñ€Ñ‹
        else:  # two_pair
            base += "ðŸŽ´ **Ð”Ð²Ðµ Ð¿Ð°Ñ€Ñ‹**\n"
            
            if texture.get('paired'):
                base += "âš ï¸ ÐŸÐ°Ñ€Ð½Ñ‹Ð¹ Ð±Ð¾Ñ€Ð´ - Ð²Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ñ‹ ÑÑ‚Ð°Ñ€ÑˆÐ¸Ðµ Ð´Ð²Ðµ Ð¿Ð°Ñ€Ñ‹/Ñ‚Ñ€Ð¸Ð¿Ñ/Ñ„ÑƒÐ»Ð»-Ñ…Ð°ÑƒÑ\n\n"
            else:
                base += "âœ… Ð¥Ð¾Ñ€Ð¾ÑˆÐ°Ñ Ñ€ÑƒÐºÐ° Ð½Ð° Ð½ÐµÐ¿Ð°Ñ€Ð½Ð¾Ð¼ Ð±Ð¾Ñ€Ð´Ðµ\n\n"
            
            # ÐžÐ¿Ð°ÑÐ½Ð¾ÑÑ‚Ð¸
            dangers = []
            if texture.get('monotone'):
                dangers.append("Ñ„Ð»ÐµÑˆ")
            if texture.get('coordinated'):
                dangers.append("ÑÑ‚Ñ€Ð¸Ñ‚")
            if texture.get('paired'):
                dangers.append("Ñ„ÑƒÐ»Ð»-Ñ…Ð°ÑƒÑ/Ñ‚Ñ€Ð¸Ð¿Ñ")
            
            if dangers:
                base += f"âš ï¸ **Ð’Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ñ‹Ðµ Ð¾Ð¿Ð°ÑÐ½Ð¾ÑÑ‚Ð¸**: {', '.join(dangers)}\n\n"
            
            # ÐÑƒÑ‚Ñ‹ Ð½Ð° ÑƒÐ»ÑƒÑ‡ÑˆÐµÐ½Ð¸Ðµ
            if total_outs >= 4:
                base += f"ðŸŽ¯ {total_outs} Ð°ÑƒÑ‚Ð¾Ð² Ð½Ð° Ñ„ÑƒÐ»Ð»-Ñ…Ð°ÑƒÑ!\n"
                base += "â€¢ ÐŸÑ€Ð¸ Ð°Ð³Ñ€ÐµÑÑÐ¸Ð¸ Ð¾Ð¿Ð¿Ð¾Ð½ÐµÐ½Ñ‚Ð° - ÐµÑÑ‚ÑŒ ÑˆÐ°Ð½Ñ Ð¿ÐµÑ€ÐµÐµÑ…Ð°Ñ‚ÑŒ\n\n"
            
            if win_rate >= 65:
                base += "âœ… **Ð’Ð¸Ð½Ñ€ÐµÐ¹Ñ‚ Ð¾Ñ‚Ð»Ð¸Ñ‡Ð½Ñ‹Ð¹** - Ð°Ð³Ñ€ÐµÑÑÐ¸Ð²Ð½Ð°Ñ Ð¸Ð³Ñ€Ð°\n"
                base += "**Ð”ÐµÐ¹ÑÑ‚Ð²Ð¸Ñ:**\n"
                base += "â€¢ Bet Ð´Ð»Ñ value Ð½Ð° Ð²ÑÐµÑ… ÑƒÐ»Ð¸Ñ†Ð°Ñ…\n"
                base += "â€¢ Ð—Ð°Ñ‰Ð¸Ñ‚Ð° Ð¾Ñ‚ Ð´Ñ€Ð¾ Ð¾Ð±ÑÐ·Ð°Ñ‚ÐµÐ»ÑŒÐ½Ð°\n"
            elif win_rate >= 50:
                base += "âœ… **Ð’Ð¸Ð½Ñ€ÐµÐ¹Ñ‚ Ñ…Ð¾Ñ€Ð¾ÑˆÐ¸Ð¹** - Ð¸Ð³Ñ€Ð°ÐµÐ¼ Ð½Ð° value\n"
                base += "**Ð”ÐµÐ¹ÑÑ‚Ð²Ð¸Ñ:**\n"
                base += "â€¢ Ð¡Ñ€ÐµÐ´Ð½Ð¸Ðµ ÑÑ‚Ð°Ð²ÐºÐ¸ Ð´Ð»Ñ value\n"
                base += "â€¢ ÐžÑÑ‚Ð¾Ñ€Ð¾Ð¶Ð½Ð¾ÑÑ‚ÑŒ Ð½Ð° Ð¾Ð¿Ð°ÑÐ½Ñ‹Ñ… Ñ€Ð¸Ð²Ð°Ñ…\n"
            else:
                base += "âš ï¸ **Ð’Ð¸Ð½Ñ€ÐµÐ¹Ñ‚ Ð½Ð¸Ð·ÐºÐ¸Ð¹** - pot control\n"
                base += "**Ð”ÐµÐ¹ÑÑ‚Ð²Ð¸Ñ:**\n"
                base += "â€¢ Ð§ÐµÐº-ÐºÐ¾Ð»Ð» Ð¼Ð°Ð»Ñ‹Ñ… ÑÑ‚Ð°Ð²Ð¾Ðº\n"
                base += "â€¢ Fold Ðº Ð°Ð³Ñ€ÐµÑÑÐ¸Ð¸ Ð½Ð° Ñ„Ð»ÐµÑˆÐµÐ²Ñ‹Ñ…/ÑÑ‚Ñ€Ð¸Ñ‚Ð¾Ð²Ñ‹Ñ… Ð±Ð¾Ñ€Ð°Ñ…\n"
            
            if stage == GameStage.RIVER:
                base += "\nðŸ“Œ **ÐÐ° Ñ€Ð¸Ð²ÐµÑ€Ðµ:**\n"
                if texture.get('monotone') or texture.get('coordinated'):
                    base += "â€¢ ÐžÐ¿Ð°ÑÐ½Ñ‹Ð¹ Ð±Ð¾Ñ€Ð´ Ð·Ð°Ð²ÐµÑ€ÑˆÐ¸Ð»ÑÑ - Ñ‚Ð¾Ð»ÑŒÐºÐ¾ Ñ‡ÐµÐº-ÐºÐ¾Ð»Ð» Ð¼Ð°Ð»Ñ‹Ñ… ÑÑ‚Ð°Ð²Ð¾Ðº\n"
                else:
                    base += "â€¢ Ð¡ÑƒÑ…Ð¾Ð¹ Ð±Ð¾Ñ€Ð´ - value bet 50-60% pot\n"
        
        base += "\n" + self._add_opponent_behavior_advice(**{
            "Ð°Ð³Ñ€ÐµÑÑÐ¸Ð²ÐµÐ½": "Ð§ÐµÐº-ÐºÐ¾Ð»Ð» Ð¸Ð»Ð¸ Ñ‡ÐµÐº-Ñ€ÐµÐ¹Ð· ÐµÑÐ»Ð¸ ÑƒÐ²ÐµÑ€ÐµÐ½Ñ‹ Ð² Ð¿Ñ€ÐµÐ¸Ð¼ÑƒÑ‰ÐµÑÑ‚Ð²Ðµ",
            "Ð¿Ð°ÑÑÐ¸Ð²ÐµÐ½": "Value bet - Ð²Ð¾Ð·ÑŒÐ¼Ñ‘Ñ‚ Ñ Ð¼Ð»Ð°Ð´ÑˆÐ¸Ð¼Ð¸ Ð¿Ð°Ñ€Ð°Ð¼Ð¸",
            "Ñ‚Ð°Ð¹Ñ‚Ð¾Ð²": "ÐœÐ°Ð»Ñ‹Ðµ ÑÑ‚Ð°Ð²ÐºÐ¸ - Ð¿Ð»Ð°Ñ‚Ð¸Ñ‚ Ñ‚Ð¾Ð»ÑŒÐºÐ¾ Ñ Ñ€ÐµÐ°Ð»ÑŒÐ½Ñ‹Ð¼Ð¸ Ñ€ÑƒÐºÐ°Ð¼Ð¸"
        })
        
        return base
    
    # ===================== WEAK MADE HANDS =====================
    
    def _recommend_weak_made(
        self,
        hand_type: str,
        win_rate: float,
        texture: Dict,
        num_opponents: int,
        stage: GameStage,
        total_outs: int,
        outs_breakdown: Dict
    ) -> str:
        """Ð ÐµÐºÐ¾Ð¼ÐµÐ½Ð´Ð°Ñ†Ð¸Ð¸ Ð´Ð»Ñ ÑÐ»Ð°Ð±Ñ‹Ñ… Ð³Ð¾Ñ‚Ð¾Ð²Ñ‹Ñ… Ñ€ÑƒÐº (Ð¾Ð´Ð½Ð° Ð¿Ð°Ñ€Ð°)"""
        
        base = "âš ï¸ **Ð¡Ð›ÐÐ‘ÐÐ¯ Ð“ÐžÐ¢ÐžÐ’ÐÐ¯ Ð Ð£ÐšÐ**\n\n"
        base += "ðŸƒ **ÐžÐ´Ð½Ð° Ð¿Ð°Ñ€Ð°**\n"
        
        # ÐžÑ†ÐµÐ½ÐºÐ° Ð¾Ð¿Ð°ÑÐ½Ð¾ÑÑ‚Ð¸ Ð±Ð¾Ñ€Ð´Ð°
        danger_level = 0
        dangers = []
        
        if texture.get('monotone'):
            danger_level += 3
            dangers.append("Ð¼Ð¾Ð½Ð¾Ñ‚Ð¾Ð½Ð½Ñ‹Ð¹ Ð±Ð¾Ñ€Ð´ (Ñ„Ð»ÐµÑˆ)")
        elif texture.get('flush_draw'):
            danger_level += 2
            dangers.append("Ñ„Ð»ÐµÑˆ-Ð´Ñ€Ð¾ Ð½Ð° Ð±Ð¾Ñ€Ð´Ðµ")
        
        if texture.get('coordinated'):
            danger_level += 2
            dangers.append("ÐºÐ¾Ð¾Ñ€Ð´Ð¸Ð½Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð½Ñ‹Ð¹ Ð±Ð¾Ñ€Ð´ (ÑÑ‚Ñ€Ð¸Ñ‚Ñ‹)")
        
        if texture.get('paired'):
            danger_level += 2
            dangers.append("Ð¿Ð°Ñ€Ð½Ñ‹Ð¹ Ð±Ð¾Ñ€Ð´ (Ñ‚Ñ€Ð¸Ð¿ÑÑ‹)")
        
        if dangers:
            base += f"âš ï¸ **ÐžÐŸÐÐ¡ÐÐžÐ¡Ð¢Ð˜** ({danger_level}/10): {', '.join(dangers)}\n\n"
        else:
            base += "âœ… Ð¡ÑƒÑ…Ð¾Ð¹ Ð±Ð¾Ñ€Ð´ - Ð²Ð°ÑˆÐ° Ð¿Ð°Ñ€Ð° Ð¼Ð¾Ð¶ÐµÑ‚ Ð±Ñ‹Ñ‚ÑŒ Ð»ÑƒÑ‡ÑˆÐµÐ¹\n\n"
        
        # ÐÑƒÑ‚Ñ‹ Ð½Ð° ÑƒÐ»ÑƒÑ‡ÑˆÐµÐ½Ð¸Ðµ
        if total_outs >= 5:
            base += f"ðŸŽ¯ {total_outs} Ð°ÑƒÑ‚Ð¾Ð² Ð½Ð° ÑƒÐ»ÑƒÑ‡ÑˆÐµÐ½Ð¸Ðµ:\n"
            if outs_breakdown.get('set_trips', 0) >= 2:
                base += f"  â€¢ {outs_breakdown['set_trips']} Ð°ÑƒÑ‚Ð¾Ð² Ð½Ð° ÑÐµÑ‚\n"
            if outs_breakdown.get('two_pair', 0) >= 3:
                base += f"  â€¢ ÐÑƒÑ‚Ñ‹ Ð½Ð° Ð´Ð²Ðµ Ð¿Ð°Ñ€Ñ‹\n"
            base += "â€¢ ÐœÐ¾Ð¶Ð½Ð¾ Ð¿Ñ€Ð¾Ð´Ð¾Ð»Ð¶Ð°Ñ‚ÑŒ Ñ€Ð¾Ð·Ñ‹Ð³Ñ€Ñ‹Ñˆ Ð¿Ñ€Ð¸ Ñ…Ð¾Ñ€Ð¾ÑˆÐ¸Ñ… pot odds\n\n"
        
        # Ð ÐµÐºÐ¾Ð¼ÐµÐ½Ð´Ð°Ñ†Ð¸Ð¸ Ð¿Ð¾ Ð²Ð¸Ð½Ñ€ÐµÐ¹Ñ‚Ñƒ
        if win_rate >= 70:
            base += "âœ… **Ð’Ð¸Ð½Ñ€ÐµÐ¹Ñ‚ Ð²Ñ‹ÑÐ¾ÐºÐ¸Ð¹** (likely top pair) - Ð¸Ð³Ñ€Ð°ÐµÐ¼ Ð°Ð³Ñ€ÐµÑÑÐ¸Ð²Ð½Ð¾!\n"
            base += "**Ð”ÐµÐ¹ÑÑ‚Ð²Ð¸Ñ:**\n"
            base += "â€¢ Bet Ð´Ð»Ñ value Ð¸ Ð·Ð°Ñ‰Ð¸Ñ‚Ñ‹ Ð¾Ñ‚ Ð´Ñ€Ð¾\n"
            base += "â€¢ ÐÐ° Ñ‚ÐµÑ€Ð½Ðµ/Ñ€Ð¸Ð²ÐµÑ€Ðµ: Ð¿Ñ€Ð¾Ð´Ð¾Ð»Ð¶Ð°ÐµÐ¼ bet ÐµÑÐ»Ð¸ Ð½ÐµÑ‚ Ñ„Ð»ÐµÑˆÐ°/ÑÑ‚Ñ€Ð¸Ñ‚Ð°\n"
            
        elif win_rate >= 55:
            base += "âœ… **Ð’Ð¸Ð½Ñ€ÐµÐ¹Ñ‚ Ñ…Ð¾Ñ€Ð¾ÑˆÐ¸Ð¹** - Ð¸Ð³Ñ€Ð°ÐµÐ¼ Ð½Ð° value Ð¾ÑÑ‚Ð¾Ñ€Ð¾Ð¶Ð½Ð¾\n"
            base += "**Ð”ÐµÐ¹ÑÑ‚Ð²Ð¸Ñ:**\n"
            base += "â€¢ ÐœÐ°Ð»Ñ‹Ðµ/ÑÑ€ÐµÐ´Ð½Ð¸Ðµ ÑÑ‚Ð°Ð²ÐºÐ¸ Ð´Ð»Ñ value\n"
            base += "â€¢ Ð§ÐµÐº-ÐºÐ¾Ð»Ð» Ðº Ð¼Ð°Ð»Ð¾Ð¹ Ð°Ð³Ñ€ÐµÑÑÐ¸Ð¸\n"
            base += "â€¢ Fold Ðº ÐºÑ€ÑƒÐ¿Ð½Ñ‹Ð¼ ÑÑ‚Ð°Ð²ÐºÐ°Ð¼ Ð½Ð° Ð¾Ð¿Ð°ÑÐ½Ñ‹Ñ… Ð±Ð¾Ñ€Ð´Ð°Ñ…\n"
            
        elif win_rate >= 40:
            base += "âš ï¸ **Ð’Ð¸Ð½Ñ€ÐµÐ¹Ñ‚ ÑÑ€ÐµÐ´Ð½Ð¸Ð¹** - pot control\n"
            base += "**Ð”ÐµÐ¹ÑÑ‚Ð²Ð¸Ñ:**\n"
            base += "â€¢ Ð§ÐµÐº-ÐºÐ¾Ð»Ð» Ð¼Ð°Ð»Ñ‹Ñ… ÑÑ‚Ð°Ð²Ð¾Ðº\n"
            base += "â€¢ Fold Ðº Ð°Ð³Ñ€ÐµÑÑÐ¸Ð¸\n"
            base += "â€¢ Cheap showdown ÐµÑÐ»Ð¸ Ð²Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ð¾\n"
            
        else:
            base += "âŒ **Ð’Ð¸Ð½Ñ€ÐµÐ¹Ñ‚ Ð½Ð¸Ð·ÐºÐ¸Ð¹** - Ð²ÐµÑ€Ð¾ÑÑ‚Ð½Ð¾ ÑƒÐ¶Ðµ Ð¿Ð¾Ð·Ð°Ð´Ð¸\n"
            base += "**Ð”ÐµÐ¹ÑÑ‚Ð²Ð¸Ñ:**\n"
            base += "â€¢ Ð§ÐµÐº-fold\n"
            base += "â€¢ Fold Ðº Ð»ÑŽÐ±Ñ‹Ð¼ ÑÑ‚Ð°Ð²ÐºÐ°Ð¼\n"
            base += "â€¢ Bluff-catcher Ñ‚Ð¾Ð»ÑŒÐºÐ¾ Ð² ÑÐ¿ÐµÑ†Ð¸Ð°Ð»ÑŒÐ½Ñ‹Ñ… ÑÐ¸Ñ‚ÑƒÐ°Ñ†Ð¸ÑÑ…\n"
        
        # ÐœÑƒÐ»ÑŒÑ‚Ð¸Ð²ÐµÐ¹ vs heads-up
        base += f"\nâ€¢ **{num_opponents} Ð¾Ð¿Ð¿Ð¾Ð½ÐµÐ½Ñ‚Ð¾Ð²**: "
        if num_opponents >= 4:
            base += "Multiway - Ð¾Ð´Ð½Ð° Ð¿Ð°Ñ€Ð° Ð¾Ñ‡ÐµÐ½ÑŒ ÑÐ»Ð°Ð±Ð°, Ð¸Ð³Ñ€Ð°Ð¹Ñ‚Ðµ ÐºÑ€Ð°Ð¹Ð½Ðµ Ð¾ÑÑ‚Ð¾Ñ€Ð¾Ð¶Ð½Ð¾\n"
        elif num_opponents >= 2:
            base += "3-way - Ð¾ÑÑ‚Ð¾Ñ€Ð¾Ð¶Ð½Ð°Ñ Ð¸Ð³Ñ€Ð°, ÐºÑ‚Ð¾-Ñ‚Ð¾ Ð¼Ð¾Ð¶ÐµÑ‚ Ð¸Ð¼ÐµÑ‚ÑŒ Ð»ÑƒÑ‡ÑˆÐµ\n"
        else:
            base += "Heads-up - Ð¼Ð¾Ð¶ÐµÑ‚Ðµ Ð±Ð»ÐµÑ„ÐºÑÑ‚Ñ‡Ð¸Ñ‚ÑŒ Ñ Ñ…Ð¾Ñ€Ð¾ÑˆÐµÐ¹ Ð¿Ð°Ñ€Ð¾Ð¹\n"
        
        # Ð¡Ñ‚Ð°Ð´Ð¸Ñ Ð¸Ð³Ñ€Ñ‹
        if stage == GameStage.FLOP:
            base += "\nðŸ“Œ **ÐÐ° Ñ„Ð»Ð¾Ð¿Ðµ**: ÐžÑ†ÐµÐ½Ð¸Ñ‚Ðµ Ñ€ÐµÐ°ÐºÑ†Ð¸ÑŽ Ð¾Ð¿Ð¿Ð¾Ð½ÐµÐ½Ñ‚Ð¾Ð² Ð¿ÐµÑ€ÐµÐ´ Ð¸Ð½Ð²ÐµÑÑ‚Ð¸Ñ†Ð¸ÑÐ¼Ð¸\n"
        elif stage == GameStage.TURN:
            base += "\nðŸ“Œ **ÐÐ° Ñ‚ÐµÑ€Ð½Ðµ**: ÐŸÐµÑ€ÐµÐ¾Ñ†ÐµÐ½Ð¸Ð²Ð°Ð¹Ñ‚Ðµ Ñ ÐºÐ°Ð¶Ð´Ð¾Ð¹ Ð½Ð¾Ð²Ð¾Ð¹ ÐºÐ°Ñ€Ñ‚Ð¾Ð¹\n"
        elif stage == GameStage.RIVER:
            base += "\nðŸ“Œ **ÐÐ° Ñ€Ð¸Ð²ÐµÑ€Ðµ**: "
            if danger_level >= 5:
                base += "ÐžÐ¿Ð°ÑÐ½Ñ‹Ð¹ Ð±Ð¾Ñ€Ð´ Ð·Ð°Ð²ÐµÑ€ÑˆÐ¸Ð»ÑÑ - bluff-catcher Ñ‚Ð¾Ð»ÑŒÐºÐ¾ Ñ Ñ‚Ð¾Ð¿-Ð¿Ð°Ñ€Ð¾Ð¹\n"
            else:
                base += "Ð¡ÑƒÑ…Ð¾Ð¹ Ð±Ð¾Ñ€Ð´ - Ð¼Ð¾Ð¶ÐµÑ‚Ðµ Ð¿Ð¾Ð»ÑƒÑ‡Ð¸Ñ‚ÑŒ value Ñ Ñ…Ð¾Ñ€Ð¾ÑˆÐµÐ¹ Ð¿Ð°Ñ€Ð¾Ð¹\n"
        
        base += "\n" + self._add_positional_advice(
            "ÐœÐ¾Ð¶ÐµÑ‚Ðµ Ð±Ð»ÐµÑ„ÐºÑÑ‚Ñ‡Ð¸Ñ‚ÑŒ Ñ Ñ…Ð¾Ñ€Ð¾ÑˆÐµÐ¹ Ð¿Ð°Ñ€Ð¾Ð¹ Ð½Ð° ÑÑƒÑ…Ð¸Ñ… Ð±Ð¾Ñ€Ð´Ð°Ñ…",
            "Ð‘ÐµÐ· Ð¿Ð¾Ð·Ð¸Ñ†Ð¸Ð¸ - Ð¸Ð³Ñ€Ð°Ð¹Ñ‚Ðµ fit-or-fold (Ñ‡ÐµÐº-fold ÐµÑÐ»Ð¸ Ð½Ðµ ÑƒÐ»ÑƒÑ‡ÑˆÐ¸Ð»Ð¸ÑÑŒ)"
        )
        
        base += "\n" + self._add_opponent_behavior_advice(**{
            "Ð°Ð³Ñ€ÐµÑÑÐ¸Ð²ÐµÐ½": "Bluff-catch Ñ Ñ‚Ð¾Ð¿-Ð¿Ð°Ñ€Ð¾Ð¹, fold Ñ Ð¼Ð»Ð°Ð´ÑˆÐ¸Ð¼Ð¸",
            "Ð¿Ð°ÑÑÐ¸Ð²ÐµÐ½": "ÐœÐ°Ð»Ñ‹Ðµ ÑÑ‚Ð°Ð²ÐºÐ¸ Ð´Ð»Ñ value - Ñ‡Ð°ÑÑ‚Ð¾ Ð¿Ð»Ð°Ñ‚Ð¸Ñ‚ Ñ Ñ…ÑƒÐ¶Ðµ",
            "Ñ‚Ð°Ð¹Ñ‚Ð¾Ð²": "Ð§ÐµÐº-fold - ÑÑ‚Ð°Ð²Ð¸Ñ‚ Ñ‚Ð¾Ð»ÑŒÐºÐ¾ Ñ ÑÐ¸Ð»ÑŒÐ½Ñ‹Ð¼Ð¸ Ñ€ÑƒÐºÐ°Ð¼Ð¸"
        })
        
        return base
    
    # ===================== DRAWS =====================
    
    def _recommend_draw(
        self,
        total_outs: int,
        outs_breakdown: Dict,
        win_rate: float,
        texture: Dict,
        num_opponents: int,
        stage: GameStage
    ) -> str:
        """Ð ÐµÐºÐ¾Ð¼ÐµÐ½Ð´Ð°Ñ†Ð¸Ð¸ Ð´Ð»Ñ Ð´Ñ€Ð¾"""
        
        base = "ðŸŽ² **Ð”Ð Ðž / ÐÐ•Ð¢ Ð“ÐžÐ¢ÐžÐ’ÐžÐ™ ÐšÐžÐœÐ‘Ð˜ÐÐÐ¦Ð˜Ð˜**\n\n"
        
        # ÐšÐ»Ð°ÑÑÐ¸Ñ„Ð¸ÐºÐ°Ñ†Ð¸Ñ Ð´Ñ€Ð¾
        flush_outs = outs_breakdown.get('flush', 0)
        straight_outs = outs_breakdown.get('straight', 0)
        set_outs = outs_breakdown.get('set_trips', 0)
        overcard_outs = outs_breakdown.get('overcard', 0)
        
        # ÐžÐ¿Ð¸ÑÐ°Ð½Ð¸Ðµ Ð´Ñ€Ð¾
        draw_types = []
        if flush_outs >= 9:
            draw_types.append(f"Ñ„Ð»ÐµÑˆ-Ð´Ñ€Ð¾ ({flush_outs} Ð°ÑƒÑ‚Ð¾Ð²)")
        if straight_outs >= 8:
            draw_types.append(f"ÑÑ‚Ñ€Ð¸Ñ‚-Ð´Ñ€Ð¾ ({straight_outs} Ð°ÑƒÑ‚Ð¾Ð²)")
        if straight_outs >= 4 and straight_outs < 8:
            draw_types.append(f"Ð³Ð°Ñ‚ÑˆÐ¾Ñ‚ ({straight_outs} Ð°ÑƒÑ‚Ð¾Ð²)")
        if set_outs >= 2:
            draw_types.append(f"Ð¿Ð°Ñ€Ð° Ñ Ð°ÑƒÑ‚Ð°Ð¼Ð¸ Ð½Ð° ÑÐµÑ‚ ({set_outs} Ð°ÑƒÑ‚Ð¾Ð²)")
        if overcard_outs >= 3:
            draw_types.append(f"Ð¾Ð²ÐµÑ€ÐºÐ°Ñ€Ñ‚Ñ‹ ({overcard_outs} Ð°ÑƒÑ‚Ð¾Ð²)")
        
        if draw_types:
            base += f"**Ð£ Ð²Ð°Ñ**: {', '.join(draw_types)}\n"
            base += f"**Ð’ÑÐµÐ³Ð¾ Ð°ÑƒÑ‚Ð¾Ð²**: {total_outs}\n\n"
        else:
            base += "âŒ **Ð—Ð½Ð°Ñ‡Ð¸Ð¼Ñ‹Ñ… Ð´Ñ€Ð¾ Ð½Ðµ Ð¾Ð±Ð½Ð°Ñ€ÑƒÐ¶ÐµÐ½Ð¾**\n\n"
        
        # Ð ÐµÐºÐ¾Ð¼ÐµÐ½Ð´Ð°Ñ†Ð¸Ð¸ Ð¿Ð¾ ÐºÐ¾Ð»Ð¸Ñ‡ÐµÑÑ‚Ð²Ñƒ Ð°ÑƒÑ‚Ð¾Ð²
        if total_outs >= 15:
            base += "ðŸš€ **ÐœÐžÐÐ¡Ð¢Ð -Ð”Ð Ðž** (15+ Ð°ÑƒÑ‚Ð¾Ð²) - Ñ„Ð°Ð²Ð¾Ñ€Ð¸Ñ‚ Ð´Ð°Ð¶Ðµ Ð¿Ñ€Ð¾Ñ‚Ð¸Ð² Ð³Ð¾Ñ‚Ð¾Ð²Ñ‹Ñ… Ñ€ÑƒÐº!\n"
            base += "**Ð”ÐµÐ¹ÑÑ‚Ð²Ð¸Ñ:**\n"
            base += "â€¢ Ð˜Ð³Ñ€Ð°Ð¹Ñ‚Ðµ Ð¼Ð°ÐºÑÐ¸Ð¼Ð°Ð»ÑŒÐ½Ð¾ Ð°Ð³Ñ€ÐµÑÑÐ¸Ð²Ð½Ð¾\n"
            base += "â€¢ Ð ÐµÐ¹Ð·/3-Ð±ÐµÑ‚ Ð´Ð»Ñ semi-bluff\n"
            base += "â€¢ ÐœÐ¾Ð¶ÐµÑ‚Ðµ ÐºÐ¾Ð»Ð»Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ all-in Ð½Ð° Ñ„Ð»Ð¾Ð¿Ðµ/Ñ‚ÐµÑ€Ð½Ðµ\n"
            base += "â€¢ Ð’ Ð¿Ð¾Ð·Ð¸Ñ†Ð¸Ð¸: Ñ€Ð°ÑÑÐ¼Ð¾Ñ‚Ñ€Ð¸Ñ‚Ðµ Ñ‡ÐµÐº-Ñ€ÐµÐ¹Ð·\n\n"
            
            base += self._add_positional_advice(
                "Ð§ÐµÐº-Ñ€ÐµÐ¹Ð· Ð½Ð° Ñ„Ð»Ð¾Ð¿Ðµ Ð´Ð»Ñ Ð¼Ð°ÐºÑÐ¸Ð¼Ð°Ð»ÑŒÐ½Ð¾Ð¹ fold equity",
                "Ð ÐµÐ¹Ð· ÑÑ€Ð°Ð·Ñƒ - Ð½Ðµ Ð´Ð°Ð²Ð°Ð¹Ñ‚Ðµ Ð´ÐµÑˆÐµÐ²Ð¾ ÑƒÐ²Ð¸Ð´ÐµÑ‚ÑŒ ÑÐ»ÐµÐ´ÑƒÑŽÑ‰ÑƒÑŽ ÐºÐ°Ñ€Ñ‚Ñƒ"
            )
        
        elif total_outs >= 12:
            base += "âš¡ **Ð¡Ð˜Ð›Ð¬ÐÐžÐ• Ð”Ð Ðž** (12-14 Ð°ÑƒÑ‚Ð¾Ð²) - Ð¾Ñ‚Ð»Ð¸Ñ‡Ð½Ñ‹Ðµ ÑˆÐ°Ð½ÑÑ‹!\n"
            base += "**Ð”ÐµÐ¹ÑÑ‚Ð²Ð¸Ñ:**\n"
            base += "â€¢ ÐÐ³Ñ€ÐµÑÑÐ¸Ð²Ð½Ð°Ñ Ð¸Ð³Ñ€Ð° Ð¾Ð¿Ñ€Ð°Ð²Ð´Ð°Ð½Ð°\n"
            base += "â€¢ Bet/raise Ð´Ð»Ñ semi-bluff\n"
            base += "â€¢ ÐšÐ¾Ð»Ð»Ð¸Ñ€ÑƒÐ¹Ñ‚Ðµ ÑÑ€ÐµÐ´Ð½Ð¸Ðµ ÑÑ‚Ð°Ð²ÐºÐ¸\n"
            base += f"â€¢ ÐŸÑ€Ð¾Ñ‚Ð¸Ð² {num_opponents} Ð¾Ð¿Ð¿Ð¾Ð½ÐµÐ½Ñ‚Ð¾Ð²: ÐºÑ‚Ð¾-Ñ‚Ð¾ Ð¼Ð¾Ð¶ÐµÑ‚ ÑÑ„Ð¾Ð»Ð´Ð¸Ñ‚ÑŒ Ð»ÑƒÑ‡ÑˆÑƒÑŽ Ñ€ÑƒÐºÑƒ\n\n"
            
            if stage == GameStage.FLOP:
                cards_remaining = 2
                base += f"ðŸ“Š **ÐÐ° Ñ„Ð»Ð¾Ð¿Ðµ**: ~{min(total_outs * 4, 100):.0f}% ÑƒÐ»ÑƒÑ‡ÑˆÐ¸Ñ‚ÑŒÑÑ Ð´Ð¾ Ñ€Ð¸Ð²ÐµÑ€Ð°\n"
            else:
                cards_remaining = 1
                base += f"ðŸ“Š **ÐÐ° Ñ‚ÐµÑ€Ð½Ðµ**: ~{min(total_outs * 2, 100):.0f}% ÑƒÐ»ÑƒÑ‡ÑˆÐ¸Ñ‚ÑŒÑÑ Ð½Ð° Ñ€Ð¸Ð²ÐµÑ€Ðµ\n"
        
        elif total_outs >= 9:
            base += "âœ… **Ð¥ÐžÐ ÐžÐ¨Ð•Ð• Ð”Ð Ðž** (9-11 Ð°ÑƒÑ‚Ð¾Ð²)\n"
            base += "**Ð”ÐµÐ¹ÑÑ‚Ð²Ð¸Ñ:**\n"
            base += "â€¢ ÐšÐ¾Ð»Ð»Ð¸Ñ€ÑƒÐ¹Ñ‚Ðµ Ð¼Ð°Ð»Ñ‹Ðµ/ÑÑ€ÐµÐ´Ð½Ð¸Ðµ ÑÑ‚Ð°Ð²ÐºÐ¸\n"
            base += "â€¢ Semi-bluff bet Ð² Ð¿Ð¾Ð·Ð¸Ñ†Ð¸Ð¸\n"
            base += "â€¢ ÐŸÑ€Ð¾Ð²ÐµÑ€ÑŒÑ‚Ðµ pot odds Ð¿ÐµÑ€ÐµÐ´ ÐºÐ¾Ð»Ð»Ð¾Ð¼:\n"
            
            if stage == GameStage.FLOP:
                base += f"  - ~{min(total_outs * 4, 100):.0f}% ÑƒÐ»ÑƒÑ‡ÑˆÐ¸Ñ‚ÑŒÑÑ Ð´Ð¾ Ñ€Ð¸Ð²ÐµÑ€Ð°\n"
                base += "  - ÐÑƒÐ¶Ð½Ñ‹ pot odds ~2.5:1 Ð´Ð»Ñ Ð¿Ñ€Ð¸Ð±Ñ‹Ð»ÑŒÐ½Ð¾Ð³Ð¾ ÐºÐ¾Ð»Ð»Ð°\n"
            else:
                base += f"  - ~{min(total_outs * 2, 100):.0f}% ÑƒÐ»ÑƒÑ‡ÑˆÐ¸Ñ‚ÑŒÑÑ Ð½Ð° Ñ€Ð¸Ð²ÐµÑ€Ðµ\n"
                base += "  - ÐÑƒÐ¶Ð½Ñ‹ pot odds ~4:1 Ð´Ð»Ñ Ð¿Ñ€Ð¸Ð±Ñ‹Ð»ÑŒÐ½Ð¾Ð³Ð¾ ÐºÐ¾Ð»Ð»Ð°\n"
            
            base += "\n" + self._add_opponent_behavior_advice(**{
                "Ð°Ð³Ñ€ÐµÑÑÐ¸Ð²ÐµÐ½": "ÐœÐ¾Ð¶ÐµÑ‚Ðµ semi-bluff Ñ€ÐµÐ¹Ð· ÐµÑÐ»Ð¸ fold equity Ð²Ñ‹ÑÐ¾ÐºÐ°Ñ",
                "Ð¿Ð°ÑÑÐ¸Ð²ÐµÐ½": "ÐœÐ¾Ð¶ÐµÑ‚Ðµ ÐºÑ€Ð°ÑÑ‚ÑŒ Ð±Ð°Ð½Ðº ÑÑ‚Ð°Ð²ÐºÐ¾Ð¹ Ð½Ð° Ñ‚ÐµÑ€Ð½Ðµ",
                "Ñ‚Ð°Ð¹Ñ‚Ð¾Ð²": "ÐšÐ¾Ð»Ð»Ð¸Ñ€ÑƒÐ¹Ñ‚Ðµ Ð¸ ÑƒÐ»ÑƒÑ‡ÑˆÐ°Ð¹Ñ‚ÐµÑÑŒ - Ð¾Ð½Ð¸ Ð¿Ð»Ð°Ñ‚ÑÑ‚ Ñ Ð³Ð¾Ñ‚Ð¾Ð²Ñ‹Ð¼Ð¸ Ñ€ÑƒÐºÐ°Ð¼Ð¸"
            })
        
        elif total_outs >= 6:
            base += "âš ï¸ **Ð¡Ð Ð•Ð”ÐÐ•Ð• Ð”Ð Ðž** (6-8 Ð°ÑƒÑ‚Ð¾Ð²)\n"
            base += "**Ð”ÐµÐ¹ÑÑ‚Ð²Ð¸Ñ:**\n"
            base += "â€¢ ÐšÐ¾Ð»Ð»Ð¸Ñ€ÑƒÐ¹Ñ‚Ðµ Ð¢ÐžÐ›Ð¬ÐšÐž Ð¼Ð°Ð»Ñ‹Ðµ ÑÑ‚Ð°Ð²ÐºÐ¸\n"
            base += "â€¢ ÐŸÑ€Ð¾Ð²ÐµÑ€ÑÐ¹Ñ‚Ðµ pot odds Ð¾Ð±ÑÐ·Ð°Ñ‚ÐµÐ»ÑŒÐ½Ð¾\n"
            base += "â€¢ Fold Ðº ÑÑ€ÐµÐ´Ð½Ð¸Ð¼/ÐºÑ€ÑƒÐ¿Ð½Ñ‹Ð¼ ÑÑ‚Ð°Ð²ÐºÐ°Ð¼\n"
            
            if stage == GameStage.FLOP:
                base += f"â€¢ ~{min(total_outs * 4, 100):.0f}% ÑˆÐ°Ð½Ñ ÑƒÐ»ÑƒÑ‡ÑˆÐ¸Ñ‚ÑŒÑÑ Ð´Ð¾ Ñ€Ð¸Ð²ÐµÑ€Ð°\n"
            else:
                base += f"â€¢ ~{min(total_outs * 2, 100):.0f}% ÑˆÐ°Ð½Ñ Ð½Ð° Ñ€Ð¸Ð²ÐµÑ€Ðµ\n"
                base += "â€¢ ÐÐ° Ñ‚ÐµÑ€Ð½Ðµ Ñ 6-8 Ð°ÑƒÑ‚Ð°Ð¼Ð¸ - Ð½ÑƒÐ¶Ð½Ñ‹ pot odds Ð¼Ð¸Ð½Ð¸Ð¼ÑƒÐ¼ 5:1\n"
            
            base += "\nðŸ“Œ **Ð’Ð°Ð¶Ð½Ð¾**: ÐÐµ Ð¿ÐµÑ€ÐµÐ¾Ñ†ÐµÐ½Ð¸Ð²Ð°Ð¹Ñ‚Ðµ ÑÐ»Ð°Ð±Ñ‹Ðµ Ð´Ñ€Ð¾!\n"
        
        elif total_outs >= 4:
            base += "ðŸ¤ **Ð¡Ð›ÐÐ‘ÐžÐ• Ð”Ð Ðž** (4-5 Ð°ÑƒÑ‚Ð¾Ð²)\n"
            base += "**Ð”ÐµÐ¹ÑÑ‚Ð²Ð¸Ñ:**\n"
            base += "â€¢ ÐšÐ¾Ð»Ð»Ð¸Ñ€ÑƒÐ¹Ñ‚Ðµ Ñ‚Ð¾Ð»ÑŒÐºÐ¾ Ð¼Ð¸Ð½Ð¸Ð¼Ð°Ð»ÑŒÐ½Ñ‹Ðµ ÑÑ‚Ð°Ð²ÐºÐ¸\n"
            base += "â€¢ Fold Ðº Ð»ÑŽÐ±Ð¾Ð¹ ÑÑƒÑ‰ÐµÑÑ‚Ð²ÐµÐ½Ð½Ð¾Ð¹ Ð°Ð³Ñ€ÐµÑÑÐ¸Ð¸\n"
            base += "â€¢ Ð Ð°ÑÑÐ¼Ð¾Ñ‚Ñ€Ð¸Ñ‚Ðµ fold Ð´Ð°Ð¶Ðµ Ðº Ð¼Ð°Ð»Ñ‹Ð¼ ÑÑ‚Ð°Ð²ÐºÐ°Ð¼ Ð±ÐµÐ· implied odds\n"
            
            if stage == GameStage.FLOP:
                base += f"â€¢ Ð¢Ð¾Ð»ÑŒÐºÐ¾ ~{min(total_outs * 4, 100):.0f}% ÑƒÐ»ÑƒÑ‡ÑˆÐ¸Ñ‚ÑŒÑÑ Ð´Ð¾ Ñ€Ð¸Ð²ÐµÑ€Ð°\n"
            else:
                base += f"â€¢ Ð¢Ð¾Ð»ÑŒÐºÐ¾ ~{min(total_outs * 2, 100):.0f}% Ð¿Ð¾Ð¿Ð°ÑÑ‚ÑŒ Ð½Ð° Ñ€Ð¸Ð²ÐµÑ€Ðµ\n"
                base += "â€¢ **ÐÐ° Ñ‚ÐµÑ€Ð½Ðµ ÑÐ¾ ÑÐ»Ð°Ð±Ñ‹Ð¼ Ð´Ñ€Ð¾ - Ñ‡Ð°Ñ‰Ðµ Ð²ÑÐµÐ³Ð¾ fold**\n"
        
        elif total_outs >= 1:
            base += "ðŸ˜” **ÐžÐ§Ð•ÐÐ¬ Ð¡Ð›ÐÐ‘ÐžÐ• Ð”Ð Ðž** (1-3 Ð°ÑƒÑ‚Ð°)\n"
            base += "**Ð”ÐµÐ¹ÑÑ‚Ð²Ð¸Ñ:**\n"
            base += "â€¢ Fold Ðº Ð»ÑŽÐ±Ñ‹Ð¼ ÑÑ‚Ð°Ð²ÐºÐ°Ð¼\n"
            base += "â€¢ Ð‘ÐµÑÐ¿Ð»Ð°Ñ‚Ð½Ð°Ñ ÐºÐ°Ñ€Ñ‚Ð° - ÐµÐ´Ð¸Ð½ÑÑ‚Ð²ÐµÐ½Ð½Ñ‹Ð¹ Ð²Ð°Ñ€Ð¸Ð°Ð½Ñ‚\n"
            base += "â€¢ ÐÐµ Ð¸Ð½Ð²ÐµÑÑ‚Ð¸Ñ€ÑƒÐ¹Ñ‚Ðµ Ð² Ñ‚Ð°ÐºÐ¸Ðµ Ð´Ñ€Ð¾\n"
        
        else:
            base += "âŒ **ÐÐ•Ð¢ ÐÐ£Ð¢ÐžÐ’ / Ð’ÐžÐ—Ð”Ð£Ð¥**\n"
            base += "**Ð”ÐµÐ¹ÑÑ‚Ð²Ð¸Ñ:**\n"
            base += "â€¢ Fold Ðº Ð»ÑŽÐ±Ð¾Ð¹ ÑÑ‚Ð°Ð²ÐºÐµ\n"
            base += "â€¢ Ð§Ð¸ÑÑ‚Ñ‹Ð¹ Ð±Ð»ÐµÑ„ - Ñ‚Ð¾Ð»ÑŒÐºÐ¾ Ð² ÑÐ¿ÐµÑ†Ð¸Ñ„Ð¸Ñ‡ÐµÑÐºÐ¸Ñ… ÑÐ¸Ñ‚ÑƒÐ°Ñ†Ð¸ÑÑ…\n"
            base += "â€¢ ÐÐµ Ð¿Ñ€Ð¾Ð´Ð¾Ð»Ð¶Ð°Ð¹Ñ‚Ðµ Ð±ÐµÐ· fold equity\n\n"
            
            base += self._add_positional_advice(
                "Ð’ Ð¿Ð¾Ð·Ð¸Ñ†Ð¸Ð¸ Ð¼Ð¾Ð¶ÐµÑ‚Ðµ Ð¿Ð¾Ð¿Ñ€Ð¾Ð±Ð¾Ð²Ð°Ñ‚ÑŒ steal ÑÑ‚Ð°Ð²ÐºÑƒ Ð½Ð° ÑÑ‚Ñ€Ð°ÑˆÐ½Ð¾Ð¹ ÐºÐ°Ñ€Ñ‚Ðµ",
                "Ð‘ÐµÐ· Ð¿Ð¾Ð·Ð¸Ñ†Ð¸Ð¸ - Ñ‡ÐµÐº-fold, Ð±Ð»ÐµÑ„ Ð½Ðµ Ñ€Ð°Ð±Ð¾Ñ‚Ð°ÐµÑ‚"
            )
            
            base += "\n" + self._add_opponent_behavior_advice(**{
                "Ð°Ð³Ñ€ÐµÑÑÐ¸Ð²ÐµÐ½": "Fold Ð½ÐµÐ¼ÐµÐ´Ð»ÐµÐ½Ð½Ð¾",
                "Ð¿Ð°ÑÑÐ¸Ð²ÐµÐ½": "ÐœÐ¾Ð¶ÐµÑ‚Ðµ Ð¿Ð¾Ð¿Ñ‹Ñ‚Ð°Ñ‚ÑŒÑÑ ÑƒÐºÑ€Ð°ÑÑ‚ÑŒ Ð½Ð° Ñ‚ÐµÑ€Ð½Ðµ/Ñ€Ð¸Ð²ÐµÑ€Ðµ",
                "Ð¿Ð¾ÐºÐ°Ð·Ð°Ð» ÑÐ»Ð°Ð±Ð¾ÑÑ‚ÑŒ": "Ð‘Ð»ÐµÑ„ ÑÑ‚Ð°Ð²ÐºÐ° Ð¼Ð¾Ð¶ÐµÑ‚ ÑÑ€Ð°Ð±Ð¾Ñ‚Ð°Ñ‚ÑŒ"
            })
            
            return base
        
        # ÐÐ½Ð°Ð»Ð¸Ð· Ð²Ð¸Ð½Ñ€ÐµÐ¹Ñ‚Ð° Ð´Ð»Ñ Ð´Ñ€Ð¾
        if win_rate >= 45:
            base += f"\nâœ… **Ð’Ð¸Ð½Ñ€ÐµÐ¹Ñ‚ {win_rate:.1f}%** - Ð´Ñ€Ð¾ Ð¸Ð¼ÐµÐµÑ‚ Ñ…Ð¾Ñ€Ð¾ÑˆÐ¸Ðµ ÑˆÐ°Ð½ÑÑ‹!\n"
        elif win_rate >= 30:
            base += f"\nâš ï¸ **Ð’Ð¸Ð½Ñ€ÐµÐ¹Ñ‚ {win_rate:.1f}%** - Ð´Ñ€Ð¾ Ð¼Ð°Ñ€Ð³Ð¸Ð½Ð°Ð»ÑŒÐ½Ð¾Ðµ\n"
        else:
            base += f"\nâŒ **Ð’Ð¸Ð½Ñ€ÐµÐ¹Ñ‚ {win_rate:.1f}%** - Ð´Ñ€Ð¾ ÑÐ»Ð°Ð±Ð¾Ðµ, Ð½ÑƒÐ¶Ð½Ñ‹ Ð¾Ñ‚Ð»Ð¸Ñ‡Ð½Ñ‹Ðµ pot odds\n"
        
        # Multiway considerations
        if num_opponents >= 3:
            base += f"\nâš ï¸ **{num_opponents} Ð¾Ð¿Ð¿Ð¾Ð½ÐµÐ½Ñ‚Ð¾Ð²** (multiway):\n"
            base += "â€¢ Implied odds Ð»ÑƒÑ‡ÑˆÐµ (Ð±Ð¾Ð»ÑŒÑˆÐµ Ð´ÐµÐ½ÐµÐ³ Ð² Ð±Ð°Ð½ÐºÐµ Ð¿Ñ€Ð¸ Ð¿Ð¾Ð¿Ð°Ð´Ð°Ð½Ð¸Ð¸)\n"
            base += "â€¢ Fold equity Ñ…ÑƒÐ¶Ðµ (ÑÐ»Ð¾Ð¶Ð½ÐµÐµ Ð²Ñ‹Ð±Ð¸Ñ‚ÑŒ Ð²ÑÐµÑ… Ð±Ð»ÐµÑ„Ð¾Ð¼)\n"
            base += "â€¢ Ð˜Ð³Ñ€Ð°Ð¹Ñ‚Ðµ ÐºÐ¾Ð½ÑÐµÑ€Ð²Ð°Ñ‚Ð¸Ð²Ð½ÐµÐµ - ÐºÑ‚Ð¾-Ñ‚Ð¾ ÑƒÐ¶Ðµ Ð¸Ð¼ÐµÐµÑ‚ Ð³Ð¾Ñ‚Ð¾Ð²ÑƒÑŽ Ñ€ÑƒÐºÑƒ\n"
        
        # Ð¡Ñ‚Ð°Ð´Ð¸Ñ Ð¸Ð³Ñ€Ñ‹
        if stage == GameStage.TURN:
            base += "\nâš ï¸ **Ð’ÐÐ˜ÐœÐÐÐ˜Ð• - Ð’Ð« ÐÐ Ð¢Ð•Ð ÐÐ•**:\n"
            base += "â€¢ Ð¢Ð¾Ð»ÑŒÐºÐ¾ 1 ÐºÐ°Ñ€Ñ‚Ð° Ð¾ÑÑ‚Ð°Ð»Ð°ÑÑŒ (Ñ€Ð¸Ð²ÐµÑ€)\n"
            base += "â€¢ Implied odds ÑƒÑ…ÑƒÐ´ÑˆÐ¸Ð»Ð¸ÑÑŒ\n"
            base += "â€¢ Ð‘ÑƒÐ´ÑŒÑ‚Ðµ ÑÑ‚Ñ€Ð¾Ð¶Ðµ Ðº pot odds\n"
        
        base += "\n" + self._add_positional_advice(
            "Ð’ Ð¿Ð¾Ð·Ð¸Ñ†Ð¸Ð¸ Ñ Ð´Ñ€Ð¾:\n  â€¢ ÐœÐ¾Ð¶ÐµÑ‚Ðµ ÐºÐ¾Ð½Ñ‚Ñ€Ð¾Ð»Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ Ñ€Ð°Ð·Ð¼ÐµÑ€ Ð±Ð°Ð½ÐºÐ°\n  â€¢ Ð§ÐµÐº-Ð±ÑÐº Ð½Ð° Ñ‚ÐµÑ€Ð½Ðµ Ð´Ð»Ñ Ð±ÐµÑÐ¿Ð»Ð°Ñ‚Ð½Ð¾Ð¹ ÐºÐ°Ñ€Ñ‚Ñ‹\n  â€¢ Ð‘Ð»ÐµÑ„ Ð½Ð° Ñ€Ð¸Ð²ÐµÑ€Ðµ ÐµÑÐ»Ð¸ Ð´Ñ€Ð¾ Ð¿Ñ€Ð¾Ð¼Ð°Ñ…Ð½ÑƒÐ»Ð¾ÑÑŒ Ð½Ð¾ Ð¿Ñ€Ð¸ÑˆÐ»Ð° ÑÑ‚Ñ€Ð°ÑˆÐ½Ð°Ñ ÐºÐ°Ñ€Ñ‚Ð°",
            "Ð‘ÐµÐ· Ð¿Ð¾Ð·Ð¸Ñ†Ð¸Ð¸ Ñ Ð´Ñ€Ð¾:\n  â€¢ Ð§ÐµÐº-ÐºÐ¾Ð»Ð» Ð»Ð¸Ð½Ð¸Ñ Ð¾Ð±Ñ‹Ñ‡Ð½Ð¾ Ð¾Ð¿Ñ‚Ð¸Ð¼Ð°Ð»ÑŒÐ½Ð°\n  â€¢ Ð”Ð¾Ð½Ðº-Ð±ÐµÑ‚ Ñ‚Ð¾Ð»ÑŒÐºÐ¾ Ñ Ð¾Ñ‡ÐµÐ½ÑŒ ÑÐ¸Ð»ÑŒÐ½Ñ‹Ð¼ Ð´Ñ€Ð¾ (12+ Ð°ÑƒÑ‚Ð¾Ð²)\n  â€¢ Ð“Ð¾Ñ‚Ð¾Ð²ÑŒÑ‚ÐµÑÑŒ Ñ„Ð¾Ð»Ð´Ð¸Ñ‚ÑŒ Ð½Ð° Ñ‚ÐµÑ€Ð½Ðµ/Ñ€Ð¸Ð²ÐµÑ€Ðµ Ðº Ð°Ð³Ñ€ÐµÑÑÐ¸Ð¸"
        )
        
        return base
    
    # ===================== HELPER METHODS =====================
    
    def _add_positional_advice(self, in_position: str, out_of_position: str) -> str:
        """Ð”Ð¾Ð±Ð°Ð²Ð»ÑÐµÑ‚ Ð¿Ð¾Ð·Ð¸Ñ†Ð¸Ð¾Ð½Ð½Ñ‹Ðµ ÑÐ¾Ð²ÐµÑ‚Ñ‹"""
        return (
            "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n"
            "â”‚ ðŸ“ ÐŸÐžÐ—Ð˜Ð¦Ð˜ÐžÐÐÐ«Ð• Ð¡ÐžÐ’Ð•Ð¢Ð« (Ð´Ð»Ñ Ð²Ð°Ñ):   â”‚\n"
            "â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n"
            f"ðŸŸ¢ **Ð•ÑÐ»Ð¸ Ð²Ñ‹ Ð’ ÐŸÐžÐ—Ð˜Ð¦Ð˜Ð˜** (BTN/CO):\n   {in_position}\n\n"
            f"ðŸ”´ **Ð•ÑÐ»Ð¸ Ð²Ñ‹ Ð‘Ð•Ð— ÐŸÐžÐ—Ð˜Ð¦Ð˜Ð˜** (UTG/MP/SB/BB):\n   {out_of_position}\n"
        )
    
    def _add_opponent_behavior_advice(self, **behaviors) -> str:
        """Ð”Ð¾Ð±Ð°Ð²Ð»ÑÐµÑ‚ ÑÐ¾Ð²ÐµÑ‚Ñ‹ Ð¿Ð¾ Ð¿Ð¾Ð²ÐµÐ´ÐµÐ½Ð¸ÑŽ Ð¾Ð¿Ð¿Ð¾Ð½ÐµÐ½Ñ‚Ð°"""
        advice = (
            "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n"
            "â”‚ ðŸŽ­ Ð¡ÐžÐ’Ð•Ð¢Ð« ÐŸÐž ÐžÐŸÐŸÐžÐÐ•ÐÐ¢Ð£ (Ð´Ð»Ñ Ð²Ð°Ñ):  â”‚\n"
            "â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n"
        )
        
        for behavior_type, recommendation in behaviors.items():
            emoji = {
                'Ð°Ð³Ñ€ÐµÑÑÐ¸Ð²ÐµÐ½': 'ðŸ”¥',
                'Ð¿Ð°ÑÑÐ¸Ð²ÐµÐ½': 'ðŸ˜´',
                'Ñ‚Ð°Ð¹Ñ‚Ð¾Ð²': 'ðŸ›¡ï¸',
                'Ð½Ð° Ñ‚Ð¸Ð»ÑŒÑ‚Ðµ': 'ðŸ˜¤',
                'Ð¿Ð¾ÐºÐ°Ð·Ð°Ð» ÑÐ»Ð°Ð±Ð¾ÑÑ‚ÑŒ': 'ðŸ˜°'
            }.get(behavior_type, 'ðŸ‘¤')
            
            advice += f"{emoji} **Ð•ÑÐ»Ð¸ Ð¾Ð¿Ð¿Ð¾Ð½ÐµÐ½Ñ‚ {behavior_type}**:\n   {recommendation}\n\n"
        
        return advice.rstrip()


# ===================== INTEGRATION FUNCTION =====================

def generate_improved_recommendation(analysis_result: Dict) -> str:
    """
    Ð“Ð»Ð°Ð²Ð½Ð°Ñ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ñ Ð´Ð»Ñ Ð¸Ð½Ñ‚ÐµÐ³Ñ€Ð°Ñ†Ð¸Ð¸ Ð² analysis_service.py
    
    Usage:
        from improved_abc_recommendations import generate_improved_recommendation
        
        recommendation = generate_improved_recommendation(analysis_result)
    """
    engine = ImprovedRecommendationEngine()
    
    # Extract data from analysis result
    current_hand = analysis_result.get('current_hand', 'high card')
    equity_data = analysis_result.get('equity', {})
    win_rate = equity_data.get('win_rate', 0)
    
    outs_data = analysis_result.get('outs_analysis', {})
    total_outs = analysis_result.get('total_outs', 0)
    
    texture_analysis = analysis_result.get('board_texture', {})
    
    # Get game state data (you'll need to pass this)
    # These should come from the GameState object
    num_opponents = analysis_result.get('num_opponents', 1)
    stage = analysis_result.get('stage', GameStage.FLOP)
    board_cards = analysis_result.get('board_cards_list', [])
    
    return engine.generate_recommendation(
        current_hand=current_hand,
        win_rate=win_rate,
        total_outs=total_outs,
        outs_breakdown=outs_data,
        texture_analysis=texture_analysis,
        num_opponents=num_opponents,
        stage=stage,
        board_cards=board_cards
    )




==========================
dock_widgets.py
==========================




"""Dockable widgets for adaptive UI - Fixed floating resize issue"""
import logging
from typing import Optional, List
from PySide6.QtWidgets import (QDockWidget, QWidget, QVBoxLayout, QHBoxLayout,
                               QLabel, QGroupBox, QRadioButton, QButtonGroup,
                               QScrollArea, QPushButton, QSizePolicy)
from PySide6.QtCore import Qt, Signal, QTimer, QRect
from PySide6.QtGui import QResizeEvent, QMoveEvent

from core.domain import TableSize, GameType
from ui.widgets import CardInputWidget

logger = logging.getLogger(__name__)


class BaseDockWidget(QDockWidget):
    """Base class for all dock widgets with common functionality"""
    
    def __init__(self, title: str, object_name: str, parent=None):
        super().__init__(title, parent)
        self.setObjectName(object_name)
        
        # Enable docking features
        self.setFeatures(
            QDockWidget.DockWidgetFeature.DockWidgetMovable |
            QDockWidget.DockWidgetFeature.DockWidgetFloatable |
            QDockWidget.DockWidgetFeature.DockWidgetClosable
        )
        
        # Set size policies for responsive behavior
        self.setSizePolicy(QSizePolicy.Policy.Preferred, QSizePolicy.Policy.Preferred)
        
        # Store floating geometry to prevent unwanted resizing
        self._floating_geometry: Optional[QRect] = None
        self._is_user_resizing = False
        self._restore_timer = QTimer(self)
        self._restore_timer.setSingleShot(True)
        self._restore_timer.timeout.connect(self._restore_floating_geometry)
        
        # Container widget
        self.container = QWidget()
        self.setWidget(self.container)
        
        # Connect to topLevelChanged signal to handle float/dock transitions
        self.topLevelChanged.connect(self._on_float_changed)
        
        logger.debug(f"Initialized dock: {object_name}")
    
    def _on_float_changed(self, floating: bool):
        """Handle dock/float state change"""
        if floating:
            # When becoming floating, store current geometry
            QTimer.singleShot(100, self._capture_initial_floating_geometry)
            logger.debug(f"{self.objectName()}: Became floating")
        else:
            # Clear stored geometry when docking
            self._floating_geometry = None
            logger.debug(f"{self.objectName()}: Docked")
    
    def _capture_initial_floating_geometry(self):
        """Capture geometry after floating transition completes"""
        if self.isFloating():
            self._floating_geometry = self.geometry()
            logger.debug(f"{self.objectName()}: Captured floating geometry: {self._floating_geometry}")
    
    def resizeEvent(self, event: QResizeEvent):
        """Override resizeEvent to prevent unwanted resizing of floating widgets"""
        if self.isFloating():
            # Check if this is a user-initiated resize
            if event.spontaneous():
                # User is resizing - allow and store new size
                self._is_user_resizing = True
                super().resizeEvent(event)
                self._floating_geometry = self.geometry()
                logger.debug(f"{self.objectName()}: User resized to {self._floating_geometry}")
            else:
                # System-initiated resize (e.g., parent window moved)
                if self._floating_geometry is not None:
                    # Ignore this resize and restore our saved geometry
                    event.ignore()
                    # Schedule geometry restoration after event processing
                    self._restore_timer.start(10)
                    return
                else:
                    # No saved geometry yet, allow this resize
                    super().resizeEvent(event)
        else:
            # Not floating - normal behavior
            super().resizeEvent(event)
    
    def moveEvent(self, event: QMoveEvent):
        """Override moveEvent to track user movements"""
        super().moveEvent(event)
        if self.isFloating():
            # User moved the window - update stored geometry
            if event.spontaneous():
                self._floating_geometry = self.geometry()
                logger.debug(f"{self.objectName()}: User moved to {self._floating_geometry}")
    
    def _restore_floating_geometry(self):
        """Restore the saved floating geometry"""
        if self.isFloating() and self._floating_geometry is not None:
            current_geom = self.geometry()
            # Only restore if geometry actually changed
            if (current_geom.width() != self._floating_geometry.width() or
                current_geom.height() != self._floating_geometry.height()):
                logger.debug(f"{self.objectName()}: Restoring geometry from {current_geom} to {self._floating_geometry}")
                self.setGeometry(self._floating_geometry)
    
    def set_saved_geometry(self, geometry: QRect):
        """Set saved geometry (used when loading from config)"""
        self._floating_geometry = geometry
        if self.isFloating():
            self.setGeometry(geometry)
            logger.debug(f"{self.objectName()}: Applied saved geometry: {geometry}")


class TableConfigDock(BaseDockWidget):
    """Dock widget for table configuration"""
    
    # Signals
    table_size_changed = Signal(TableSize)
    game_type_changed = Signal(GameType)
    
    def __init__(self, parent=None):
        super().__init__("âš™ï¸ Table Configuration", "table_config_dock", parent)
        
        self.table_size_group = QButtonGroup(self)
        self.game_type_group = QButtonGroup(self)
        
        self._setup_ui()
    
    def _setup_ui(self):
        """Setup UI components"""
        layout = QVBoxLayout(self.container)
        layout.setSpacing(8)
        layout.setContentsMargins(8, 8, 8, 8)
        
        # Table size section
        size_group = QGroupBox("Table Size")
        size_layout = QVBoxLayout(size_group)
        size_layout.setSpacing(4)
        
        table_sizes = [
            ("2 Ð¸Ð³Ñ€Ð¾ÐºÐ°", TableSize.HEADS_UP),
            ("3 Ð¸Ð³Ñ€Ð¾ÐºÐ°", TableSize.THREE_MAX),
            ("4 Ð¸Ð³Ñ€Ð¾ÐºÐ°", TableSize.FOUR_MAX),
            ("5 Ð¸Ð³Ñ€Ð¾ÐºÐ¾Ð²", TableSize.FIVE_MAX),
            ("6 Ð¸Ð³Ñ€Ð¾ÐºÐ¾Ð²", TableSize.SIX_MAX),
            ("7 Ð¸Ð³Ñ€Ð¾ÐºÐ¾Ð²", TableSize.SEVEN_MAX),
            ("8 Ð¸Ð³Ñ€Ð¾ÐºÐ¾Ð²", TableSize.EIGHT_MAX),
            ("9 Ð¸Ð³Ñ€Ð¾ÐºÐ¾Ð²", TableSize.NINE_MAX)
        ]
        
        for label, size in table_sizes:
            btn = QRadioButton(label)
            btn.setProperty("table_size", size)
            btn.setStyleSheet("font-size: 11px; padding: 3px;")
            
            if size == TableSize.SIX_MAX:
                btn.setChecked(True)
            
            self.table_size_group.addButton(btn)
            size_layout.addWidget(btn)
        
        layout.addWidget(size_group)
        
        # Connect signals
        self.table_size_group.buttonClicked.connect(self._on_table_size_clicked)
        
    def _on_table_size_clicked(self):
        """Handle table size button click"""
        checked_btn = self.table_size_group.checkedButton()
        if checked_btn:
            table_size = checked_btn.property("table_size")
            self.table_size_changed.emit(table_size)
    
    def get_table_size(self) -> TableSize:
        """Get currently selected table size"""
        checked_btn = self.table_size_group.checkedButton()
        if checked_btn:
            return checked_btn.property("table_size")
        return TableSize.SIX_MAX


class CardsDock(BaseDockWidget):
    """Dock widget for player and board cards"""
    
    # Signals
    cards_changed = Signal(str)
    
    def __init__(self, parent=None):
        super().__init__("ðŸƒ Cards", "cards_dock", parent)
        
        # Card input widgets
        self.card1_widget: Optional[CardInputWidget] = None
        self.card2_widget: Optional[CardInputWidget] = None
        self.flop1_widget: Optional[CardInputWidget] = None
        self.flop2_widget: Optional[CardInputWidget] = None
        self.flop3_widget: Optional[CardInputWidget] = None
        self.turn_widget: Optional[CardInputWidget] = None
        self.river_widget: Optional[CardInputWidget] = None
        
        self._setup_ui()
    
    def _setup_ui(self):
        """Setup UI components"""
        layout = QVBoxLayout(self.container)
        layout.setSpacing(10)
        layout.setContentsMargins(8, 8, 8, 8)
        
        # Player cards section
        player_group = QGroupBox("Player Cards")
        player_layout = QVBoxLayout(player_group)
        player_layout.setSpacing(6)
        
        self.card1_widget = CardInputWidget("Card 1:")
        self.card2_widget = CardInputWidget("Card 2:")
        
        for widget in [self.card1_widget, self.card2_widget]:
            self._configure_card_widget(widget)
            player_layout.addWidget(widget)
        
        layout.addWidget(player_group)
        
        # Board cards section
        board_group = QGroupBox("Board Cards")
        board_layout = QVBoxLayout(board_group)
        board_layout.setSpacing(6)
        
        self.flop1_widget = CardInputWidget("Flop 1:")
        self.flop2_widget = CardInputWidget("Flop 2:")
        self.flop3_widget = CardInputWidget("Flop 3:")
        self.turn_widget = CardInputWidget("Turn:")
        self.river_widget = CardInputWidget("River:")
        
        for widget in [self.flop1_widget, self.flop2_widget, self.flop3_widget,
                      self.turn_widget, self.river_widget]:
            self._configure_card_widget(widget)
            board_layout.addWidget(widget)
        
        layout.addWidget(board_group)
        
        # Clear button
        clear_btn = QPushButton("ðŸ”„ Clear All Cards")
        clear_btn.clicked.connect(self.clear_all_cards)
        clear_btn.setStyleSheet("padding: 6px; font-weight: bold;")
        layout.addWidget(clear_btn)
        
        layout.addStretch()
        
        # Connect change signals
        for widget in self.get_all_card_widgets():
            widget.line_edit.textChanged.connect(self.cards_changed.emit)
    
    def _configure_card_widget(self, widget: CardInputWidget):
        """Configure card widget for consistent appearance"""
        widget.label.setFixedWidth(70)
        widget.line_edit.setFixedWidth(45)
        for btn in widget.suit_buttons:
            btn.setFixedSize(30, 30)
    
    def get_all_card_widgets(self) -> List[CardInputWidget]:
        """Get all card input widgets"""
        return [
            self.card1_widget, self.card2_widget,
            self.flop1_widget, self.flop2_widget, self.flop3_widget,
            self.turn_widget, self.river_widget
        ]
    
    def clear_all_cards(self):
        """Clear all card inputs"""
        for widget in self.get_all_card_widgets():
            widget.clear()
        logger.info("All cards cleared")


class AnalysisDock(BaseDockWidget):
    """Dock widget for analysis results"""
    
    def __init__(self, parent=None):
        super().__init__("ðŸ§  Analysis", "analysis_dock", parent)
        
        self.scroll_area: Optional[QScrollArea] = None
        self.content_widget: Optional[QWidget] = None
        self.content_layout: Optional[QVBoxLayout] = None
        
        self._setup_ui()
    
    def _setup_ui(self):
        """Setup UI components"""
        layout = QVBoxLayout(self.container)
        layout.setContentsMargins(0, 0, 0, 0)
        
        # Scrollable area for analysis content
        self.scroll_area = QScrollArea()
        self.scroll_area.setWidgetResizable(True)
        self.scroll_area.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        
        self.content_widget = QWidget()
        self.content_layout = QVBoxLayout(self.content_widget)
        self.content_layout.setSpacing(8)
        self.content_layout.setContentsMargins(8, 8, 8, 8)
        
        self.scroll_area.setWidget(self.content_widget)
        layout.addWidget(self.scroll_area)
        
        # Show welcome message by default
        self.show_welcome_message()
    
    def show_welcome_message(self):
        """Display welcome/instructions message"""
        self.clear_content()
        
        welcome = QLabel("ðŸƒ Welcome to MonteLab")
        welcome.setStyleSheet("font-size: 18px; font-weight: bold; color: #4CAF50; padding: 15px;")
        welcome.setAlignment(Qt.AlignmentFlag.AlignCenter)
        
        instructions = QLabel("""
        <b>Instructions:</b><br>
        1. Configure table settings<br>
        2. Enter cards or use ML detection<br>
        3. Click 'Analyze' for insights<br><br>
        
        <b>Features:</b><br>
        â€¢ Hand strength evaluation<br>
        â€¢ Board texture analysis<br>
        â€¢ Outs calculation<br>
        â€¢ Strategy recommendations
        """)
        instructions.setStyleSheet("color: #ccc; padding: 15px; line-height: 1.6;")
        instructions.setWordWrap(True)
        
        self.content_layout.addWidget(welcome)
        self.content_layout.addWidget(instructions)
        self.content_layout.addStretch()
    
    def clear_content(self):
        """Clear all content from analysis area"""
        while self.content_layout.count():
            child = self.content_layout.takeAt(0)
            if child.widget():
                child.widget().deleteLater()
    
    def add_widget(self, widget: QWidget):
        """Add widget to analysis content"""
        self.content_layout.addWidget(widget)
    
    def add_stretch(self):
        """Add stretch to push content up"""
        self.content_layout.addStretch()


class ImagePreviewDock(BaseDockWidget):
    """Dock widget for captured image preview"""
    
    def __init__(self, parent=None):
        super().__init__("ðŸ“¸ Image Preview", "image_preview_dock", parent)
        
        self.image_label: Optional[QLabel] = None
        self._setup_ui()
    
    def _setup_ui(self):
        """Setup UI components"""
        layout = QVBoxLayout(self.container)
        layout.setContentsMargins(8, 8, 8, 8)
        
        self.image_label = QLabel("Select area and capture\nto see detected cards")
        self.image_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.image_label.setMinimumSize(250, 200)
        self.image_label.setStyleSheet("""
            background: #111; 
            color: #ccc; 
            border: 2px solid #444; 
            border-radius: 4px; 
            font-size: 13px; 
            padding: 15px;
        """)
        self.image_label.setScaledContents(False)
        
        layout.addWidget(self.image_label, 1)
    
    def set_placeholder_text(self, text: str):
        """Set placeholder text"""
        self.image_label.setText(text)
        self.image_label.setPixmap(None)
    
    def set_pixmap(self, pixmap):
        """Set image pixmap"""
        if pixmap:
            scaled_pixmap = pixmap.scaled(
                self.image_label.size(),
                Qt.AspectRatioMode.KeepAspectRatio,
                Qt.TransformationMode.SmoothTransformation
            )
            self.image_label.setPixmap(scaled_pixmap)
        else:
            self.image_label.setPixmap(None)






==========================
hwid_dialog.py
==========================




from PySide6.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QLabel, QPushButton, 
    QTextEdit, QFrame, QApplication, QMessageBox
)
from PySide6.QtCore import Qt, Signal as pyqtSignal, QTimer
from PySide6.QtGui import QFont, QIcon, QPixmap, QClipboard
from utils.hwid_generator import HWIDGenerator
import logging

logger = logging.getLogger(__name__)

class HWIDDialog(QDialog):
    """Ð”Ð¸Ð°Ð»Ð¾Ð³Ð¾Ð²Ð¾Ðµ Ð¾ÐºÐ½Ð¾ Ð´Ð»Ñ Ð¾Ñ‚Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½Ð¸Ñ HWID Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ"""
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("ÐÐºÑ‚Ð¸Ð²Ð°Ñ†Ð¸Ñ Ð»Ð¸Ñ†ÐµÐ½Ð·Ð¸Ð¸ - PoRTA 2")
        self.setFixedSize(500, 300)
        self.setWindowFlags(Qt.WindowType.Dialog | Qt.WindowType.WindowCloseButtonHint)
        self.setModal(True)
        
        # Ð“ÐµÐ½ÐµÑ€Ð¸Ñ€ÑƒÐµÐ¼ HWID
        try:
            self.hwid = HWIDGenerator.generate_hwid()
            logger.info(f"Generated HWID: {self.hwid}")
        except Exception as e:
            logger.error(f"Error generating HWID: {e}")
            self.hwid = "ERROR-GENERATING-HWID"
        
        self.setup_ui()
        self.setup_styles()
    
    def setup_ui(self):
        """ÐÐ°ÑÑ‚Ñ€Ð¾Ð¹ÐºÐ° Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÑŒÑÐºÐ¾Ð³Ð¾ Ð¸Ð½Ñ‚ÐµÑ€Ñ„ÐµÐ¹ÑÐ°"""
        layout = QVBoxLayout(self)
        layout.setContentsMargins(20, 20, 20, 20)
        layout.setSpacing(15)
        
        # Ð—Ð°Ð³Ð¾Ð»Ð¾Ð²Ð¾Ðº
        title_label = QLabel("ðŸ” ÐÐºÑ‚Ð¸Ð²Ð°Ñ†Ð¸Ñ Ð»Ð¸Ñ†ÐµÐ½Ð·Ð¸Ð¸")
        title_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        title_font = QFont()
        title_font.setPointSize(16)
        title_font.setBold(True)
        title_label.setFont(title_font)
        layout.addWidget(title_label)
        
        # Ð Ð°Ð·Ð´ÐµÐ»Ð¸Ñ‚ÐµÐ»ÑŒ
        separator = QFrame()
        separator.setFrameShape(QFrame.Shape.HLine)
        separator.setFrameShadow(QFrame.Shadow.Sunken)
        layout.addWidget(separator)
        
        # Ð˜Ð½ÑÑ‚Ñ€ÑƒÐºÑ†Ð¸Ñ
        instruction_label = QLabel(
            "Ð”Ð»Ñ Ð°ÐºÑ‚Ð¸Ð²Ð°Ñ†Ð¸Ð¸ Ð»Ð¸Ñ†ÐµÐ½Ð·Ð¸Ð¸ ÑÐºÐ¾Ð¿Ð¸Ñ€ÑƒÐ¹Ñ‚Ðµ Ð²Ð°Ñˆ ÑƒÐ½Ð¸ÐºÐ°Ð»ÑŒÐ½Ñ‹Ð¹ HWID\n"
            "Ð¸ Ð¾Ñ‚Ð¿Ñ€Ð°Ð²ÑŒÑ‚Ðµ ÐµÐ³Ð¾ Ð°Ð´Ð¼Ð¸Ð½Ð¸ÑÑ‚Ñ€Ð°Ñ‚Ð¾Ñ€Ñƒ:"
        )
        instruction_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        instruction_label.setWordWrap(True)
        layout.addWidget(instruction_label)
        
        # HWID Ð¿Ð¾Ð»Ðµ
        self.hwid_display = QTextEdit()
        self.hwid_display.setPlainText(self.hwid)
        self.hwid_display.setReadOnly(True)
        self.hwid_display.setMaximumHeight(60)
        self.hwid_display.setAlignment(Qt.AlignmentFlag.AlignCenter)
        layout.addWidget(self.hwid_display)
        
        # ÐšÐ½Ð¾Ð¿ÐºÐ¸
        button_layout = QHBoxLayout()
        button_layout.setSpacing(10)
        
        self.copy_button = QPushButton("ðŸ“‹ ÐšÐ¾Ð¿Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ HWID")
        self.copy_button.clicked.connect(self.copy_hwid)
        button_layout.addWidget(self.copy_button)
        
        self.close_button = QPushButton("âŒ Ð—Ð°ÐºÑ€Ñ‹Ñ‚ÑŒ")
        self.close_button.clicked.connect(self.reject)
        button_layout.addWidget(self.close_button)
        
        layout.addLayout(button_layout)
        
        # Ð”Ð¾Ð¿Ð¾Ð»Ð½Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ð°Ñ Ð¸Ð½Ñ„Ð¾Ñ€Ð¼Ð°Ñ†Ð¸Ñ
        info_label = QLabel(
            "ðŸ’¡ ÐŸÐ¾ÑÐ»Ðµ Ð¿Ð¾Ð»ÑƒÑ‡ÐµÐ½Ð¸Ñ Ð»Ð¸Ñ†ÐµÐ½Ð·Ð¸Ð¸ Ð¿ÐµÑ€ÐµÐ·Ð°Ð¿ÑƒÑÑ‚Ð¸Ñ‚Ðµ Ð¿Ñ€Ð¸Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ"
        )
        info_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        info_label.setStyleSheet("color: #666; font-size: 12px;")
        layout.addWidget(info_label)
    
    def setup_styles(self):
        """ÐÐ°ÑÑ‚Ñ€Ð¾Ð¹ÐºÐ° ÑÑ‚Ð¸Ð»ÐµÐ¹"""
        self.setStyleSheet("""
            QDialog {
                background-color: #2b2b2b;
                color: #ffffff;
                border-radius: 10px;
            }
            QLabel {
                color: #ffffff;
                padding: 5px;
            }
            QTextEdit {
                background-color: #1a1a1a;
                color: #00ff00;
                border: 2px solid #4CAF50;
                border-radius: 5px;
                padding: 10px;
                font-family: 'Courier New', monospace;
                font-size: 12px;
                font-weight: bold;
                selection-background-color: #4CAF50;
            }
            QPushButton {
                background-color: #4CAF50;
                color: white;
                border: none;
                padding: 10px 15px;
                border-radius: 5px;
                font-weight: bold;
                font-size: 12px;
                min-width: 120px;
            }
            QPushButton:hover {
                background-color: #45a049;
                transform: translateY(-1px);
            }
            QPushButton:pressed {
                background-color: #3d8b40;
                transform: translateY(1px);
            }
            QPushButton#close_button {
                background-color: #f44336;
            }
            QPushButton#close_button:hover {
                background-color: #da190b;
            }
            QPushButton#close_button:pressed {
                background-color: #b71c1c;
            }
            QFrame {
                color: #666;
            }
        """)
        
        # Ð£ÑÑ‚Ð°Ð½Ð°Ð²Ð»Ð¸Ð²Ð°ÐµÐ¼ ID Ð´Ð»Ñ ÐºÐ½Ð¾Ð¿ÐºÐ¸ Ð·Ð°ÐºÑ€Ñ‹Ñ‚Ð¸Ñ
        self.close_button.setObjectName("close_button")
    
    def copy_hwid(self):
        """ÐšÐ¾Ð¿Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ðµ HWID Ð² Ð±ÑƒÑ„ÐµÑ€ Ð¾Ð±Ð¼ÐµÐ½Ð°"""
        try:
            clipboard = QApplication.clipboard()
            clipboard.setText(self.hwid)
            
            # ÐŸÐ¾ÐºÐ°Ð·Ñ‹Ð²Ð°ÐµÐ¼ ÑƒÐ²ÐµÐ´Ð¾Ð¼Ð»ÐµÐ½Ð¸Ðµ
            self.copy_button.setText("âœ… Ð¡ÐºÐ¾Ð¿Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¾!")
            self.copy_button.setStyleSheet("""
                QPushButton {
                    background-color: #2196F3;
                    color: white;
                }
            """)
            
            # Ð’Ð¾Ð·Ð²Ñ€Ð°Ñ‰Ð°ÐµÐ¼ Ð¸ÑÑ…Ð¾Ð´Ð½Ñ‹Ð¹ Ñ‚ÐµÐºÑÑ‚ Ñ‡ÐµÑ€ÐµÐ· 2 ÑÐµÐºÑƒÐ½Ð´Ñ‹
            QTimer.singleShot(2000, self.reset_copy_button)
            
            logger.info("HWID copied to clipboard")
            
        except Exception as e:
            logger.error(f"Error copying HWID: {e}")
            QMessageBox.warning(self, "ÐžÑˆÐ¸Ð±ÐºÐ°", "ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ ÑÐºÐ¾Ð¿Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ HWID")
    
    def reset_copy_button(self):
        """Ð¡Ð±Ñ€Ð¾Ñ Ñ‚ÐµÐºÑÑ‚Ð° ÐºÐ½Ð¾Ð¿ÐºÐ¸ ÐºÐ¾Ð¿Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ñ"""
        self.copy_button.setText("ðŸ“‹ ÐšÐ¾Ð¿Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ HWID")
        self.copy_button.setStyleSheet("")  # Ð’Ð¾Ð·Ð²Ñ€Ð°Ñ‰Ð°ÐµÐ¼ Ðº ÑÑ‚Ð°Ð½Ð´Ð°Ñ€Ñ‚Ð½Ð¾Ð¼Ñƒ ÑÑ‚Ð¸Ð»ÑŽ
    
    def get_hwid(self) -> str:
        """ÐŸÐ¾Ð»ÑƒÑ‡ÐµÐ½Ð¸Ðµ ÑÐ³ÐµÐ½ÐµÑ€Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð½Ð¾Ð³Ð¾ HWID"""
        return self.hwid





==========================
styles.py
==========================




"""Application styles - Centralized styling"""


def apply_dark_theme(app):
    """Apply dark theme to application"""
    app.setStyleSheet("""
        QWidget { 
            background-color: #2b2b2b; 
            color: #ffffff; 
            font-family: 'Ubuntu', 'Segoe UI', 'Arial', sans-serif;
            font-size: 12px;
        }
        QLineEdit {
            background-color: #1a1a1a;
            border: 2px solid #555;
            color: #ffffff;
            border-radius: 6px;
            padding: 8px;
            font-size: 13px;
        }
        QLineEdit:focus {
            border-color: #4CAF50;
            background-color: #222;
        }
        QPushButton {
            background-color: #404040;
            border: 1px solid #666;
            color: #ffffff;
            padding: 10px 18px;
            border-radius: 6px;
            font-weight: bold;
            font-size: 12px;
        }
        QPushButton:hover {
            background-color: #505050;
            border-color: #777;
        }
        QPushButton:pressed {
            background-color: #353535;
        }
        QPushButton:disabled {
            background-color: #2a2a2a;
            color: #666666;
            border-color: #444;
        }
        QGroupBox {
            font-weight: bold;
            font-size: 12px;
            border: 2px solid #555;
            border-radius: 8px;
            margin-top: 1ex;
            padding-top: 8px;
            background-color: #2a2a2a;
        }
        QScrollArea {
            border: none;
            background-color: #1a1a1a;
        }
        QScrollBar:vertical {
            background: #2a2a2a;
            width: 12px;
            border-radius: 6px;
        }
        QScrollBar::handle:vertical {
            background: #555;
            border-radius: 6px;
            min-height: 20px;
        }
        QScrollBar::handle:vertical:hover {
            background: #666;
        }
    """)





==========================
ui_config.py
==========================




"""UI configuration management - Handles window state, dock positions, and user preferences"""
import json
import logging
from pathlib import Path
from typing import Optional, Dict, Any
from dataclasses import dataclass, asdict, field
from PySide6.QtCore import QByteArray, QRect, QPoint

logger = logging.getLogger(__name__)


@dataclass
class WindowGeometry:
    """Window geometry state"""
    x: int = 100
    y: int = 100
    width: int = 1200
    height: int = 800
    maximized: bool = False
    
    def to_qrect(self) -> QRect:
        """Convert to QRect for Qt"""
        return QRect(self.x, self.y, self.width, self.height)
    
    @classmethod
    def from_qrect(cls, rect: QRect, maximized: bool = False) -> 'WindowGeometry':
        """Create from QRect"""
        return cls(
            x=rect.x(),
            y=rect.y(),
            width=rect.width(),
            height=rect.height(),
            maximized=maximized
        )


@dataclass
class DockState:
    """State of a single dock widget"""
    name: str
    floating: bool = False
    visible: bool = True
    area: str = "left"  # left, right, top, bottom
    geometry: Optional[Dict[str, int]] = None  # For floating docks
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary"""
        return {
            'name': self.name,
            'floating': self.floating,
            'visible': self.visible,
            'area': self.area,
            'geometry': self.geometry
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'DockState':
        """Create from dictionary"""
        return cls(
            name=data['name'],
            floating=data.get('floating', False),
            visible=data.get('visible', True),
            area=data.get('area', 'left'),
            geometry=data.get('geometry')
        )


@dataclass
class UIConfig:
    """Complete UI configuration state"""
    window_geometry: WindowGeometry = field(default_factory=WindowGeometry)
    dock_states: Dict[str, DockState] = field(default_factory=dict)
    roi: Optional[list] = None  # [x, y, width, height]
    theme: str = "dark"
    font_scale: float = 1.0
    show_tooltips: bool = True
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for JSON serialization"""
        return {
            'window_geometry': asdict(self.window_geometry),
            'dock_states': {name: state.to_dict() for name, state in self.dock_states.items()},
            'roi': self.roi,
            'theme': self.theme,
            'font_scale': self.font_scale,
            'show_tooltips': self.show_tooltips
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'UIConfig':
        """Create from dictionary"""
        window_geom_data = data.get('window_geometry', {})
        window_geometry = WindowGeometry(**window_geom_data) if window_geom_data else WindowGeometry()
        
        dock_states_data = data.get('dock_states', {})
        dock_states = {name: DockState.from_dict(state_data) 
                      for name, state_data in dock_states_data.items()}
        
        return cls(
            window_geometry=window_geometry,
            dock_states=dock_states,
            roi=data.get('roi'),
            theme=data.get('theme', 'dark'),
            font_scale=data.get('font_scale', 1.0),
            show_tooltips=data.get('show_tooltips', True)
        )


class UIConfigManager:
    """Manages loading and saving UI configuration"""
    
    DEFAULT_CONFIG_NAME = "ui_config.json"
    
    def __init__(self, config_path: Optional[Path] = None):
        """
        Initialize config manager
        
        Args:
            config_path: Custom path to config file. If None, uses project root.
        """
        if config_path is None:
            # Use project root
            config_path = Path(__file__).parent.parent / self.DEFAULT_CONFIG_NAME
        
        self.config_path = Path(config_path)
        self._config: Optional[UIConfig] = None
        logger.info(f"UI config manager initialized: {self.config_path}")
    
    def load(self) -> UIConfig:
        """
        Load UI configuration from file
        
        Returns:
            UIConfig instance (default if file doesn't exist or is invalid)
        """
        if not self.config_path.exists():
            logger.info("No UI config file found, using defaults")
            self._config = UIConfig()
            return self._config
        
        try:
            with open(self.config_path, 'r', encoding='utf-8') as f:
                data = json.load(f)
            
            self._config = UIConfig.from_dict(data)
            logger.info(f"UI config loaded successfully from {self.config_path}")
            return self._config
            
        except Exception as e:
            logger.error(f"Failed to load UI config: {e}", exc_info=True)
            logger.info("Using default UI config")
            self._config = UIConfig()
            return self._config
    
    def save(self, config: UIConfig) -> bool:
        """
        Save UI configuration to file
        
        Args:
            config: UIConfig instance to save
            
        Returns:
            True if successful, False otherwise
        """
        try:
            self._config = config
            
            # Ensure directory exists
            self.config_path.parent.mkdir(parents=True, exist_ok=True)
            
            # Save to file with pretty formatting
            with open(self.config_path, 'w', encoding='utf-8') as f:
                json.dump(config.to_dict(), f, indent=2, ensure_ascii=False)
            
            logger.info(f"UI config saved successfully to {self.config_path}")
            return True
            
        except Exception as e:
            logger.error(f"Failed to save UI config: {e}", exc_info=True)
            return False
    
    @property
    def config(self) -> UIConfig:
        """Get current config (loads if not loaded)"""
        if self._config is None:
            return self.load()
        return self._config
    
    def update_window_geometry(self, geometry: WindowGeometry):
        """Update and save window geometry"""
        if self._config is None:
            self._config = self.load()
        
        self._config.window_geometry = geometry
        self.save(self._config)
    
    def update_dock_state(self, dock_name: str, state: DockState):
        """Update and save dock state"""
        if self._config is None:
            self._config = self.load()
        
        self._config.dock_states[dock_name] = state
        self.save(self._config)
    
    def update_roi(self, roi: list):
        """Update and save ROI"""
        if self._config is None:
            self._config = self.load()
        
        self._config.roi = roi
        self.save(self._config)
    
    def get_dock_state(self, dock_name: str) -> Optional[DockState]:
        """Get dock state by name"""
        if self._config is None:
            self._config = self.load()
        
        return self._config.dock_states.get(dock_name)





==========================
init.py(widgets)
==========================




"""UI widgets package"""
from .card_input import CardInputWidget
from .selection_overlay import SelectionOverlay

__all__ = ['CardInputWidget', 'SelectionOverlay']





==========================
card_input.py
==========================




"""Reusable card input widget with suit buttons"""

from functools import partial
from PySide6.QtCore import Qt
from PySide6.QtWidgets import QWidget, QLabel, QPushButton, QHBoxLayout, QLineEdit


class CardLineEdit(QLineEdit):
    """Enhanced QLineEdit with wheel scrolling for ranks"""
    ranks = ['2', '3', '4', '5', '6', '7', '8', '9', 'T', 'J', 'Q', 'K', 'A']

    def wheelEvent(self, event):
        """Scroll wheel to cycle through ranks"""
        text = self.text().upper()
        suit = ''
        rank = 'A'

        if len(text) == 2:
            rank, suit = text[0], text[1]
        elif len(text) == 1:
            rank = text[0]

        try:
            current_idx = self.ranks.index(rank)
        except ValueError:
            current_idx = len(self.ranks) - 1

        scroll_delta = event.angleDelta().y()
        if scroll_delta > 0:
            new_idx = (current_idx + 1) % len(self.ranks)
        else:
            new_idx = (current_idx - 1) % len(self.ranks)

        new_rank = self.ranks[new_idx]
        self.setText(new_rank + suit)
        self.selectAll()
        event.accept()


class CardInputWidget(QWidget):
    """Card input with suit buttons and auto-highlight"""

    def __init__(self, label_text: str, parent=None):
        super().__init__(parent)

        self.layout = QHBoxLayout(self)
        self.layout.setContentsMargins(5, 5, 5, 5)
        self.layout.setSpacing(8)

        # Label
        self.label = QLabel(label_text)
        self.label.setFixedWidth(80)
        self.label.setStyleSheet("color: #fff; font-weight: bold;")
        self.layout.addWidget(self.label)

        # Card input with wheel scrolling
        self.line_edit = CardLineEdit()
        self.line_edit.setFixedWidth(50)
        self.line_edit.setMaxLength(2)
        self.line_edit.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.line_edit.setStyleSheet("""
            QLineEdit {
                font-weight: bold; font-size: 18px; text-transform: uppercase;
                padding: 8px; border: 2px solid #555; border-radius: 6px;
                background-color: #1a1a1a; color: white;
            }
            QLineEdit:focus { border-color: #4CAF50; background-color: #222; }
            QLineEdit:hover { border-color: #777; background-color: #222; }
        """)
        self.line_edit.setToolTip("ðŸŽ® Scroll wheel to change rank\nðŸ–±ï¸ Click suit buttons")
        self.layout.addWidget(self.line_edit)

        # Suit buttons with metadata
        self.suit_buttons = []
        self.suit_data = []  # Store suit metadata for highlighting

        suits = [
            ("s", "â™ ", "#1a1a1a", "#f0f0f0"),
            ("h", "â™¥", "#e53935", "#fff0f0"),
            ("c", "â™£", "#1a1a1a", "#f0f0f0"),
            ("d", "â™¦", "#e53935", "#fff0f0")
        ]

        for suit_char, suit_symbol, text_color, bg_color in suits:
            btn = QPushButton(suit_symbol)
            btn.setFixedSize(36, 36)

            # Define normal and highlighted styles
            normal_style = f"""
                QPushButton {{
                    font-size: 22px; font-weight: bold; color: {text_color};
                    background-color: {bg_color}; border: 2px solid #999; border-radius: 8px;
                    margin-left: 3px; padding: 2px;
                }}
                QPushButton:hover {{
                    background-color: #4CAF50; color: white; border-color: #4CAF50;
                }}
                QPushButton:pressed {{
                    background-color: #388E3C; color: white; border-color: #388E3C;
                }}
            """

            highlighted_style = f"""
                QPushButton {{
                    font-size: 22px; font-weight: bold; color: #000000;
                    background-color: #FFC107; border: 3px solid #FFA000; border-radius: 8px;
                    margin-left: 3px; padding: 2px;
                }}
                QPushButton:hover {{
                    background-color: #FFD54F; color: #000000; border-color: #FF6F00;
                }}
            """

            btn.setStyleSheet(normal_style)
            btn.clicked.connect(partial(self.on_suit_clicked, suit_char))
            self.layout.addWidget(btn)
            self.suit_buttons.append(btn)

            # Store suit metadata
            self.suit_data.append({
                'char': suit_char.lower(),
                'button': btn,
                'normal_style': normal_style,
                'highlighted_style': highlighted_style
            })

        # Connect text change signal to update highlight
        self.line_edit.textChanged.connect(self._update_suit_highlight)

    def _update_suit_highlight(self):
        """Update suit button highlighting based on text input"""
        text = self.line_edit.text().upper()
        current_suit = None

        # Extract suit from text (second character if present)
        if len(text) >= 2:
            current_suit = text[1].lower()

        # Update all button styles
        for suit_info in self.suit_data:
            if suit_info['char'] == current_suit:
                # Highlight active suit
                suit_info['button'].setStyleSheet(suit_info['highlighted_style'])
            else:
                # Reset to normal style
                suit_info['button'].setStyleSheet(suit_info['normal_style'])

    def on_suit_clicked(self, suit_char: str):
        """Handle suit button click"""
        text = self.line_edit.text().upper()
        rank = text[0] if len(text) > 0 else 'A'
        self.line_edit.setText(rank + suit_char.upper())
        self.line_edit.setFocus()
        self.line_edit.selectAll()
        # Highlight updates automatically via textChanged signal

    def get_text(self) -> str:
        return self.line_edit.text().upper()

    def set_text(self, text: str):
        self.line_edit.setText(text.upper())
        # Highlight updates automatically via textChanged signal

    def clear(self):
        self.line_edit.clear()
        # Highlight updates automatically via textChanged signal





==========================
selection_overlay.py
==========================




"""Selection overlay for ROI capture"""
import logging
from typing import Optional
from PySide6.QtCore import Qt, QPoint, QRect
from PySide6.QtGui import QGuiApplication, QPainter, QPen, QBrush, QColor
from PySide6.QtWidgets import QDialog

logger = logging.getLogger(__name__)


class SelectionOverlay(QDialog):
    """Transparent overlay for ROI selection"""
    
    def __init__(self, parent=None):
        super().__init__(parent)
        logger.info("SelectionOverlay: Initializing...")
        
        self.setWindowFlags(Qt.WindowType.WindowStaysOnTopHint | 
                          Qt.WindowType.FramelessWindowHint | 
                          Qt.WindowType.Tool)
        self.setAttribute(Qt.WidgetAttribute.WA_TranslucentBackground)
        self.setWindowModality(Qt.WindowModality.ApplicationModal)
        
        self.start_global: Optional[QPoint] = None
        self.end_global: Optional[QPoint] = None
        
        # Cover all screens
        try:
            primary_screen = QGuiApplication.primaryScreen()
            virtual_geom = primary_screen.virtualGeometry()
            self.setGeometry(virtual_geom)
            logger.info(f"Overlay covers: {virtual_geom.width()}x{virtual_geom.height()}")
        except Exception as e:
            logger.error(f"Failed to get screen geometry: {e}")
            self.setGeometry(0, 0, 1920, 1080)
        
        self.setCursor(Qt.CursorShape.CrossCursor)
    
    def mousePressEvent(self, event):
        if event.button() == Qt.MouseButton.LeftButton:
            self.start_global = event.globalPosition().toPoint()
            self.end_global = self.start_global
            logger.info(f"Selection started at ({self.start_global.x()}, {self.start_global.y()})")
            self.update()
    
    def mouseMoveEvent(self, event):
        if self.start_global is not None:
            self.end_global = event.globalPosition().toPoint()
            self.update()
    
    def mouseReleaseEvent(self, event):
        if event.button() == Qt.MouseButton.LeftButton and self.start_global is not None:
            self.end_global = event.globalPosition().toPoint()
            rect = QRect(self.start_global, self.end_global).normalized()
            logger.info(f"Selection complete: {rect.width()}x{rect.height()} at ({rect.x()}, {rect.y()})")
            self.accept()
    
    def keyPressEvent(self, event):
        if event.key() == Qt.Key.Key_Escape:
            logger.info("Selection cancelled")
            self.reject()
    
    def paintEvent(self, event):
        painter = QPainter(self)
        painter.setRenderHint(QPainter.RenderHint.Antialiasing)
        
        # Semi-transparent background
        painter.fillRect(self.rect(), QColor(0, 0, 0, 100))
        
        if not self.start_global or not self.end_global:
            painter.setPen(QPen(QColor(255, 255, 255), 2))
            hint_text = "Click and drag to select capture area â€¢ ESC to cancel"
            painter.drawText(self.rect(), Qt.AlignmentFlag.AlignCenter, hint_text)
            return
        
        # Convert to local coordinates
        start_local = self.mapFromGlobal(self.start_global)
        end_local = self.mapFromGlobal(self.end_global)
        rect = QRect(start_local, end_local).normalized()
        
        # Clear selected area
        painter.setCompositionMode(QPainter.CompositionMode.CompositionMode_Clear)
        painter.fillRect(rect, QColor(0, 0, 0, 0))
        painter.setCompositionMode(QPainter.CompositionMode.CompositionMode_SourceOver)
        
        # Green selection rectangle
        painter.setPen(QPen(QColor(0, 255, 0), 3, Qt.PenStyle.SolidLine))
        painter.drawRect(rect)
        painter.fillRect(rect, QColor(0, 255, 0, 30))
        
        # Coordinates text
        painter.setPen(QPen(QColor(255, 255, 255), 2))
        painter.setBrush(QBrush(QColor(0, 0, 0, 180)))
        text = f"{rect.width()}Ã—{rect.height()} at ({rect.x()}, {rect.y()})"
        text_rect = painter.fontMetrics().boundingRect(text)
        text_rect.adjust(-8, -5, 8, 5)
        text_pos = rect.topLeft() + QPoint(5, -text_rect.height() - 5)
        
        if text_pos.y() < 0:
            text_pos = rect.bottomLeft() + QPoint(5, 10)
        
        text_rect.moveTo(text_pos)
        painter.drawRect(text_rect)
        painter.setPen(QPen(QColor(255, 255, 255)))
        painter.drawText(text_rect, Qt.AlignmentFlag.AlignCenter, text)
    
    def selected_rect(self) -> Optional[QRect]:
        """Return global QRect for screen capture"""
        if self.start_global and self.end_global:
            rect = QRect(self.start_global, self.end_global).normalized()
            logger.info(f"Final selection: {rect.width()}x{rect.height()} at ({rect.x()}, {rect.y()})")
            return rect
        return None





==========================
init.py(windows)
==========================




"""Windows package"""
from .main_window import MainWindow

__all__ = ['MainWindow']





==========================
adaptive_main_window.py
==========================




"""Adaptive main window with dockable panels - Fully responsive UI"""
import logging
from pathlib import Path
from typing import Optional, List, Dict, Any
import numpy as np
import cv2
from utils.global_hotkeys import get_hotkey_manager

from PySide6.QtWidgets import (QMainWindow, QWidget, QVBoxLayout, QHBoxLayout,
                               QLabel, QPushButton, QMessageBox, QToolBar, 
                               QStatusBar, QSizePolicy, QMenu, QGroupBox, QScrollArea)
from PySide6.QtCore import Qt, QRect, QTimer, QSize
from PySide6.QtGui import QImage, QPixmap, QAction, QIcon

from core.domain import Card, GameState, GameStage, TableSize, GameType
from services.ml_service import MLService
from services.analysis_service import AnalysisService
from ui.dock_widgets import (TableConfigDock, CardsDock, ImagePreviewDock)
from ui.widgets import SelectionOverlay
from ui.ui_config import UIConfigManager, WindowGeometry, DockState
from utils.screen_capture import ScreenCapture

logger = logging.getLogger(__name__)


class AdaptiveMainWindow(QMainWindow):
    """
    Adaptive main window with dockable panels.
    
    Features:
    - Dockable/floatable panels
    - Persistent UI state (geometry, dock positions)
    - Responsive layout
    - Multi-monitor support
    """
    
    def __init__(self, ml_service: MLService, analysis_service: AnalysisService):
        super().__init__()
        
        # Services
        self.ml_service = ml_service
        self.analysis_service = analysis_service
        self.screen_capture = ScreenCapture()
        
        # UI Config Manager
        self.ui_config_manager = UIConfigManager()
        
        # State
        self.roi: Optional[QRect] = None
        self.captured_frame: Optional[np.ndarray] = None
        self.game_state = GameState(
            table_size=TableSize.SIX_MAX,
            game_type=GameType.CASH,
            stage=GameStage.PREFLOP,
            player_cards=[],
            board_cards=[]
        )
        
        # Dock widgets
        self.table_config_dock: Optional[TableConfigDock] = None
        self.cards_dock: Optional[CardsDock] = None
        self.image_preview_dock: Optional[ImagePreviewDock] = None
        
        # UI Components (analysis is now in central widget)
        self.game_state_label: Optional[QLabel] = None
        self.analysis_scroll: Optional[QScrollArea] = None
        self.analysis_content: Optional[QWidget] = None
        self.analysis_layout: Optional[QVBoxLayout] = None
        
        # Timer for debounced analysis
        self.analysis_timer = QTimer(self)
        self.analysis_timer.setSingleShot(True)
        self.analysis_timer.timeout.connect(self.analyze_situation)
        
        # Setup
        self.setup_ui()
        self.load_ui_state()
        self.load_roi()
        
        logger.info("Adaptive main window initialized")
        self.hotkey_manager = get_hotkey_manager()
    
        if self.hotkey_manager.is_available():
            # Connect signals
            self.hotkey_manager.numpad_pressed.connect(self._on_hotkey_opponent_select)
            self.hotkey_manager.enter_pressed.connect(self._on_hotkey_capture)
            
            # Register hotkeys
            self.hotkey_manager.register_hotkeys()
            logger.info("âœ… Global hotkeys enabled")
        else:
            logger.warning("âš ï¸  Global hotkeys not available (install: pip install keyboard)")
    
    def setup_ui(self):
        """Setup complete user interface"""
        self.setWindowTitle("ðŸ’œ MonteLab - Adaptive UI ðŸ’œ")
        
        # Set default geometry to match original (will be overridden by saved state)
        self.setGeometry(100, 100, 1000, 700)
        # Minimal constraints - allow aggressive shrinking when panels are floating
        self.setMinimumSize(400, 300)
        
        # Create central widget
        self._create_central_widget()
        
        # Create toolbar
        self._create_toolbar()
        
        # Create dock widgets
        self._create_dock_widgets()
        
        # Create status bar
        self._create_status_bar()
        
        # Setup menu bar
        self._create_menu_bar()
        
        logger.info("UI setup complete")
    
    def _create_central_widget(self):
        """Create central widget with integrated analysis area"""
        central = QWidget()
        self.setCentralWidget(central)
        
        layout = QVBoxLayout(central)
        layout.setContentsMargins(8, 8, 8, 8)
        layout.setSpacing(8)
        
        # Title
        title = QLabel("MonteLab - Advanced Poker Analysis")
        title.setAlignment(Qt.AlignmentFlag.AlignCenter)
        title.setStyleSheet("""
            font-size: 20px; 
            font-weight: bold; 
            color: #4CAF50; 
            padding: 12px;
            background-color: #1a1a1a;
            border-radius: 6px;
        """)
        layout.addWidget(title)
        
        # Game state display
        self.game_state_label = QLabel("Current Mode: 6-Max Cash | Stage: Preflop")
        self.game_state_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.game_state_label.setStyleSheet("""
            font-size: 14px; 
            font-weight: bold; 
            color: #81C784; 
            padding: 10px;
            background-color: #1a1a1a;
            border-radius: 6px;
        """)
        layout.addWidget(self.game_state_label)
        
        # Integrated Analysis Area (replaces separate dock)
        analysis_group = QGroupBox("ðŸ§  Poker Analysis")
        analysis_group.setStyleSheet("""
            QGroupBox {
                font-weight: bold;
                font-size: 13px;
                border: 2px solid #4CAF50;
                border-radius: 8px;
                margin-top: 1ex;
                padding-top: 12px;
                background-color: #1e1e1e;
            }
            QGroupBox::title {
                color: #4CAF50;
                subcontrol-origin: margin;
                left: 10px;
                padding: 0 5px 0 5px;
            }
        """)
        
        analysis_layout = QVBoxLayout(analysis_group)
        analysis_layout.setContentsMargins(8, 8, 8, 8)
        
        # Scrollable analysis content
        self.analysis_scroll = QScrollArea()
        self.analysis_scroll.setWidgetResizable(True)
        self.analysis_scroll.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        
        self.analysis_content = QWidget()
        self.analysis_layout = QVBoxLayout(self.analysis_content)
        self.analysis_layout.setSpacing(8)
        self.analysis_layout.setContentsMargins(8, 8, 8, 8)
        
        self.analysis_scroll.setWidget(self.analysis_content)
        analysis_layout.addWidget(self.analysis_scroll)
        
        layout.addWidget(analysis_group, 1)  # Take all available space
        
        # Show welcome message by default
        self.create_default_analysis()
    
    def _create_toolbar(self):
        """Create main toolbar with actions"""
        toolbar = QToolBar("Main Toolbar")
        toolbar.setMovable(False)
        toolbar.setIconSize(QSize(24, 24))
        self.addToolBar(Qt.ToolBarArea.TopToolBarArea, toolbar)
        
        # Select ROI action
        select_roi_action = QAction("ðŸŽ¯ Select Area", self)
        select_roi_action.setStatusTip("Select screen capture area")
        select_roi_action.triggered.connect(self.select_roi)
        toolbar.addAction(select_roi_action)
        
        toolbar.addSeparator()
        
        # Capture action
        self.capture_action = QAction("ðŸ“¸ Capture", self)
        self.capture_action.setStatusTip("Capture and detect cards")
        self.capture_action.setEnabled(False)
        self.capture_action.triggered.connect(self.capture_and_detect)
        toolbar.addAction(self.capture_action)
        
        toolbar.addSeparator()
        
        # Analyze action
        analyze_action = QAction("ðŸ§  Analyze", self)
        analyze_action.setStatusTip("Analyze current situation")
        analyze_action.triggered.connect(self.analyze_situation)
        toolbar.addAction(analyze_action)
        
        toolbar.addSeparator()
        
        # Clear action
        clear_action = QAction("ðŸ”„ Clear", self)
        clear_action.setStatusTip("Clear all inputs")
        clear_action.triggered.connect(self.clear_all_inputs)
        toolbar.addAction(clear_action)
        
        # Add stretch to push remaining items to right
        spacer = QWidget()
        spacer.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Preferred)
        toolbar.addWidget(spacer)
        
        # Reset layout action
        reset_layout_action = QAction("âš¡ Reset Layout", self)
        reset_layout_action.setStatusTip("Reset docks to default positions")
        reset_layout_action.triggered.connect(self.reset_dock_layout)
        toolbar.addAction(reset_layout_action)
    
    def _create_dock_widgets(self):
        """Create and configure all dock widgets"""
        # Table Configuration Dock (Left)
        self.table_config_dock = TableConfigDock(self)
        self.table_config_dock.table_size_changed.connect(self.on_table_size_changed)
        self.addDockWidget(Qt.DockWidgetArea.LeftDockWidgetArea, self.table_config_dock)
        
        # Cards Dock (Left, below table config)
        self.cards_dock = CardsDock(self)
        self.cards_dock.cards_changed.connect(self.on_cards_changed)
        self.addDockWidget(Qt.DockWidgetArea.LeftDockWidgetArea, self.cards_dock)
        
        # Image Preview Dock (Right)
        self.image_preview_dock = ImagePreviewDock(self)
        self.addDockWidget(Qt.DockWidgetArea.RightDockWidgetArea, self.image_preview_dock)
        
        # Set relative sizes
        self.resizeDocks(
            [self.table_config_dock, self.cards_dock],
            [200, 400],
            Qt.Orientation.Vertical
        )
        
        logger.info("Dock widgets created")
    
    def _create_status_bar(self):
        """Create status bar"""
        status_bar = QStatusBar()
        self.setStatusBar(status_bar)
        status_bar.showMessage("Ready - Configure and analyze")
        status_bar.setStyleSheet("""
            QStatusBar {
                background-color: #1a1a1a;
                color: #888;
                border-top: 1px solid #444;
                padding: 4px;
            }
        """)
    
    def _create_menu_bar(self):
        """Create menu bar"""
        menubar = self.menuBar()
        
        # View menu
        view_menu = menubar.addMenu("&View")
        
        # Toggle dock visibility actions
        view_menu.addAction(self.table_config_dock.toggleViewAction())
        view_menu.addAction(self.cards_dock.toggleViewAction())
        view_menu.addAction(self.image_preview_dock.toggleViewAction())
        
        view_menu.addSeparator()
        
        # Reset layout action
        reset_action = QAction("Reset Layout", self)
        reset_action.triggered.connect(self.reset_dock_layout)
        view_menu.addAction(reset_action)
        
        # Tools menu
        tools_menu = menubar.addMenu("&Tools")
        
        select_roi_action = QAction("Select Capture Area", self)
        select_roi_action.triggered.connect(self.select_roi)
        tools_menu.addAction(select_roi_action)
        
        clear_action = QAction("Clear All Cards", self)
        clear_action.triggered.connect(self.clear_all_inputs)
        tools_menu.addAction(clear_action)
        
        # Help menu
        help_menu = menubar.addMenu("&Help")
        
        about_action = QAction("About", self)
        about_action.triggered.connect(self.show_about)
        help_menu.addAction(about_action)
    
    def reset_dock_layout(self):
        """Reset dock widgets to default layout"""
        # Reset to default positions
        self.removeDockWidget(self.table_config_dock)
        self.removeDockWidget(self.cards_dock)
        self.removeDockWidget(self.image_preview_dock)
        
        self.addDockWidget(Qt.DockWidgetArea.LeftDockWidgetArea, self.table_config_dock)
        self.addDockWidget(Qt.DockWidgetArea.LeftDockWidgetArea, self.cards_dock)
        self.addDockWidget(Qt.DockWidgetArea.RightDockWidgetArea, self.image_preview_dock)
        
        # Ensure all visible
        for dock in [self.table_config_dock, self.cards_dock, self.image_preview_dock]:
            dock.setVisible(True)
            dock.setFloating(False)
        
        self.statusBar().showMessage("Layout reset to default", 3000)
        logger.info("Dock layout reset to default")
    
    def show_about(self):
        """Show about dialog"""
        QMessageBox.about(
            self,
            "About MonteLab",
            """
            <h2>MonteLab - Adaptive UI</h2>
            <p><b>Version:</b> 2.0-Adaptive</p>
            <p><b>Architecture:</b> Modular with dockable panels</p>
            <br>
            <p><b>Features:</b></p>
            <ul>
            <li>Adaptive responsive UI</li>
            <li>Dockable/floatable panels</li>
            <li>Persistent layout state</li>
            <li>Multi-monitor support</li>
            <li>ML-powered card detection</li>
            <li>Advanced poker analysis</li>
            </ul>
            """
        )
    
    # ==================== Event Handlers ====================
    
    def on_table_size_changed(self, table_size: TableSize):
        """Handle table size change"""
        self.game_state.table_size = table_size
        
        # Update player and board cards from current inputs
        self.game_state.player_cards = self.get_player_cards()
        self.game_state.board_cards = self.get_board_cards()
        self.game_state.stage = self._determine_stage(self.game_state.board_cards)
        
        self.update_game_state_display()
        
        # Auto-analyze if we have valid player cards
        if len(self.game_state.player_cards) == 2:
            self.analysis_timer.stop()
            self.analysis_timer.start(300)
        
        logger.info(f"Table size changed: {table_size}")
    
    def on_game_type_changed(self, game_type: GameType):
        """Handle game type change"""
        self.game_state.game_type = game_type
        self.update_game_state_display()
        logger.info(f"Game type changed: {game_type}")
    
    def on_cards_changed(self, *args):
        """Handle card input changes"""
        # Update player cards
        player_cards = self.get_player_cards()
        self.game_state.player_cards = player_cards
        
        # Update board cards
        board_cards = self.get_board_cards()
        self.game_state.board_cards = board_cards
        self.game_state.stage = self._determine_stage(board_cards)
        
        self.update_game_state_display()
        
        # Auto-analyze if we have valid player cards
        if len(player_cards) == 2:
            # Debounce analysis
            self.analysis_timer.stop()
            self.analysis_timer.start(300)
        
        logger.debug(f"Cards changed: {len(player_cards)} player, {len(board_cards)} board")
    
    def update_game_state_display(self):
        """Update game state label"""
        players_count = self.game_state.get_players_count()
        stage_name = self.game_state.stage.value
        board_count = len(self.game_state.board_cards)
        game_type = self.game_state.game_type.value
        
        display_text = (f"Ð¡Ñ‚Ð¾Ð»: {players_count} Ð¸Ð³Ñ€Ð¾ÐºÐ¾Ð² | "
                       f"Ð¢Ð¸Ð¿: {game_type} | "
                       f"Ð¡Ñ‚Ð°Ð´Ð¸Ñ: {stage_name} ({board_count} ÐºÐ°Ñ€Ñ‚)")
        self.game_state_label.setText(display_text)
    
    # ==================== Card Management ====================
    
    def has_player_cards(self) -> bool:
        """Check if player has valid cards"""
        if not self.cards_dock:
            return False
        
        card1 = self.cards_dock.card1_widget.get_text().strip()
        card2 = self.cards_dock.card2_widget.get_text().strip()
        return bool(card1 and card2)
    
    def get_player_cards(self) -> List[Card]:
        """Get player cards"""
        if not self.cards_dock:
            return []
        
        cards = []
        for widget in [self.cards_dock.card1_widget, self.cards_dock.card2_widget]:
            text = widget.get_text().strip()
            if text:
                card = Card.parse(text)
                if card:
                    cards.append(card)
        return cards
    
    def get_board_cards(self) -> List[Card]:
        """Get board cards"""
        if not self.cards_dock:
            return []
        
        cards = []
        widgets = [
            self.cards_dock.flop1_widget,
            self.cards_dock.flop2_widget,
            self.cards_dock.flop3_widget,
            self.cards_dock.turn_widget,
            self.cards_dock.river_widget
        ]
        
        for widget in widgets:
            text = widget.get_text().strip()
            if text:
                card = Card.parse(text)
                if card:
                    cards.append(card)
        return cards
    
    def _determine_stage(self, board_cards: List[Card]) -> GameStage:
        """Determine game stage from board cards"""
        num_board = len(board_cards)
        stage_map = {
            0: GameStage.PREFLOP,
            3: GameStage.FLOP,
            4: GameStage.TURN,
            5: GameStage.RIVER
        }
        return stage_map.get(num_board, GameStage.PREFLOP)
    
    def clear_all_inputs(self):
        """Clear all card inputs"""
        if self.cards_dock:
            self.cards_dock.clear_all_cards()
        
        self.game_state.player_cards = []
        self.game_state.board_cards = []
        self.game_state.stage = GameStage.PREFLOP
        
        self.update_game_state_display()
        
        self.create_default_analysis()
        
        self.statusBar().showMessage("ðŸ”„ All inputs cleared", 3000)
        logger.info("All inputs cleared")
    
    # ==================== ROI and Capture ====================
    
    def select_roi(self):
        """Select screen capture ROI"""
        logger.info("ROI selection started")
        try:
            overlay = SelectionOverlay(self)
            overlay.show()
            
            result = overlay.exec()
            
            if result == overlay.DialogCode.Accepted:
                rect = overlay.selected_rect()
                
                if rect and rect.width() > 50 and rect.height() > 50:
                    self.roi = rect
                    self.save_roi()
                    self.capture_action.setEnabled(True)
                    self.statusBar().showMessage(
                        f"âœ… Area selected: {rect.width()}Ã—{rect.height()} at ({rect.x()}, {rect.y()})",
                        5000
                    )
                    logger.info(f"ROI saved: {rect.width()}x{rect.height()}")
                else:
                    QMessageBox.warning(
                        self,
                        "Selection Too Small",
                        "Please select a larger area (minimum 50Ã—50 pixels)"
                    )
        
        except Exception as e:
            logger.error(f"ROI selection error: {e}", exc_info=True)
            QMessageBox.critical(self, "Selection Error", f"Failed to select region: {e}")
    
    def capture_and_detect(self):
        """Capture screen and detect cards"""
        if not self.roi:
            QMessageBox.warning(self, "No Area", "Please select capture area first")
            return
        
        self.statusBar().showMessage("ðŸ“¸ Capturing and analyzing...")
        
        try:
            frame = self.screen_capture.grab_roi(self.roi)
            if frame is None:
                QMessageBox.warning(self, "Capture Failed", "Failed to capture screenshot")
                self.statusBar().showMessage("âŒ Capture failed", 3000)
                return
            
            self.captured_frame = frame.copy()
            self.display_frame(frame)
            
            if self.ml_service.is_available:
                self.statusBar().showMessage("ðŸ” Analyzing cards with ML...")
                self._detect_and_fill_cards(frame)
            else:
                self.statusBar().showMessage(
                    "ðŸ“· Captured - ML unavailable, enter cards manually",
                    5000
                )
        
        except Exception as e:
            logger.error(f"Capture error: {e}", exc_info=True)
            QMessageBox.critical(self, "Capture Error", f"Failed to capture: {e}")
            self.statusBar().showMessage("âŒ Capture error", 3000)
    
    def _detect_and_fill_cards(self, frame: np.ndarray):
        """Detect cards using ML and fill inputs"""
        try:
            player_cards, board_cards = self.ml_service.detect_and_classify(
                frame,
                confidence_threshold=0.4
            )
            
            # Draw detections on frame
            overlay_frame = frame.copy()
            
            for detection in player_cards:
                x1, y1, x2, y2 = detection.bbox
                cv2.rectangle(overlay_frame, (x1, y1), (x2, y2), (0, 255, 0), 2)
                cv2.putText(
                    overlay_frame,
                    f"P: {detection.classification}",
                    (x1, y1 - 10),
                    cv2.FONT_HERSHEY_SIMPLEX,
                    0.6,
                    (0, 255, 0),
                    2
                )
            
            for detection in board_cards:
                x1, y1, x2, y2 = detection.bbox
                cv2.rectangle(overlay_frame, (x1, y1), (x2, y2), (255, 0, 0), 2)
                cv2.putText(
                    overlay_frame,
                    f"B: {detection.classification}",
                    (x1, y1 - 10),
                    cv2.FONT_HERSHEY_SIMPLEX,
                    0.6,
                    (255, 0, 0),
                    2
                )
            
            self.display_frame(overlay_frame)
            
            # Fill card inputs
            if len(player_cards) >= 1:
                self.cards_dock.card1_widget.set_text(player_cards[0].classification or "")
            if len(player_cards) >= 2:
                self.cards_dock.card2_widget.set_text(player_cards[1].classification or "")
            
            board_widgets = [
                self.cards_dock.flop1_widget,
                self.cards_dock.flop2_widget,
                self.cards_dock.flop3_widget,
                self.cards_dock.turn_widget,
                self.cards_dock.river_widget
            ]
            
            for i, widget in enumerate(board_widgets):
                if i < len(board_cards):
                    widget.set_text(board_cards[i].classification or "")
                else:
                    widget.clear()
            
            if len(player_cards) >= 2:
                self.analyze_situation()
                self.statusBar().showMessage(
                    f"âœ… Detected: {len(player_cards)} player, {len(board_cards)} board cards",
                    5000
                )
            else:
                self.statusBar().showMessage(
                    f"âš ï¸ Found {len(player_cards)} player cards - Complete manually",
                    5000
                )
        
        except Exception as e:
            logger.error(f"Detection error: {e}", exc_info=True)
            self.statusBar().showMessage("âŒ Detection error", 3000)
    
    def display_frame(self, frame: np.ndarray):
        """Display frame in image preview dock"""
        if not self.image_preview_dock:
            return
        
        try:
            if len(frame.shape) == 3:
                height, width, channel = frame.shape
                bytes_per_line = 3 * width
                q_image = QImage(
                    frame.data,
                    width,
                    height,
                    bytes_per_line,
                    QImage.Format.Format_RGB888
                ).rgbSwapped()
            else:
                height, width = frame.shape
                bytes_per_line = width
                q_image = QImage(
                    frame.data,
                    width,
                    height,
                    bytes_per_line,
                    QImage.Format.Format_Grayscale8
                )
            
            pixmap = QPixmap.fromImage(q_image)
            self.image_preview_dock.set_pixmap(pixmap)
        
        except Exception as e:
            logger.error(f"Display error: {e}")
    
    # ==================== Analysis ====================
    
    def create_default_analysis(self):
        """Display default welcome message in analysis area"""
        self.clear_analysis_content()
        
        welcome = QLabel("ðŸŽ´ Welcome to MonteLab")
        welcome.setStyleSheet("font-size: 18px; font-weight: bold; color: #4CAF50; padding: 15px;")
        welcome.setAlignment(Qt.AlignmentFlag.AlignCenter)
        
        instructions = QLabel("""
        <b>Instructions:</b><br>
        1. Configure table settings<br>
        2. Enter cards or use ML detection<br>
        3. Click 'Analyze' for insights<br><br>
        
        <b>Features:</b><br>
        â€¢ Hand strength evaluation<br>
        â€¢ Board texture analysis<br>
        â€¢ Outs calculation<br>
        â€¢ Strategy recommendations<br><br>
        
        <b>Tip:</b> Drag dock panels to customize layout<br>
        Right-click title bars for options<br>
        Double-click to undock/dock
        """)
        instructions.setStyleSheet("color: #ccc; padding: 15px; line-height: 1.6;")
        instructions.setWordWrap(True)
        
        self.analysis_layout.addWidget(welcome)
        self.analysis_layout.addWidget(instructions)
        self.analysis_layout.addStretch()
    
    def clear_analysis_content(self):
        """Clear all content from analysis area"""
        while self.analysis_layout.count():
            child = self.analysis_layout.takeAt(0)
            if child.widget():
                child.widget().deleteLater()
    
    def add_analysis_widget(self, widget: QWidget):
        """Add widget to analysis content"""
        self.analysis_layout.addWidget(widget)
    
    def add_analysis_stretch(self):
        """Add stretch to push content up"""
        self.analysis_layout.addStretch()
    
    def analyze_situation(self):
        """Analyze current poker situation"""
        if not self.has_player_cards():
            QMessageBox.warning(self, "Input Error", "Please enter both player cards")
            return
        
        try:
            player_cards = self.get_player_cards()
            board_cards = self.get_board_cards()
            
            if len(player_cards) != 2:
                QMessageBox.warning(self, "Invalid Cards", "Please enter valid player cards")
                return
            
            self.game_state.player_cards = player_cards
            self.game_state.board_cards = board_cards
            self.game_state.stage = self._determine_stage(board_cards)
            
            self.update_game_state_display()
            self.statusBar().showMessage("ðŸ§  Analyzing...", 1000)
            
            # Perform analysis
            analysis_result = self.analysis_service.analyze_hand(self.game_state)
            
            if "error" in analysis_result:
                QMessageBox.warning(self, "Analysis Error", analysis_result["error"])
            else:
                self._display_analysis_result(analysis_result)
            
            self.statusBar().showMessage("âœ… Analysis complete", 3000)
        
        except Exception as e:
            logger.error(f"Analysis error: {e}", exc_info=True)
            QMessageBox.critical(self, "Analysis Error", f"Failed to analyze: {e}")
            self.statusBar().showMessage("âŒ Analysis error", 3000)
    
    def _display_analysis_result(self, result: Dict[str, Any]):
        """Display analysis results in central analysis area"""
        self.clear_analysis_content()
        
        stage = result.get("stage", "")
        
        # Cards display
        cards_display = " ".join(str(c) for c in self.game_state.player_cards)
        board_display = (" ".join(str(c) for c in self.game_state.board_cards) 
                        if self.game_state.board_cards else "No board")
        
        # Title
        title = QLabel(f"ÐÐ½Ð°Ð»Ð¸Ð· - {stage}")
        title.setStyleSheet("""
            font-size: 20px; 
            font-weight: bold; 
            color: #4CAF50; 
            padding: 10px;
            background-color: rgba(76, 175, 80, 0.1);
            border-radius: 6px;
        """)
        
        # Cards info
        cards_label = QLabel(f"Player: {cards_display} | Board: {board_display}")
        cards_label.setStyleSheet("""
            font-size: 16px; 
            color: #81C784; 
            padding: 8px; 
            font-weight: bold;
            background-color: rgba(129, 199, 132, 0.1);
            border-radius: 4px;
        """)
        cards_label.setWordWrap(True)
        
        self.add_analysis_widget(title)
        self.add_analysis_widget(cards_label)
        
        # Hand strength analysis
        if "current_hand" in result:
            from PySide6.QtWidgets import QGroupBox, QVBoxLayout
            
            strength_group = QGroupBox("ÐÐ½Ð°Ð»Ð¸Ð· Ñ€ÑƒÐºÐ¸")
            strength_layout = QVBoxLayout(strength_group)
            
            current_hand_label = QLabel(f"Ð¢ÐµÐºÑƒÑ‰Ð°Ñ ÐºÐ¾Ð¼Ð±Ð¸Ð½Ð°Ñ†Ð¸Ñ: {result['current_hand']}")
            current_hand_label.setStyleSheet("""
                font-size: 16px; 
                color: #fff; 
                padding: 8px; 
                font-weight: bold;
            """)
            strength_layout.addWidget(current_hand_label)
            
            # Outs analysis
            outs_data = result.get("outs_analysis", {})
            total_outs = result.get("total_outs", 0)
            
            if total_outs >= 0:
                outs_text = f"ðŸŽ¯ ÐÐÐÐ›Ð˜Ð— ÐÐ£Ð¢ÐžÐ’:\n"
                outs_text += f"â€¢ Ð¤Ð»ÐµÑˆ: {outs_data.get('flush', 0)} Ð°ÑƒÑ‚Ð¾Ð²\n"
                outs_text += f"â€¢ Ð¡Ñ‚Ñ€Ð¸Ñ‚: {outs_data.get('straight', 0)} Ð°ÑƒÑ‚Ð¾Ð²\n"
                outs_text += f"â€¢ Ð¡ÐµÑ‚/Ð¢Ñ€Ð¸Ð¿Ñ: {outs_data.get('set_trips', 0)} Ð°ÑƒÑ‚Ð¾Ð²\n"
                outs_text += f"â€¢ ÐžÐ²ÐµÑ€ÐºÐ°Ñ€Ñ‚Ñ‹: {outs_data.get('overcard', 0)} Ð°ÑƒÑ‚Ð¾Ð²\n"
                outs_text += f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
                outs_text += f"ðŸ“Š Ð’Ð¡Ð•Ð“Ðž ÐÐ£Ð¢ÐžÐ’: {total_outs}\n\n"
                
                # Calculate improvement equity
                cards_to_come = 5 - len(self.game_state.board_cards)
                if cards_to_come == 2:
                    improvement_equity = min(total_outs * 4, 100)
                    stage_text = "Ð´Ð¾ Ñ€Ð¸Ð²ÐµÑ€Ð°"
                elif cards_to_come == 1:
                    improvement_equity = min(total_outs * 2, 100)
                    stage_text = "Ð½Ð° Ñ€Ð¸Ð²ÐµÑ€Ðµ"
                else:
                    improvement_equity = 0
                    stage_text = "Ð·Ð°Ð²ÐµÑ€ÑˆÐµÐ½"
                
                outs_text += f"ðŸ“ˆ Ð¨Ð°Ð½Ñ ÑƒÐ»ÑƒÑ‡ÑˆÐµÐ½Ð¸Ñ {stage_text}: {improvement_equity:.2f}%\n"
                
                # Add equity if available
                equity = result.get("equity", {})
                if "win_rate" in equity and not equity.get("error"):
                    outs_text += f"\nðŸ† Ð’Ð•Ð ÐžÐ¯Ð¢ÐÐžÐ¡Ð¢Ð¬ ÐŸÐžÐ‘Ð•Ð”Ð«:\n"
                    outs_text += f"â€¢ ÐŸÐ¾Ð±ÐµÐ´Ð°: {equity.get('win_rate', 0):.2f}%\n"
                    outs_text += f"â€¢ ÐÐ¸Ñ‡ÑŒÑ: {equity.get('tie_rate', 0):.2f}%\n"
                    outs_text += f"â€¢ ÐŸÐ¾Ñ€Ð°Ð¶ÐµÐ½Ð¸Ðµ: {equity.get('lose_rate', 0):.2f}%"
            else:
                outs_text = "âŒ Ð—Ð½Ð°Ñ‡Ð¸Ð¼Ñ‹Ñ… Ð´Ñ€Ð¾ Ð½Ðµ Ð¾Ð±Ð½Ð°Ñ€ÑƒÐ¶ÐµÐ½Ð¾"
            
            outs_label = QLabel(outs_text)
            outs_label.setStyleSheet("""
                font-size: 14px; 
                color: #ccc; 
                padding: 8px; 
                font-family: 'Consolas', monospace;
                background-color: rgba(0, 0, 0, 0.3);
                border-radius: 4px;
            """)
            outs_label.setWordWrap(True)
            strength_layout.addWidget(outs_label)
            
            self.add_analysis_widget(strength_group)
        
        # Board texture
        texture = result.get("board_texture", {})
        if texture and "error" not in texture:
            from PySide6.QtWidgets import QGroupBox, QVBoxLayout
            
            texture_group = QGroupBox("Ð¢ÐµÐºÑÑ‚ÑƒÑ€Ð° Ð´Ð¾ÑÐºÐ¸")
            texture_layout = QVBoxLayout(texture_group)
            
            features = []
            if texture.get('monotone'):
                features.append("ðŸ”´ ÐœÐ¾Ð½Ð¾Ñ‚Ð¾Ð½")
            elif texture.get('two_tone'):
                features.append("ðŸŸ¡ Ð”Ð²ÑƒÑ…Ñ†Ð²ÐµÑ‚Ð½Ð°Ñ")
            elif texture.get('rainbow'):
                features.append("ðŸŒˆ Ð Ð°Ð´ÑƒÐ¶Ð½Ð°Ñ")
            
            if texture.get('paired'):
                features.append("ðŸ‘¥ Ð¡Ð¿Ð°Ñ€ÐµÐ½Ð½Ð°Ñ")
            
            if texture.get('coordinated'):
                features.append("ðŸ”— Ð¡ÐºÐ¾Ð¾Ñ€Ð´Ð¸Ð½Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð½Ð°Ñ")
            elif texture.get('dry'):
                features.append("ðŸœï¸ Ð¡ÑƒÑ…Ð°Ñ")
            
            if texture.get('flush_draw'):
                features.append("ðŸ’§ Ð¤Ð»ÐµÑˆ-Ð´Ñ€Ð¾")
            
            texture_text = ("Ð¥Ð°Ñ€Ð°ÐºÑ‚ÐµÑ€Ð¸ÑÑ‚Ð¸ÐºÐ¸:\n" + "\n".join(f"â€¢ {f}" for f in features) 
                          if features else "Ð¡Ñ‚Ð°Ð½Ð´Ð°Ñ€Ñ‚Ð½Ð°Ñ")
            
            texture_label = QLabel(texture_text)
            texture_label.setStyleSheet("font-size: 14px; color: #ccc; padding: 8px;")
            texture_label.setWordWrap(True)
            texture_layout.addWidget(texture_label)
            
            self.add_analysis_widget(texture_group)
        
        # Strategy recommendation
        strategy = result.get("strategy_recommendation", "")
        if strategy:
            from PySide6.QtWidgets import QGroupBox, QVBoxLayout
            
            recommendations_group = QGroupBox("ABC Ð ÐµÐºÐ¾Ð¼ÐµÐ½Ð´Ð°Ñ†Ð¸Ð¸")
            recommendations_layout = QVBoxLayout(recommendations_group)
            
            strategy_label = QLabel(f"ðŸŽ¯ {strategy}")
            strategy_label.setStyleSheet("""
                font-size: 16px; 
                color: #FFD700; 
                padding: 15px; 
                font-weight: bold; 
                border: 2px solid #FFD700; 
                border-radius: 8px; 
                background-color: rgba(255, 215, 0, 0.1);
            """)
            strategy_label.setWordWrap(True)
            recommendations_layout.addWidget(strategy_label)
            
            self.add_analysis_widget(recommendations_group)
        
        self.add_analysis_stretch()
    
    # ==================== State Management ====================
    
    def save_roi(self):
        """Save ROI to config"""
        if self.roi:
            roi_data = [self.roi.x(), self.roi.y(), self.roi.width(), self.roi.height()]
            self.ui_config_manager.update_roi(roi_data)
            logger.info(f"ROI saved: {roi_data}")
    
    def load_roi(self):
        """Load ROI from config"""
        config = self.ui_config_manager.config
        if config.roi and len(config.roi) == 4:
            self.roi = QRect(*config.roi)
            self.capture_action.setEnabled(True)
            self.statusBar().showMessage(
                f"ðŸ“ Loaded saved area: {config.roi[2]}Ã—{config.roi[3]}",
                3000
            )
            logger.info(f"ROI loaded: {config.roi}")
    
    def load_ui_state(self):
        """Load and restore UI state from config"""
        config = self.ui_config_manager.config
        
        # Restore window geometry
        if config.window_geometry:
            self.setGeometry(config.window_geometry.to_qrect())
            if config.window_geometry.maximized:
                self.showMaximized()
        
        # Restore dock states
        for dock_name, dock in [
            ("table_config", self.table_config_dock),
            ("cards", self.cards_dock),
            ("image_preview", self.image_preview_dock)
        ]:
            if dock:
                dock_state = config.dock_states.get(dock_name)
                if dock_state:
                    # Restore visibility
                    dock.setVisible(dock_state.visible)
                    
                    # Restore floating state and geometry
                    if dock_state.floating and dock_state.geometry:
                        dock.setFloating(True)
                        geom = dock_state.geometry
                        from PySide6.QtCore import QRect
                        saved_rect = QRect(
                            geom['x'], geom['y'],
                            geom['width'], geom['height']
                        )
                        # Use the new set_saved_geometry method to properly restore
                        dock.set_saved_geometry(saved_rect)
                        logger.info(f"Restored floating {dock_name}: {geom}")
        
        logger.info("UI state loaded")
    
    def save_ui_state(self):
        """Save current UI state to config"""
        # Save window geometry
        geometry = WindowGeometry.from_qrect(
            self.geometry(),
            self.isMaximized()
        )
        self.ui_config_manager.update_window_geometry(geometry)
        
        # Save dock states
        for dock_name, dock in [
            ("table_config", self.table_config_dock),
            ("cards", self.cards_dock),
            ("image_preview", self.image_preview_dock)
        ]:
            if dock:
                area_map = {
                    Qt.DockWidgetArea.LeftDockWidgetArea: "left",
                    Qt.DockWidgetArea.RightDockWidgetArea: "right",
                    Qt.DockWidgetArea.TopDockWidgetArea: "top",
                    Qt.DockWidgetArea.BottomDockWidgetArea: "bottom"
                }
                
                geometry_dict = None
                if dock.isFloating():
                    geom = dock.geometry()
                    geometry_dict = {
                        'x': geom.x(),
                        'y': geom.y(),
                        'width': geom.width(),
                        'height': geom.height()
                    }
                
                state = DockState(
                    name=dock_name,
                    floating=dock.isFloating(),
                    visible=dock.isVisible(),
                    area=area_map.get(self.dockWidgetArea(dock), "left"),
                    geometry=geometry_dict
                )
                self.ui_config_manager.update_dock_state(dock_name, state)
        
        logger.info("UI state saved")

    def _on_hotkey_opponent_select(self, number: int):
        """Handle numpad hotkey for opponent selection"""
        logger.info(f"HANDLER: Setting {number} opponents via hotkey")
        
        try:
            # ÐŸÑ€ÑÐ¼Ð°Ñ ÑƒÑÑ‚Ð°Ð½Ð¾Ð²ÐºÐ° Ñ‡ÐµÑ€ÐµÐ· game_state
            if hasattr(self, 'game_state'):
                old_val = self.game_state.num_opponents
                self.game_state.num_opponents = number
                logger.info(f"HANDLER: SUCCESS! Set game_state.num_opponents: {old_val} -> {number}")
                
                # ÐŸÑ€Ð¸Ð½ÑƒÐ´Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ð¾ Ð²Ñ‹Ð·Ñ‹Ð²Ð°ÐµÐ¼ Ð¾Ð±Ð½Ð¾Ð²Ð»ÐµÐ½Ð¸Ðµ UI
                if hasattr(self, 'on_table_size_changed'):
                    self.on_table_size_changed()
                    logger.info("HANDLER: Called on_table_size_changed()")
                
                # ÐžÐ±Ð½Ð¾Ð²Ð»ÑÐµÐ¼ Ð¾Ñ‚Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½Ð¸Ðµ ÑÐ¾ÑÑ‚Ð¾ÑÐ½Ð¸Ñ Ð¸Ð³Ñ€Ñ‹
                if hasattr(self, 'update_game_state_display'):
                    self.update_game_state_display()
                    logger.info("HANDLER: Called update_game_state_display()")
                
                # Ð•ÑÐ»Ð¸ ÐµÑÑ‚ÑŒ Ð¼ÐµÑ‚Ð¾Ð´ analyze_situation - Ð²Ñ‹Ð·Ñ‹Ð²Ð°ÐµÐ¼ Ð´Ð»Ñ Ð¿ÐµÑ€ÐµÑÑ‡Ñ‘Ñ‚Ð°
                if hasattr(self, 'analyze_situation'):
                    self.analyze_situation()
                    logger.info("HANDLER: Called analyze_situation()")
                
                return
            
            logger.error("HANDLER: game_state not found!")
            
        except Exception as e:
            logger.error(f"HANDLER: Exception: {e}", exc_info=True)


    def _on_hotkey_capture(self):
        """Handle Enter hotkey for capture"""
        logger.info("HANDLER: Capture hotkey pressed")
        
        try:
            from PySide6.QtWidgets import QPushButton
            
            # Ð’Ð°Ñ€Ð¸Ð°Ð½Ñ‚ 1: capture_action
            if hasattr(self, 'capture_action'):
                logger.info("HANDLER: Found capture_action")
                self.capture_action.trigger()
                logger.info("HANDLER: SUCCESS! capture_action triggered")
                return
            
            # Ð’Ð°Ñ€Ð¸Ð°Ð½Ñ‚ 2: capture_and_detect Ð¼ÐµÑ‚Ð¾Ð´
            if hasattr(self, 'capture_and_detect'):
                logger.info("HANDLER: Found capture_and_detect method")
                self.capture_and_detect()
                logger.info("HANDLER: SUCCESS! capture_and_detect called")
                return
            
            # Ð’Ð°Ñ€Ð¸Ð°Ð½Ñ‚ 3: select_roi Ð¼ÐµÑ‚Ð¾Ð´
            if hasattr(self, 'select_roi'):
                logger.info("HANDLER: Found select_roi method")
                self.select_roi()
                logger.info("HANDLER: SUCCESS! select_roi called")
                return
            
            # Ð’Ð°Ñ€Ð¸Ð°Ð½Ñ‚ 4: Ð¿Ð¾Ð¸ÑÐº ÐºÐ½Ð¾Ð¿ÐºÐ¸
            all_buttons = self.findChildren(QPushButton)
            logger.info(f"HANDLER: Searching through {len(all_buttons)} buttons")
            
            for btn in all_buttons:
                btn_text = btn.text().lower()
                btn_name = btn.objectName().lower()
                
                if ('capture' in btn_text or 'capture' in btn_name or 
                    'grab' in btn_text or 'screen' in btn_text):
                    logger.info(f"HANDLER: Found button: '{btn.text()}' ({btn.objectName()})")
                    if btn.isEnabled():
                        btn.click()
                        logger.info("HANDLER: SUCCESS! Button clicked")
                        return
            
            logger.error("HANDLER: Could not trigger capture!")
            
        except Exception as e:
            logger.error(f"HANDLER: Exception: {e}", exc_info=True)    

    def closeEvent(self, event):
        """Handle window close event"""
        self.save_ui_state()
        logger.info("Application closing - UI state saved")
        event.accept()








==========================
main_window.py
==========================




"""Main application window - Refactored with service layer - COMPLETE"""
import json
import logging
from pathlib import Path
from typing import Optional, List
import numpy as np
import cv2
from utils.global_hotkeys import get_hotkey_manager

from PySide6.QtWidgets import (QWidget, QVBoxLayout, QHBoxLayout, QLabel, 
                               QPushButton, QGroupBox, QScrollArea, QMessageBox,
                               QRadioButton, QButtonGroup, QSizePolicy)
from PySide6.QtCore import Qt, QRect, QTimer
from PySide6.QtGui import QImage, QPixmap

from core.domain import Card, GameState, GameStage, TableSize, GameType
from services.ml_service import MLService
from services.analysis_service import AnalysisService
from ui.widgets import CardInputWidget, SelectionOverlay
from utils.screen_capture import ScreenCapture

logger = logging.getLogger(__name__)


class MainWindow(QWidget):
    """Main application window with clean separation of concerns"""
    
    def __init__(self, ml_service: MLService, analysis_service: AnalysisService):
        super().__init__()
        self.ml_service = ml_service
        self.analysis_service = analysis_service
        self.screen_capture = ScreenCapture()
        
        self.roi: Optional[QRect] = None
        self.captured_frame: Optional[np.ndarray] = None
        self.game_state = GameState(
            table_size=TableSize.SIX_MAX,
            game_type=GameType.CASH,
            stage=GameStage.PREFLOP,
            player_cards=[],
            board_cards=[]
        )
        
        self.setup_ui()
        self.load_roi()
        
        self.analysis_timer = QTimer(self)
        self.analysis_timer.setSingleShot(True)
        self.analysis_timer.timeout.connect(self.analyze_situation)
        self.hotkey_manager = get_hotkey_manager()
    
        if self.hotkey_manager.is_available():
            # Connect signals
            self.hotkey_manager.numpad_pressed.connect(self._on_hotkey_opponent_select)
            self.hotkey_manager.enter_pressed.connect(self._on_hotkey_capture)
            
            # Register hotkeys
            self.hotkey_manager.register_hotkeys()
            logger.info("âœ… Global hotkeys enabled")
        else:
            logger.warning("âš ï¸  Global hotkeys not available (install: pip install keyboard)")
    
    def setup_ui(self):
        """Setup user interface"""
        self.setWindowTitle("ðŸ’œ MonteLab - Refactored ðŸ’œ")
        self.setGeometry(100, 100, 1000, 700)
        self.setMinimumSize(800, 600)
        self.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        
        main_layout = QVBoxLayout(self)
        
        title = QLabel("MonteLab - Advanced Poker Analysis (Refactored)")
        title.setAlignment(Qt.AlignmentFlag.AlignCenter)
        title.setStyleSheet("font-size: 20px; font-weight: bold; color: #4CAF50; padding: 15px;")
        main_layout.addWidget(title)
        
        controls = self._create_controls()
        main_layout.addLayout(controls)
        
        self.game_state_label = QLabel("Current Mode: 6-Max Cash | Stage: Preflop")
        self.game_state_label.setStyleSheet("font-size: 14px; font-weight: bold; color: #81C784; padding: 8px;")
        main_layout.addWidget(self.game_state_label)
        
        content = self._create_content_area()
        main_layout.addLayout(content, 1)
        
        self.status_label = QLabel("Ready - Configure and analyze")
        self.status_label.setStyleSheet("color: #888; padding: 8px; background-color: #222; border-radius: 4px;")
        main_layout.addWidget(self.status_label)
    
    def _create_controls(self) -> QHBoxLayout:
        layout = QHBoxLayout()
        
        self.select_roi_btn = QPushButton("ðŸŽ¯ Select Area")
        self.capture_btn = QPushButton("ðŸ“¸ Capture")
        self.analyze_btn = QPushButton("ðŸ§  Analyze")
        
        self.capture_btn.setEnabled(False)
        
        # Apply individual styling with colors
        self.select_roi_btn.setStyleSheet("padding: 8px 15px; font-weight: bold; background-color: #FF9800;")
        self.capture_btn.setStyleSheet("padding: 8px 15px; font-weight: bold; background-color: #2196F3;")
        self.analyze_btn.setStyleSheet("padding: 8px 15px; font-weight: bold; background-color: #4CAF50;")
        
        self.select_roi_btn.clicked.connect(self.select_roi)
        self.capture_btn.clicked.connect(self.capture_and_detect)
        self.analyze_btn.clicked.connect(self.analyze_situation)
        
        layout.addWidget(self.select_roi_btn)
        layout.addWidget(self.capture_btn)
        layout.addWidget(self.analyze_btn)
        layout.addStretch()
        
        return layout
    
    def _create_content_area(self) -> QHBoxLayout:
        layout = QHBoxLayout()
        layout.setSpacing(15)
        
        table_config = self._create_table_config()
        layout.addWidget(table_config)
        
        cards_column = self._create_cards_column()
        layout.addLayout(cards_column)
        
        analysis_frame = self._create_analysis_frame()
        layout.addWidget(analysis_frame, 1)
        
        image_frame = self._create_image_frame()
        layout.addWidget(image_frame)
        
        return layout
    
    def _create_table_config(self) -> QGroupBox:
        frame = QGroupBox("Table Configuration")
        frame.setFixedWidth(180)
        
        layout = QVBoxLayout(frame)
        layout.setSpacing(4)
        
        self.table_size_group = QButtonGroup()
        table_sizes = [
            ("2_players", "2 Ð¸Ð³Ñ€Ð¾ÐºÐ°", TableSize.HEADS_UP),
            ("3_players", "3 Ð¸Ð³Ñ€Ð¾ÐºÐ°", TableSize.THREE_MAX),
            ("4_players", "4 Ð¸Ð³Ñ€Ð¾ÐºÐ°", TableSize.FOUR_MAX),
            ("5_players", "5 Ð¸Ð³Ñ€Ð¾ÐºÐ¾Ð²", TableSize.FIVE_MAX),
            ("6_players", "6 Ð¸Ð³Ñ€Ð¾ÐºÐ¾Ð²", TableSize.SIX_MAX),
            ("7_players", "7 Ð¸Ð³Ñ€Ð¾ÐºÐ¾Ð²", TableSize.SEVEN_MAX),
            ("8_players", "8 Ð¸Ð³Ñ€Ð¾ÐºÐ¾Ð²", TableSize.EIGHT_MAX),
            ("9_players", "9 Ð¸Ð³Ñ€Ð¾ÐºÐ¾Ð²", TableSize.NINE_MAX)
        ]
        
        for btn_id, label, size in table_sizes:
            btn = QRadioButton(label)
            btn.setProperty("table_size", size)
            btn.setStyleSheet("font-size: 11px; padding: 2px;")
            
            if btn_id == "6_players":
                btn.setChecked(True)
            
            self.table_size_group.addButton(btn)
            layout.addWidget(btn)
        
        layout.addStretch()
        self.table_size_group.buttonClicked.connect(self.on_table_config_changed)
        
        return frame
    
    def _create_cards_column(self) -> QVBoxLayout:
        layout = QVBoxLayout()
        layout.setSpacing(10)
        
        player_cards_frame = QGroupBox("Player Cards")
        player_cards_frame.setFixedWidth(280)
        player_cards_layout = QVBoxLayout(player_cards_frame)
        player_cards_layout.setSpacing(8)
        
        self.card1_widget = CardInputWidget("Card 1:")
        self.card2_widget = CardInputWidget("Card 2:")
        
        for widget in [self.card1_widget, self.card2_widget]:
            widget.label.setFixedWidth(70)
            widget.line_edit.setFixedWidth(45)
            for btn in widget.suit_buttons:
                btn.setFixedSize(30, 30)
        
        player_cards_layout.addWidget(self.card1_widget)
        player_cards_layout.addWidget(self.card2_widget)
        
        board_cards_frame = QGroupBox("Board Cards")
        board_cards_frame.setFixedWidth(280)
        board_cards_layout = QVBoxLayout(board_cards_frame)
        board_cards_layout.setSpacing(6)
        
        self.flop1_widget = CardInputWidget("Flop 1:")
        self.flop2_widget = CardInputWidget("Flop 2:")
        self.flop3_widget = CardInputWidget("Flop 3:")
        self.turn_widget = CardInputWidget("Turn:")
        self.river_widget = CardInputWidget("River:")
        
        for widget in [self.flop1_widget, self.flop2_widget, self.flop3_widget,
                      self.turn_widget, self.river_widget]:
            widget.label.setFixedWidth(70)
            widget.line_edit.setFixedWidth(45)
            for btn in widget.suit_buttons:
                btn.setFixedSize(30, 30)
        
        board_cards_layout.addWidget(self.flop1_widget)
        board_cards_layout.addWidget(self.flop2_widget)
        board_cards_layout.addWidget(self.flop3_widget)
        board_cards_layout.addWidget(self.turn_widget)
        board_cards_layout.addWidget(self.river_widget)
        
        layout.addWidget(player_cards_frame)
        layout.addWidget(board_cards_frame)
        layout.addStretch()
        
        for widget in [self.card1_widget, self.card2_widget, 
                      self.flop1_widget, self.flop2_widget, self.flop3_widget,
                      self.turn_widget, self.river_widget]:
            widget.line_edit.textChanged.connect(self.on_cards_changed)
        
        return layout
    
    def _create_analysis_frame(self) -> QGroupBox:
        frame = QGroupBox("Poker Analysis")
        frame.setMinimumWidth(350)
        
        layout = QVBoxLayout(frame)
        
        self.analysis_scroll = QScrollArea()
        self.analysis_content = QWidget()
        self.analysis_layout = QVBoxLayout(self.analysis_content)
        
        self.analysis_scroll.setWidget(self.analysis_content)
        self.analysis_scroll.setWidgetResizable(True)
        
        layout.addWidget(self.analysis_scroll, 1)
        
        self.create_default_analysis()
        
        return frame
    
    def _create_image_frame(self) -> QGroupBox:
        frame = QGroupBox("Captured Image")
        frame.setMinimumWidth(300)
        
        layout = QVBoxLayout(frame)
        
        self.image_label = QLabel("Select area and capture\ntable to detect cards\nautomatically")
        self.image_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.image_label.setMinimumSize(280, 300)
        self.image_label.setStyleSheet("""
            background: #111; color: #ccc; border: 2px solid #444; 
            border-radius: 4px; font-size: 14px; padding: 15px;
        """)
        
        layout.addWidget(self.image_label, 1)
        
        return frame
    
    def create_default_analysis(self):
        while self.analysis_layout.count():
            child = self.analysis_layout.takeAt(0)
            if child.widget():
                child.widget().deleteLater()
        
        welcome_label = QLabel("ðŸƒ Welcome to MonteLab")
        welcome_label.setStyleSheet("font-size: 18px; font-weight: bold; color: #4CAF50; padding: 15px;")
        welcome_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        
        instructions = QLabel("""
        <b>Instructions:</b><br>
        1. Select table configuration<br>
        2. Enter player cards and board cards<br>
        3. OR use ML detection by capturing area<br>
        4. Click 'Analyze' for comprehensive analysis<br><br>
        
        <b>Features:</b><br>
        â€¢ Postflop hand strength evaluation<br>
        â€¢ Board texture analysis<br>
        â€¢ Outs calculations<br>
        â€¢ Stage-specific strategy advice
        """)
        instructions.setStyleSheet("color: #ccc; padding: 20px; line-height: 1.6;")
        instructions.setWordWrap(True)
        
        self.analysis_layout.addWidget(welcome_label)
        self.analysis_layout.addWidget(instructions)
        self.analysis_layout.addStretch()
    
    def on_table_config_changed(self):
        checked_btn = self.table_size_group.checkedButton()
        if checked_btn:
            table_size = checked_btn.property("table_size")
            self.game_state.table_size = table_size
            self.update_game_state_display()
            
            if self.has_player_cards():
                self.analyze_situation()
    
    def on_cards_changed(self):
        board_cards = self.get_board_cards()
        self.game_state.board_cards = board_cards
        self.game_state.stage = self._determine_stage(board_cards)
        
        self.update_game_state_display()
        
        if self.has_player_cards():
            self.analysis_timer.stop()
            self.analysis_timer.start(300)
    
    def update_game_state_display(self):
        players_count = self.game_state.get_players_count()
        stage_name = self.game_state.stage.value
        board_count = len(self.game_state.board_cards)
        
        display_text = f"Ð¡Ñ‚Ð¾Ð»: {players_count} Ð¸Ð³Ñ€Ð¾ÐºÐ¾Ð² | Ð¡Ñ‚Ð°Ð´Ð¸Ñ: {stage_name} ({board_count} ÐºÐ°Ñ€Ñ‚)"
        self.game_state_label.setText(display_text)
    
    def has_player_cards(self) -> bool:
        card1 = self.card1_widget.get_text().strip()
        card2 = self.card2_widget.get_text().strip()
        return bool(card1 and card2)
    
    def get_player_cards(self) -> List[Card]:
        cards = []
        for widget in [self.card1_widget, self.card2_widget]:
            text = widget.get_text().strip()
            if text:
                card = Card.parse(text)
                if card:
                    cards.append(card)
        return cards
    
    def get_board_cards(self) -> List[Card]:
        cards = []
        for widget in [self.flop1_widget, self.flop2_widget, self.flop3_widget, 
                      self.turn_widget, self.river_widget]:
            text = widget.get_text().strip()
            if text:
                card = Card.parse(text)
                if card:
                    cards.append(card)
        return cards
    
    def _determine_stage(self, board_cards: List[Card]) -> GameStage:
        num_board = len(board_cards)
        stage_map = {
            0: GameStage.PREFLOP,
            3: GameStage.FLOP,
            4: GameStage.TURN,
            5: GameStage.RIVER
        }
        return stage_map.get(num_board, GameStage.PREFLOP)
    
    def select_roi(self):
        logger.info("ROI selection started")
        try:
            overlay = SelectionOverlay(self)
            overlay.show()
            
            result = overlay.exec()
            
            if result == overlay.DialogCode.Accepted:
                rect = overlay.selected_rect()
                
                if rect and rect.width() > 50 and rect.height() > 50:
                    self.roi = rect
                    self.save_roi()
                    self.capture_btn.setEnabled(True)
                    self.status_label.setText(
                        f"âœ… Selected area: {rect.width()}Ã—{rect.height()} at ({rect.x()}, {rect.y()})"
                    )
                    logger.info(f"ROI saved: {rect.width()}x{rect.height()}")
                else:
                    QMessageBox.warning(self, "Selection Too Small", 
                                      "Please select larger area (min 50Ã—50)")
            
        except Exception as e:
            logger.error(f"ROI selection error: {e}", exc_info=True)
            QMessageBox.critical(self, "Selection Error", f"Failed to select region: {e}")
    
    def capture_and_detect(self):
        if not self.roi:
            QMessageBox.warning(self, "No Area", "Please select capture area first")
            return
        
        self.status_label.setText("ðŸ“¸ Capturing and analyzing...")
        
        try:
            frame = self.screen_capture.grab_roi(self.roi)
            if frame is None:
                QMessageBox.warning(self, "Capture Failed", "Failed to capture screenshot")
                self.status_label.setText("âŒ Capture failed")
                return
            
            self.captured_frame = frame.copy()
            self.display_frame(frame)
            
            if self.ml_service.is_available:
                self.status_label.setText("ðŸ” Analyzing cards with ML...")
                self._detect_and_fill_cards(frame)
            else:
                self.status_label.setText("ðŸ“· Picture captured - ML not available, enter cards manually")
        
        except Exception as e:
            logger.error(f"Capture error: {e}", exc_info=True)
            QMessageBox.critical(self, "Capture Error", f"Failed to capture: {e}")
            self.status_label.setText("âŒ Capture error")
    
    def _detect_and_fill_cards(self, frame: np.ndarray):
        try:
            player_cards, board_cards = self.ml_service.detect_and_classify(frame, confidence_threshold=0.4)
            
            overlay_frame = frame.copy()
            
            for detection in player_cards:
                x1, y1, x2, y2 = detection.bbox
                cv2.rectangle(overlay_frame, (x1, y1), (x2, y2), (0, 255, 0), 2)
                cv2.putText(overlay_frame, f"P: {detection.classification}", (x1, y1-10),
                           cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0, 255, 0), 2)
            
            for detection in board_cards:
                x1, y1, x2, y2 = detection.bbox
                cv2.rectangle(overlay_frame, (x1, y1), (x2, y2), (255, 0, 0), 2)
                cv2.putText(overlay_frame, f"B: {detection.classification}", (x1, y1-10),
                           cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255, 0, 0), 2)
            
            self.display_frame(overlay_frame)
            
            if len(player_cards) >= 1:
                self.card1_widget.set_text(player_cards[0].classification or "")
            if len(player_cards) >= 2:
                self.card2_widget.set_text(player_cards[1].classification or "")
            
            board_widgets = [self.flop1_widget, self.flop2_widget, self.flop3_widget,
                           self.turn_widget, self.river_widget]
            
            for i, widget in enumerate(board_widgets):
                if i < len(board_cards):
                    widget.set_text(board_cards[i].classification or "")
                else:
                    widget.clear()
            
            if len(player_cards) >= 2:
                self.analyze_situation()
                self.status_label.setText(
                    f"âœ… Detected: {len(player_cards)} player, {len(board_cards)} board cards"
                )
            else:
                self.status_label.setText(
                    f"âš ï¸ Found {len(player_cards)} player cards - Complete manually"
                )
        
        except Exception as e:
            logger.error(f"Detection error: {e}", exc_info=True)
            self.status_label.setText(f"âŒ Detection error")
    
    def display_frame(self, frame: np.ndarray):
        try:
            if len(frame.shape) == 3:
                height, width, channel = frame.shape
                bytes_per_line = 3 * width
                q_image = QImage(frame.data, width, height, bytes_per_line, 
                               QImage.Format.Format_RGB888).rgbSwapped()
            else:
                height, width = frame.shape
                bytes_per_line = width
                q_image = QImage(frame.data, width, height, bytes_per_line, 
                               QImage.Format.Format_Grayscale8)
            
            pixmap = QPixmap.fromImage(q_image)
            scaled_pixmap = pixmap.scaled(
                self.image_label.size(),
                Qt.AspectRatioMode.KeepAspectRatio,
                Qt.TransformationMode.SmoothTransformation
            )
            self.image_label.setPixmap(scaled_pixmap)
        
        except Exception as e:
            logger.error(f"Display error: {e}")
    
    def analyze_situation(self):
        if not self.has_player_cards():
            QMessageBox.warning(self, "Input Error", "Please enter both player cards")
            return
        
        try:
            player_cards = self.get_player_cards()
            board_cards = self.get_board_cards()
            
            if len(player_cards) != 2:
                QMessageBox.warning(self, "Invalid Cards", "Please enter valid player cards")
                return
            
            self.game_state.player_cards = player_cards
            self.game_state.board_cards = board_cards
            self.game_state.stage = self._determine_stage(board_cards)
            
            self.update_game_state_display()
            
            analysis_result = self.analysis_service.analyze_hand(self.game_state)
            
            if "error" in analysis_result:
                QMessageBox.warning(self, "Analysis Error", analysis_result["error"])
            else:
                self._display_analysis_result(analysis_result)
            
            self.status_label.setText("âœ… Analysis complete")
        
        except Exception as e:
            logger.error(f"Analysis error: {e}", exc_info=True)
            QMessageBox.critical(self, "Analysis Error", f"Failed to analyze: {e}")
    
    def _display_analysis_result(self, result: dict):
        while self.analysis_layout.count():
            child = self.analysis_layout.takeAt(0)
            if child.widget():
                child.widget().deleteLater()
        
        stage = result.get("stage", "")
        
        cards_display = " ".join(str(c) for c in self.game_state.player_cards)
        board_display = " ".join(str(c) for c in self.game_state.board_cards) if self.game_state.board_cards else "No board"
        
        title = QLabel(f"ÐÐ½Ð°Ð»Ð¸Ð· - {stage}")
        title.setStyleSheet("font-size: 20px; font-weight: bold; color: #4CAF50; padding: 10px;")
        
        cards_label = QLabel(f"Player: {cards_display} | Board: {board_display}")
        cards_label.setStyleSheet("font-size: 16px; color: #81C784; padding: 8px; font-weight: bold;")
        
        self.analysis_layout.addWidget(title)
        self.analysis_layout.addWidget(cards_label)
        
        if "current_hand" in result:
            strength_group = QGroupBox("ÐÐ½Ð°Ð»Ð¸Ð· Ñ€ÑƒÐºÐ¸")
            strength_layout = QVBoxLayout(strength_group)
            
            current_hand_label = QLabel(f"Ð¢ÐµÐºÑƒÑ‰Ð°Ñ ÐºÐ¾Ð¼Ð±Ð¸Ð½Ð°Ñ†Ð¸Ñ: {result['current_hand']}")
            current_hand_label.setStyleSheet("font-size: 16px; color: #fff; padding: 8px; font-weight: bold;")
            strength_layout.addWidget(current_hand_label)
            
            outs_data = result.get("outs_analysis", {})
            total_outs = result.get("total_outs", 0)
            
            if total_outs >= 0:
                outs_text = f"ðŸŽ¯ ÐÐÐÐ›Ð˜Ð— ÐÐ£Ð¢ÐžÐ’:\n"
                outs_text += f"â€¢ Ð¤Ð»ÐµÑˆ: {outs_data.get('flush', 0)} Ð°ÑƒÑ‚Ð¾Ð²\n"
                outs_text += f"â€¢ Ð¡Ñ‚Ñ€Ð¸Ñ‚: {outs_data.get('straight', 0)} Ð°ÑƒÑ‚Ð¾Ð²\n"
                outs_text += f"â€¢ Ð¡ÐµÑ‚/Ð¢Ñ€Ð¸Ð¿Ñ: {outs_data.get('set_trips', 0)} Ð°ÑƒÑ‚Ð¾Ð²\n"
                outs_text += f"â€¢ ÐžÐ²ÐµÑ€ÐºÐ°Ñ€Ñ‚Ñ‹: {outs_data.get('overcard', 0)} Ð°ÑƒÑ‚Ð¾Ð²\n"
                outs_text += f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
                outs_text += f"ðŸ“Š Ð’Ð¡Ð•Ð“Ðž ÐÐ£Ð¢ÐžÐ’: {total_outs}\n\n"
                
                cards_to_come = 5 - len(self.game_state.board_cards)
                if cards_to_come == 2:
                    improvement_equity = min(total_outs * 4, 100)
                    stage_text = "Ð´Ð¾ Ñ€Ð¸Ð²ÐµÑ€Ð°"
                elif cards_to_come == 1:
                    improvement_equity = min(total_outs * 2, 100)
                    stage_text = "Ð½Ð° Ñ€Ð¸Ð²ÐµÑ€Ðµ"
                else:
                    improvement_equity = 0
                    stage_text = "Ð·Ð°Ð²ÐµÑ€ÑˆÐµÐ½"
                
                outs_text += f"ðŸ“ˆ Ð¨Ð°Ð½Ñ ÑƒÐ»ÑƒÑ‡ÑˆÐµÐ½Ð¸Ñ {stage_text}: {improvement_equity:.2f}%\n"
                
                equity = result.get("equity", {})
                if "win_rate" in equity and not equity.get("error"):
                    outs_text += f"\nðŸ† Ð’Ð•Ð ÐžÐ¯Ð¢ÐÐžÐ¡Ð¢Ð¬ ÐŸÐžÐ‘Ð•Ð”Ð«:\n"
                    outs_text += f"â€¢ ÐŸÐ¾Ð±ÐµÐ´Ð°: {equity.get('win_rate', 0):.2f}%\n"
                    outs_text += f"â€¢ ÐÐ¸Ñ‡ÑŒÑ: {equity.get('tie_rate', 0):.2f}%\n"
                    outs_text += f"â€¢ ÐŸÐ¾Ñ€Ð°Ð¶ÐµÐ½Ð¸Ðµ: {equity.get('lose_rate', 0):.2f}%"
            else:
                outs_text = "âŒ Ð—Ð½Ð°Ñ‡Ð¸Ð¼Ñ‹Ñ… Ð´Ñ€Ð¾ Ð½Ðµ Ð¾Ð±Ð½Ð°Ñ€ÑƒÐ¶ÐµÐ½Ð¾"
            
            outs_label = QLabel(outs_text)
            outs_label.setStyleSheet("font-size: 14px; color: #ccc; padding: 8px; font-family: 'Consolas';")
            outs_label.setWordWrap(True)
            strength_layout.addWidget(outs_label)
            
            self.analysis_layout.addWidget(strength_group)
        
        texture = result.get("board_texture", {})
        if texture and "error" not in texture:
            texture_group = QGroupBox("Ð¢ÐµÐºÑÑ‚ÑƒÑ€Ð° Ð´Ð¾ÑÐºÐ¸")
            texture_layout = QVBoxLayout(texture_group)
            
            features = []
            if texture.get('monotone'):
                features.append("ðŸ”´ ÐœÐ¾Ð½Ð¾Ñ‚Ð¾Ð½")
            elif texture.get('two_tone'):
                features.append("ðŸŸ¡ Ð”Ð²ÑƒÑ…Ñ†Ð²ÐµÑ‚Ð½Ð°Ñ")
            elif texture.get('rainbow'):
                features.append("ðŸŒˆ Ð Ð°Ð´ÑƒÐ¶Ð½Ð°Ñ")
            
            if texture.get('paired'):
                features.append("ðŸ‘¥ Ð¡Ð¿Ð°Ñ€ÐµÐ½Ð½Ð°Ñ")
            
            if texture.get('coordinated'):
                features.append("ðŸ”— Ð¡ÐºÐ¾Ð¾Ñ€Ð´Ð¸Ð½Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð½Ð°Ñ")
            elif texture.get('dry'):
                features.append("ðŸœï¸ Ð¡ÑƒÑ…Ð°Ñ")
            
            if texture.get('flush_draw'):
                features.append("ðŸ’§ Ð¤Ð»ÐµÑˆ-Ð´Ñ€Ð¾")
            
            texture_text = "Ð¥Ð°Ñ€Ð°ÐºÑ‚ÐµÑ€Ð¸ÑÑ‚Ð¸ÐºÐ¸:\n" + "\n".join(f"â€¢ {f}" for f in features) if features else "Ð¡Ñ‚Ð°Ð½Ð´Ð°Ñ€Ñ‚Ð½Ð°Ñ"
            
            texture_label = QLabel(texture_text)
            texture_label.setStyleSheet("font-size: 14px; color: #ccc; padding: 8px;")
            texture_label.setWordWrap(True)
            texture_layout.addWidget(texture_label)
            
            self.analysis_layout.addWidget(texture_group)
        
        strategy = result.get("strategy_recommendation", "")
        if strategy:
            recommendations_group = QGroupBox("ABC Ð ÐµÐºÐ¾Ð¼ÐµÐ½Ð´Ð°Ñ†Ð¸Ð¸")
            recommendations_layout = QVBoxLayout(recommendations_group)
            
            strategy_label = QLabel(f"ðŸŽ¯ {strategy}")
            strategy_label.setStyleSheet("""
                font-size: 16px; color: #FFD700; padding: 15px; font-weight: bold; 
                border: 2px solid #FFD700; border-radius: 8px; background-color: rgba(255, 215, 0, 0.1);
            """)
            strategy_label.setWordWrap(True)
            recommendations_layout.addWidget(strategy_label)
            
            self.analysis_layout.addWidget(recommendations_group)
        
        self.analysis_layout.addStretch()
    
    def save_roi(self):
        if self.roi:
            roi_data = [self.roi.x(), self.roi.y(), self.roi.width(), self.roi.height()]
            config_data = {"roi": roi_data}
            try:
                config_file = Path(__file__).parent.parent.parent / "gui_config.json"
                with open(config_file, 'w') as f:
                    json.dump(config_data, f, indent=2)
                logger.info(f"ROI saved: {roi_data}")
            except Exception as e:
                logger.error(f"Failed to save ROI: {e}")
    
    def load_roi(self):
        config_file = Path(__file__).parent.parent.parent / "gui_config.json"
        if config_file.exists():
            try:
                with open(config_file, 'r') as f:
                    data = json.load(f)
                roi_data = data.get('roi')
                if roi_data and len(roi_data) == 4:
                    self.roi = QRect(*roi_data)
                    self.capture_btn.setEnabled(True)
                    self.status_label.setText(f"ðŸ“ Loaded saved area: {roi_data[2]}Ã—{roi_data[3]}")
            except Exception as e:
                logger.warning(f"Failed to load ROI: {e}")
    
    def clear_all_inputs(self):
        """Clear all card input widgets"""
        self.card1_widget.clear()
        self.card2_widget.clear()
        self.flop1_widget.clear()
        self.flop2_widget.clear()
        self.flop3_widget.clear()
        self.turn_widget.clear()
        self.river_widget.clear()
        
        self.game_state.player_cards = []
        self.game_state.board_cards = []
        self.game_state.stage = GameStage.PREFLOP
        
        self.update_game_state_display()
        self.create_default_analysis()
        self.status_label.setText("ðŸ”„ All inputs cleared")
        logger.info("All inputs cleared")

    def _on_hotkey_opponent_select(self, number: int):
        """Handle numpad hotkey for opponent selection"""
        logger.info(f"HANDLER: Setting {number} opponents via hotkey")
        
        try:
            # ÐŸÑ€ÑÐ¼Ð°Ñ ÑƒÑÑ‚Ð°Ð½Ð¾Ð²ÐºÐ° Ñ‡ÐµÑ€ÐµÐ· game_state
            if hasattr(self, 'game_state'):
                old_val = self.game_state.num_opponents
                self.game_state.num_opponents = number
                logger.info(f"HANDLER: SUCCESS! Set game_state.num_opponents: {old_val} -> {number}")
                
                # ÐŸÑ€Ð¸Ð½ÑƒÐ´Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ð¾ Ð²Ñ‹Ð·Ñ‹Ð²Ð°ÐµÐ¼ Ð¾Ð±Ð½Ð¾Ð²Ð»ÐµÐ½Ð¸Ðµ UI
                if hasattr(self, 'on_table_size_changed'):
                    self.on_table_size_changed()
                    logger.info("HANDLER: Called on_table_size_changed()")
                
                # ÐžÐ±Ð½Ð¾Ð²Ð»ÑÐµÐ¼ Ð¾Ñ‚Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½Ð¸Ðµ ÑÐ¾ÑÑ‚Ð¾ÑÐ½Ð¸Ñ Ð¸Ð³Ñ€Ñ‹
                if hasattr(self, 'update_game_state_display'):
                    self.update_game_state_display()
                    logger.info("HANDLER: Called update_game_state_display()")
                
                # Ð•ÑÐ»Ð¸ ÐµÑÑ‚ÑŒ Ð¼ÐµÑ‚Ð¾Ð´ analyze_situation - Ð²Ñ‹Ð·Ñ‹Ð²Ð°ÐµÐ¼ Ð´Ð»Ñ Ð¿ÐµÑ€ÐµÑÑ‡Ñ‘Ñ‚Ð°
                if hasattr(self, 'analyze_situation'):
                    self.analyze_situation()
                    logger.info("HANDLER: Called analyze_situation()")
                
                return
            
            logger.error("HANDLER: game_state not found!")
            
        except Exception as e:
            logger.error(f"HANDLER: Exception: {e}", exc_info=True)


    def _on_hotkey_capture(self):
        """Handle Enter hotkey for capture"""
        logger.info("HANDLER: Capture hotkey pressed")
        
        try:
            from PySide6.QtWidgets import QPushButton
            
            # Ð’Ð°Ñ€Ð¸Ð°Ð½Ñ‚ 1: capture_action
            if hasattr(self, 'capture_action'):
                logger.info("HANDLER: Found capture_action")
                self.capture_action.trigger()
                logger.info("HANDLER: SUCCESS! capture_action triggered")
                return
            
            # Ð’Ð°Ñ€Ð¸Ð°Ð½Ñ‚ 2: capture_and_detect Ð¼ÐµÑ‚Ð¾Ð´
            if hasattr(self, 'capture_and_detect'):
                logger.info("HANDLER: Found capture_and_detect method")
                self.capture_and_detect()
                logger.info("HANDLER: SUCCESS! capture_and_detect called")
                return
            
            # Ð’Ð°Ñ€Ð¸Ð°Ð½Ñ‚ 3: select_roi Ð¼ÐµÑ‚Ð¾Ð´
            if hasattr(self, 'select_roi'):
                logger.info("HANDLER: Found select_roi method")
                self.select_roi()
                logger.info("HANDLER: SUCCESS! select_roi called")
                return
            
            # Ð’Ð°Ñ€Ð¸Ð°Ð½Ñ‚ 4: Ð¿Ð¾Ð¸ÑÐº ÐºÐ½Ð¾Ð¿ÐºÐ¸
            all_buttons = self.findChildren(QPushButton)
            logger.info(f"HANDLER: Searching through {len(all_buttons)} buttons")
            
            for btn in all_buttons:
                btn_text = btn.text().lower()
                btn_name = btn.objectName().lower()
                
                if ('capture' in btn_text or 'capture' in btn_name or 
                    'grab' in btn_text or 'screen' in btn_text):
                    logger.info(f"HANDLER: Found button: '{btn.text()}' ({btn.objectName()})")
                    if btn.isEnabled():
                        btn.click()
                        logger.info("HANDLER: SUCCESS! Button clicked")
                        return
            
            logger.error("HANDLER: Could not trigger capture!")
            
        except Exception as e:
            logger.error(f"HANDLER: Exception: {e}", exc_info=True)   

    def closeEvent(self, event):
        logger.info("Application closing")
        event.accept()







==========================
init.py(utils)
==========================




"""Utils package"""
from .screen_capture import ScreenCapture

__all__ = ['ScreenCapture']





==========================
hwid_generator.py
==========================




import hashlib
import platform
import subprocess
import uuid
import re
from typing import Optional

class HWIDGenerator:
    """Ð“ÐµÐ½ÐµÑ€Ð°Ñ‚Ð¾Ñ€ ÑƒÑÑ‚Ð¾Ð¹Ñ‡Ð¸Ð²Ð¾Ð³Ð¾ HWID Ð½Ð° Ð¾ÑÐ½Ð¾Ð²Ðµ Ñ…Ð°Ñ€Ð°ÐºÑ‚ÐµÑ€Ð¸ÑÑ‚Ð¸Ðº Ð¾Ð±Ð¾Ñ€ÑƒÐ´Ð¾Ð²Ð°Ð½Ð¸Ñ"""
    
    @staticmethod
    def get_system_disk_serial() -> str:
        """ÐŸÐ¾Ð»ÑƒÑ‡ÐµÐ½Ð¸Ðµ ÑÐµÑ€Ð¸Ð¹Ð½Ð¾Ð³Ð¾ Ð½Ð¾Ð¼ÐµÑ€Ð° ÑÐ¸ÑÑ‚ÐµÐ¼Ð½Ð¾Ð³Ð¾ Ð´Ð¸ÑÐºÐ°"""
        try:
            if platform.system() == 'Windows':
                # Windows - Ñ‡ÐµÑ€ÐµÐ· WMI
                result = subprocess.run(['wmic', 'diskdrive', 'get', 'serialnumber'], 
                                      capture_output=True, text=True)
                lines = result.stdout.strip().split('\n')
                for line in lines[1:]:  # ÐŸÑ€Ð¾Ð¿ÑƒÑÐºÐ°ÐµÐ¼ Ð·Ð°Ð³Ð¾Ð»Ð¾Ð²Ð¾Ðº
                    serial = line.strip()
                    if serial and serial != 'SerialNumber':
                        return serial
            else:
                # Linux/Mac - Ñ‡ÐµÑ€ÐµÐ· lsblk Ð¸Ð»Ð¸ diskutil
                result = subprocess.run(['lsblk', '-o', 'SERIAL', '-n'], 
                                      capture_output=True, text=True)
                if result.stdout:
                    serials = [s.strip() for s in result.stdout.split('\n') if s.strip()]
                    if serials:
                        return serials[0]
        except Exception:
            pass
        return "UNKNOWN_DISK_SERIAL"
    
    @staticmethod
    def get_cpu_id() -> str:
        """ÐŸÐ¾Ð»ÑƒÑ‡ÐµÐ½Ð¸Ðµ ID Ð¿Ñ€Ð¾Ñ†ÐµÑÑÐ¾Ñ€Ð°"""
        try:
            if platform.system() == 'Windows':
                result = subprocess.run(['wmic', 'cpu', 'get', 'processorid'], 
                                      capture_output=True, text=True)
                lines = result.stdout.strip().split('\n')
                for line in lines[1:]:
                    cpu_id = line.strip()
                    if cpu_id and cpu_id != 'ProcessorId':
                        return cpu_id
            else:
                # Linux - Ñ‡ÐµÑ€ÐµÐ· /proc/cpuinfo
                with open('/proc/cpuinfo', 'r') as f:
                    for line in f:
                        if 'processor' in line.lower():
                            return line.split(':')[1].strip()
        except Exception:
            pass
        return "UNKNOWN_CPU_ID"
    
    @staticmethod
    def get_primary_mac() -> str:
        """ÐŸÐ¾Ð»ÑƒÑ‡ÐµÐ½Ð¸Ðµ MAC-Ð°Ð´Ñ€ÐµÑÐ° Ð¾ÑÐ½Ð¾Ð²Ð½Ð¾Ð³Ð¾ ÑÐµÑ‚ÐµÐ²Ð¾Ð³Ð¾ Ð¸Ð½Ñ‚ÐµÑ€Ñ„ÐµÐ¹ÑÐ°"""
        try:
            # ÐŸÐ¾Ð»ÑƒÑ‡Ð°ÐµÐ¼ MAC-Ð°Ð´Ñ€ÐµÑ Ñ‡ÐµÑ€ÐµÐ· uuid
            mac = ':'.join(re.findall('..', '%012x' % uuid.getnode()))
            return mac
        except Exception:
            return "UNKNOWN_MAC_ADDRESS"
    
    @staticmethod
    def get_motherboard_serial() -> str:
        """ÐŸÐ¾Ð»ÑƒÑ‡ÐµÐ½Ð¸Ðµ ÑÐµÑ€Ð¸Ð¹Ð½Ð¾Ð³Ð¾ Ð½Ð¾Ð¼ÐµÑ€Ð° Ð¼Ð°Ñ‚ÐµÑ€Ð¸Ð½ÑÐºÐ¾Ð¹ Ð¿Ð»Ð°Ñ‚Ñ‹"""
        try:
            if platform.system() == 'Windows':
                result = subprocess.run(['wmic', 'baseboard', 'get', 'serialnumber'], 
                                      capture_output=True, text=True)
                lines = result.stdout.strip().split('\n')
                for line in lines[1:]:
                    serial = line.strip()
                    if serial and serial != 'SerialNumber':
                        return serial
            else:
                # Linux - Ñ‡ÐµÑ€ÐµÐ· dmidecode
                result = subprocess.run(['dmidecode', '-s', 'baseboard-serial-number'], 
                                      capture_output=True, text=True)
                if result.stdout:
                    return result.stdout.strip()
        except Exception:
            pass
        return "UNKNOWN_MOTHERBOARD"
    
    @staticmethod
    def get_bios_serial() -> str:
        """ÐŸÐ¾Ð»ÑƒÑ‡ÐµÐ½Ð¸Ðµ ÑÐµÑ€Ð¸Ð¹Ð½Ð¾Ð³Ð¾ Ð½Ð¾Ð¼ÐµÑ€Ð° BIOS"""
        try:
            if platform.system() == 'Windows':
                result = subprocess.run(['wmic', 'bios', 'get', 'serialnumber'], 
                                      capture_output=True, text=True)
                lines = result.stdout.strip().split('\n')
                for line in lines[1:]:
                    serial = line.strip()
                    if serial and serial != 'SerialNumber':
                        return serial
            else:
                result = subprocess.run(['dmidecode', '-s', 'bios-serial-number'], 
                                      capture_output=True, text=True)
                if result.stdout:
                    return result.stdout.strip()
        except Exception:
            pass
        return "UNKNOWN_BIOS"
    
    @classmethod
    def generate_hwid(cls) -> str:
        """Ð“ÐµÐ½ÐµÑ€Ð°Ñ†Ð¸Ñ ÑƒÑÑ‚Ð¾Ð¹Ñ‡Ð¸Ð²Ð¾Ð³Ð¾ HWID"""
        # Ð¡Ð¾Ð±Ð¸Ñ€Ð°ÐµÐ¼ Ð²ÑÐµ Ð¸Ð´ÐµÐ½Ñ‚Ð¸Ñ„Ð¸ÐºÐ°Ñ‚Ð¾Ñ€Ñ‹
        components = [
            cls.get_system_disk_serial(),
            cls.get_cpu_id(),
            cls.get_primary_mac(),
            cls.get_motherboard_serial(),
            cls.get_bios_serial(),
            platform.machine(),
            platform.system(),
            "qpkeo2k2ok2kmdk123PENISd2"
        ]
        
        # ÐžÐ±ÑŠÐµÐ´Ð¸Ð½ÑÐµÐ¼ Ð¸ Ñ…ÐµÑˆÐ¸Ñ€ÑƒÐµÐ¼
        combined_string = "|".join(components)
        hwid_hash = hashlib.sha256(combined_string.encode('utf-8')).hexdigest()
        
        # Ð¤Ð¾Ñ€Ð¼Ð°Ñ‚Ð¸Ñ€ÑƒÐµÐ¼ Ð² Ð²Ð¸Ð´Ðµ Ð³Ñ€ÑƒÐ¿Ð¿ Ð¿Ð¾ 8 ÑÐ¸Ð¼Ð²Ð¾Ð»Ð¾Ð²
        formatted_hwid = '-'.join([hwid_hash[i:i+8].upper() for i in range(0, 32, 8)])
        
        return formatted_hwid





==========================
licencs_client.py
==========================




import requests
import json
import time
import hmac
import hashlib
import random
import string
import logging
from typing import Optional, Dict, Any
from datetime import datetime
import ssl
import socket
import urllib3
from urllib.parse import urlparse

logger = logging.getLogger(__name__)

class LicenseClient:
    def __init__(self, api_base_url: str, hmac_secret_key: str, hwid: str):
        self.api_base_url = "https://185.221.196.69:8000/api/v1/"
        self.hmac_secret_key = hmac_secret_key  
        self.hwid = hwid
        self.last_check = None
        self.expected_cert_fingerprint = None  # Ð‘ÑƒÐ´ÐµÑ‚ ÑƒÑÑ‚Ð°Ð½Ð¾Ð²Ð»ÐµÐ½ Ð¿Ñ€Ð¸ Ð¿ÐµÑ€Ð²Ð¾Ð¼ Ð¿Ð¾Ð´ÐºÐ»ÑŽÑ‡ÐµÐ½Ð¸Ð¸
        self.ssl_verification_enabled = True
        
    def _generate_hmac_signature(self, data: str) -> str:
        """Ð“ÐµÐ½ÐµÑ€Ð°Ñ†Ð¸Ñ HMAC-SHA256 Ð¿Ð¾Ð´Ð¿Ð¸ÑÐ¸ Ð´Ð»Ñ Ð´Ð°Ð½Ð½Ñ‹Ñ…"""
        import hmac
        secret_key = "28de6a1eb3b9e9edb29c886a43d71964935bd12cb981cc2e604381076d73f6660fdca0a6092ee4b055882859563e7c373472d01d28d0e91cefa810bc1106c572"  # Ð¢Ð¾Ñ‚ Ð¶Ðµ ÐºÐ»ÑŽÑ‡ Ñ‡Ñ‚Ð¾ Ð½Ð° ÑÐµÑ€Ð²ÐµÑ€Ðµ
        return hmac.new(
            secret_key.encode('utf-8'),
            data.encode('utf-8'),
            hashlib.sha256
        ).hexdigest()

    
    def _generate_nonce(self, length=8) -> str:
        """Ð“ÐµÐ½ÐµÑ€Ð°Ñ†Ð¸Ñ ÑÐ»ÑƒÑ‡Ð°Ð¹Ð½Ð¾Ð³Ð¾ nonce"""
        return ''.join(random.choices(string.ascii_letters + string.digits, k=length))
    
    def _make_request(self, endpoint: str, data: Dict[Any, Any]) -> Optional[Dict[Any, Any]]:
        """HMAC Ð·Ð°Ð¿Ñ€Ð¾Ñ Ñ SSL Pinning Ð¿Ñ€Ð¾Ð²ÐµÑ€ÐºÐ¾Ð¹"""
        try:
            url = f"{self.api_base_url}{endpoint}"
            
            # SSL Pinning Ð¿Ñ€Ð¾Ð²ÐµÑ€ÐºÐ° Ð¿ÐµÑ€ÐµÐ´ Ð·Ð°Ð¿Ñ€Ð¾ÑÐ¾Ð¼
            if not self.verify_ssl_certificate(url):
                logger.error("SSL Pinning verification failed - aborting request")
                return None
                
            json_data = json.dumps(data)
            signature = self._generate_hmac_signature(json_data)
            
            headers = {
                "Content-Type": "application/json",
                "X-Signature": signature
            }
            
            response = requests.post(url, data=json_data, headers=headers, timeout=10, verify=False)
            
            if response.status_code == 200:
                return response.json()
            elif response.status_code in [400, 401, 404]:
                logger.error(f"API request failed: {response.status_code} - {response.text}")
                return {"is_active": False}
            else:
                logger.error(f"API request failed: {response.status_code} - {response.text}")
                return None
                
        except requests.exceptions.ConnectionError as e:
            logger.error(f"Connection error: {e}")
            return None
        except requests.exceptions.Timeout as e:
            logger.error(f"Timeout error: {e}")
            return None
        except Exception as e:
            logger.error(f"Unexpected error during license check: {e}")
            return None

    
    def check_license(self) -> bool:
        """ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ° Ð»Ð¸Ñ†ÐµÐ½Ð·Ð¸Ð¸ ÑÐ¾Ð³Ð»Ð°ÑÐ½Ð¾ Ð¢Ð—"""
        request_data = {
            "hwid": self.hwid,
            "timestamp": int(time.time()),
            "nonce": self._generate_nonce()
        }
        
        result = self._make_request("license/check", request_data)
        
        if result is not None:
            # Ð¡ÐµÑ€Ð²ÐµÑ€ Ð¾Ñ‚Ð²ÐµÑ‚Ð¸Ð» (ÑƒÑÐ¿ÐµÑˆÐ½Ð¾ Ð¸Ð»Ð¸ Ñ Ð¾ÑˆÐ¸Ð±ÐºÐ¾Ð¹ Ð»Ð¸Ñ†ÐµÐ½Ð·Ð¸Ð¸)
            self.last_check = datetime.now()
            
            # ÐŸÑ€Ð¾Ð²ÐµÑ€ÑÐµÐ¼ Ð¿Ð¾Ð´Ð¿Ð¸ÑÑŒ Ð¾Ñ‚Ð²ÐµÑ‚Ð° Ð´Ð»Ñ Ð´Ð¾Ð¿Ð¾Ð»Ð½Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ð¾Ð¹ Ð±ÐµÐ·Ð¾Ð¿Ð°ÑÐ½Ð¾ÑÑ‚Ð¸
            response_copy = result.copy()
            signature = response_copy.pop('signature', '')
            response_json = json.dumps(response_copy, sort_keys=True)
            expected_signature = self._generate_hmac_signature(response_json)
            
            if signature != expected_signature:
                logger.error("Invalid response signature from server")
                return False
            
            # ÐšÐ›Ð®Ð§Ð•Ð’ÐžÐ• Ð˜Ð—ÐœÐ•ÐÐ•ÐÐ˜Ð•: Ð²Ð¾Ð·Ð²Ñ€Ð°Ñ‰Ð°ÐµÐ¼ Ñ‚Ð¾Ñ‡Ð½Ñ‹Ð¹ ÑÑ‚Ð°Ñ‚ÑƒÑ Ð¸Ð· Ð‘Ð”
            is_active = result.get('is_active', False)
            logger.info(f"Server responded: is_active={is_active}")
            return is_active
            
        else:
            # Ð¢ÐžÐ›Ð¬ÐšÐž Ð·Ð´ÐµÑÑŒ Ð²ÐºÐ»ÑŽÑ‡Ð°ÐµÐ¼ Grace Period - ÐºÐ¾Ð³Ð´Ð° ÑÐµÑ€Ð²ÐµÑ€ ÐÐ•Ð”ÐžÐ¡Ð¢Ð£ÐŸÐ•Ð
            logger.error("License check failed - no server response")
            return False 

    
    def get_license_info(self) -> Optional[Dict[Any, Any]]:
        """ÐŸÐ¾Ð»ÑƒÑ‡ÐµÐ½Ð¸Ðµ Ð´ÐµÑ‚Ð°Ð»ÑŒÐ½Ð¾Ð¹ Ð¸Ð½Ñ„Ð¾Ñ€Ð¼Ð°Ñ†Ð¸Ð¸ Ð¾ Ð»Ð¸Ñ†ÐµÐ½Ð·Ð¸Ð¸"""
        request_data = {
            "hwid": self.hwid,
            "timestamp": int(time.time()),
            "nonce": self._generate_nonce()
        }
        
        return self._make_request("license/info", request_data)
    
    def get_certificate_fingerprint(self, hostname: str, port: int = 443) -> Optional[str]:
        """ÐŸÐ¾Ð»ÑƒÑ‡Ð¸Ñ‚ÑŒ SHA-256 Ð¾Ñ‚Ð¿ÐµÑ‡Ð°Ñ‚Ð¾Ðº SSL ÑÐµÑ€Ñ‚Ð¸Ñ„Ð¸ÐºÐ°Ñ‚Ð° ÑÐµÑ€Ð²ÐµÑ€Ð°"""
        try:
            context = ssl.create_default_context()
            context.check_hostname = False
            context.verify_mode = ssl.CERT_NONE
            
            with socket.create_connection((hostname, port), timeout=10) as sock:
                with context.wrap_socket(sock, server_hostname=hostname) as ssock:
                    cert_der = ssock.getpeercert(True)
                    fingerprint = hashlib.sha256(cert_der).hexdigest()
                    logger.info(f"Certificate fingerprint: {fingerprint}")
                    return fingerprint
        except Exception as e:
            logger.error(f"Failed to get certificate fingerprint: {e}")
            return None

    def verify_ssl_certificate(self, url: str) -> bool:
        """ÐŸÑ€Ð¾Ð²ÐµÑ€Ð¸Ñ‚ÑŒ SSL ÑÐµÑ€Ñ‚Ð¸Ñ„Ð¸ÐºÐ°Ñ‚ ÑÐ¾Ð³Ð»Ð°ÑÐ½Ð¾ SSL pinning"""
        if not self.ssl_verification_enabled:
            return True
            
        parsed_url = urlparse(url)
        hostname = parsed_url.hostname
        port = parsed_url.port or (443 if parsed_url.scheme == 'https' else 80)
        
        current_fingerprint = self.get_certificate_fingerprint(hostname, port)
        if not current_fingerprint:
            logger.error("Could not retrieve certificate fingerprint")
            return False
        
        if not self.expected_cert_fingerprint:
            # ÐŸÑ€Ð¸ Ð¿ÐµÑ€Ð²Ð¾Ð¼ Ð¿Ð¾Ð´ÐºÐ»ÑŽÑ‡ÐµÐ½Ð¸Ð¸ ÑÐ¾Ñ…Ñ€Ð°Ð½Ð¸Ñ‚ÑŒ Ð¾Ñ‚Ð¿ÐµÑ‡Ð°Ñ‚Ð¾Ðº
            self.expected_cert_fingerprint = current_fingerprint
            logger.info("SSL pinning: Saved certificate fingerprint for future verification")
            return True
        
        if current_fingerprint != self.expected_cert_fingerprint:
            logger.error("SSL PINNING VIOLATION: Certificate fingerprint mismatch!")
            logger.error(f"Expected: {self.expected_cert_fingerprint}")
            logger.error(f"Received: {current_fingerprint}")
            return False
        
        logger.info("SSL pinning: Certificate verified successfully")
        return True






==========================
screen_capture.py
==========================




import platform
import tempfile
import subprocess
import os
import logging
import cv2
import numpy as np
from typing import Optional
from PySide6.QtCore import QRect
from PySide6.QtGui import QGuiApplication


# Ð£ÑÐ»Ð¾Ð²Ð½Ñ‹Ðµ Ð¸Ð¼Ð¿Ð¾Ñ€Ñ‚Ñ‹ Ñ Ñ„Ð»Ð°Ð³Ð°Ð¼Ð¸ Ð´Ð¾ÑÑ‚ÑƒÐ¿Ð½Ð¾ÑÑ‚Ð¸
HAS_PYAUTOGUI = False
HAS_PIL = False
HAS_MSS = False

try:
    import pyautogui
    HAS_PYAUTOGUI = True
except ImportError:
    pyautogui = None
    
try:
    from PIL import ImageGrab
    HAS_PIL = True
except ImportError:
    ImageGrab = None
    
try:
    import mss
    HAS_MSS = True
except ImportError:
    mss = None

logger = logging.getLogger(__name__)


class ScreenCapture:
    """Cross-platform screen capture with Windows DPI fixes"""
    
    def __init__(self):
        self.os_type = platform.system()
        logger.info(f"ScreenCapture: Initializing for {self.os_type}")
        
        if self.os_type == "Windows":
            try:
                import ctypes
                ctypes.windll.shcore.SetProcessDpiAwareness(2)
                logger.info("ScreenCapture: Windows DPI awareness enabled")
            except Exception as e:
                logger.warning(f"ScreenCapture: Could not set DPI awareness: {e}")
        
        logger.info(f"ScreenCapture: Available libraries - MSS: {HAS_MSS}, PIL: {HAS_PIL}, PyAutoGUI: {HAS_PYAUTOGUI}")
    
    def grab_roi(self, roi: QRect) -> Optional[np.ndarray]:
        """Capture screen region"""
        if roi is None or roi.width() <= 0 or roi.height() <= 0:
            logger.error(f"ScreenCapture: Invalid ROI: {roi}")
            return None
        
        logger.info(f"ScreenCapture: Capturing {roi.width()}x{roi.height()} at ({roi.x()}, {roi.y()})")
        
        if self.os_type == "Windows":
            return self._capture_windows(roi)
        elif self.os_type == "Linux":
            return self._capture_linux(roi)
        elif self.os_type == "Darwin":
            return self._capture_macos(roi)
        else:
            logger.error(f"ScreenCapture: Unsupported OS: {self.os_type}")
            return None
    
    def _to_physical_rect(self, roi: QRect) -> QRect:
        """Convert Qt logical coordinates to physical pixels"""
        try:
            center = roi.center()
            screen = QGuiApplication.screenAt(center) or QGuiApplication.primaryScreen()
            ratio = screen.devicePixelRatio() if screen else 1.0
            
            if ratio <= 0:
                ratio = 1.0
            
            phys_rect = QRect(
                int(roi.x() * ratio),
                int(roi.y() * ratio),
                int(roi.width() * ratio),
                int(roi.height() * ratio)
            )
            
            logger.info(f"  DPI ratio: {ratio:.3f}, Physical: {phys_rect.width()}x{phys_rect.height()}")
            return phys_rect
            
        except Exception as e:
            logger.error(f"ScreenCapture: DPI conversion failed: {e}")
            return roi
    
    def _capture_windows(self, roi: QRect) -> Optional[np.ndarray]:
        """Windows capture with DPI handling - FIXED: proper None checking"""
        phys = self._to_physical_rect(roi)
        
        # Try capture methods in order - FIXED: check for None explicitly
        frame = self._capture_mss(phys)
        if frame is not None:
            return frame
        
        frame = self._capture_pil(phys)
        if frame is not None:
            return frame
        
        frame = self._capture_pyautogui(phys)
        if frame is not None:
            return frame
        
        logger.error("ScreenCapture: All capture methods failed")
        return None
    
    def _capture_mss(self, phys: QRect) -> Optional[np.ndarray]:
        """MSS capture"""
        if not HAS_MSS:
            return None
            
        try:
            with mss.mss() as sct:
                monitor = {"left": phys.x(), "top": phys.y(), "width": phys.width(), "height": phys.height()}
                shot = sct.grab(monitor)
                frame = cv2.cvtColor(np.array(shot), cv2.COLOR_BGRA2BGR)
                logger.info(f"ScreenCapture: MSS capture successful - {frame.shape}")
                return frame
        except Exception as e:
            logger.error(f"ScreenCapture: MSS failed: {e}")
        return None
    
    def _capture_pil(self, phys: QRect) -> Optional[np.ndarray]:
        """PIL capture"""
        if not HAS_PIL:
            return None
            
        try:
            bbox = (phys.x(), phys.y(), phys.x() + phys.width(), phys.y() + phys.height())
            img = ImageGrab.grab(bbox=bbox, all_screens=True)
            if img:
                frame = cv2.cvtColor(np.array(img), cv2.COLOR_RGB2BGR)
                logger.info(f"ScreenCapture: PIL capture successful - {frame.shape}")
                return frame
        except Exception as e:
            logger.error(f"ScreenCapture: PIL failed: {e}")
        return None
    
    def _capture_pyautogui(self, phys: QRect) -> Optional[np.ndarray]:
        """PyAutoGUI capture"""
        if not HAS_PYAUTOGUI:
            return None
            
        try:
            region = (phys.x(), phys.y(), phys.width(), phys.height())
            img = pyautogui.screenshot(region=region)
            if img:
                frame = cv2.cvtColor(np.array(img), cv2.COLOR_RGB2BGR)
                logger.info(f"ScreenCapture: PyAutoGUI capture successful - {frame.shape}")
                return frame
        except Exception as e:
            logger.error(f"ScreenCapture: PyAutoGUI failed: {e}")
        return None
    
    def _capture_linux(self, roi: QRect) -> Optional[np.ndarray]:
        """Linux capture via ImageMagick"""
        try:
            temp_path = os.path.join(tempfile.gettempdir(), "screenshot.png")
            cmd = ["import", "-window", "root", "-crop", f"{roi.width()}x{roi.height()}+{roi.x()}+{roi.y()}", temp_path]
            
            result = subprocess.run(cmd, capture_output=True, timeout=10)
            if result.returncode == 0 and os.path.exists(temp_path):
                frame = cv2.imread(temp_path)
                os.remove(temp_path)
                if frame is not None:
                    logger.info(f"ScreenCapture: Linux capture successful - {frame.shape}")
                    return frame
        except FileNotFoundError:
            logger.error("ScreenCapture: ImageMagick not found. Install: sudo apt-get install imagemagick")
        except Exception as e:
            logger.error(f"ScreenCapture: Linux capture failed: {e}")
        return None
    
    def _capture_macos(self, roi: QRect) -> Optional[np.ndarray]:
        """macOS capture via screencapture"""
        try:
            temp_path = os.path.join(tempfile.gettempdir(), "screenshot.png")
            cmd = ["screencapture", "-x", "-R", f"{roi.x()},{roi.y()},{roi.width()},{roi.height()}", temp_path]
            
            result = subprocess.run(cmd, capture_output=True, timeout=10)
            if result.returncode == 0 and os.path.exists(temp_path):
                frame = cv2.imread(temp_path)
                os.remove(temp_path)
                if frame is not None:
                    logger.info(f"ScreenCapture: macOS capture successful - {frame.shape}")
                    return frame
        except Exception as e:
            logger.error(f"ScreenCapture: macOS capture failed: {e}")
        return None






=====================
global_hotkeys.py
=====================




"""Global hotkey handler for MonteLab"""
import logging
from typing import Callable, Optional
from PySide6.QtCore import QObject, Signal

logger = logging.getLogger(__name__)

try:
    import keyboard
    HAS_KEYBOARD = True
    logger.info("keyboard library available for global hotkeys")
except ImportError:
    keyboard = None
    HAS_KEYBOARD = False
    logger.warning("keyboard library not available. Install: pip install keyboard")


class GlobalHotkeyManager(QObject):
    """Manages global hotkeys that work even when window is not focused"""
    
    numpad_pressed = Signal(int)
    enter_pressed = Signal()
    
    def __init__(self):
        super().__init__()
        self._registered = False
        self._active = False
        
        if not HAS_KEYBOARD:
            logger.error("GlobalHotkeyManager: keyboard library not available")
    
    def is_available(self) -> bool:
        return HAS_KEYBOARD
    
    def register_hotkeys(self):
        if not HAS_KEYBOARD:
            logger.error("Cannot register hotkeys: keyboard library not available")
            return False
        
        if self._registered:
            logger.warning("Hotkeys already registered")
            return True
        
        try:
            for i in range(1, 10):
                keyboard.add_hotkey(f'num {i}', lambda n=i: self._on_numpad(n), suppress=False)
                keyboard.add_hotkey(f'{i}', lambda n=i: self._on_numpad(n), suppress=False)
                logger.info(f"Registered hotkey: Numpad/{i} -> Select {i} opponent(s)")
            
            keyboard.add_hotkey('enter', self._on_enter, suppress=False)
            keyboard.add_hotkey('num enter', self._on_enter, suppress=False)
            logger.info("Registered hotkey: Enter -> Capture")
            
            self._registered = True
            self._active = True
            logger.info("Global hotkeys registered successfully")
            return True
            
        except Exception as e:
            logger.error(f"Failed to register hotkeys: {e}")
            return False
    
    def unregister_hotkeys(self):
        if not HAS_KEYBOARD or not self._registered:
            return
        
        try:
            keyboard.unhook_all()
            self._registered = False
            self._active = False
            logger.info("Global hotkeys unregistered")
        except Exception as e:
            logger.error(f"Failed to unregister hotkeys: {e}")
    
    def set_active(self, active: bool):
        self._active = active
        logger.info(f"Global hotkeys {'enabled' if active else 'disabled'}")
    
    def _on_numpad(self, number: int):
        if not self._active:
            return
        
        logger.info(f"HOTKEY: Numpad {number} pressed -> Setting {number} opponent(s)")
        self.numpad_pressed.emit(number)
    
    def _on_enter(self):
        if not self._active:
            return
        
        logger.info("HOTKEY: Enter pressed -> Triggering capture")
        self.enter_pressed.emit()


_hotkey_manager: Optional[GlobalHotkeyManager] = None


def get_hotkey_manager() -> GlobalHotkeyManager:
    global _hotkey_manager
    if _hotkey_manager is None:
        _hotkey_manager = GlobalHotkeyManager()
    return _hotkey_manager